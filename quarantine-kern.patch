diff --git a/arch/alpha/kernel/osf_sys.c b/arch/alpha/kernel/osf_sys.c
index 8bbeebb73..910725eb3 100644
--- a/arch/alpha/kernel/osf_sys.c
+++ b/arch/alpha/kernel/osf_sys.c
@@ -183,7 +183,7 @@ SYSCALL_DEFINE6(osf_mmap, unsigned long, addr, unsigned long, len,
 #if 0
 	if (flags & (_MAP_HASSEMAPHORE | _MAP_INHERIT | _MAP_UNALIGNED))
 		printk("%s: unimplemented OSF mmap flags %04lx\n", 
-			current->comm, flags);
+			sysiso_current->comm, flags);
 #endif
 	if ((off + PAGE_ALIGN(len)) < off)
 		goto out;
@@ -1092,12 +1092,12 @@ SYSCALL_DEFINE2(osf_getrusage, int, who, struct rusage32 __user *, ru)
 		stime_jiffies = nsecs_to_jiffies(stime);
 		jiffies_to_timeval32(utime_jiffies, &r.ru_utime);
 		jiffies_to_timeval32(stime_jiffies, &r.ru_stime);
-		r.ru_minflt = current->min_flt;
-		r.ru_majflt = current->maj_flt;
+		r.ru_minflt = sysiso_current->min_flt;
+		r.ru_majflt = sysiso_current->maj_flt;
 		break;
 	case RUSAGE_CHILDREN:
-		utime_jiffies = nsecs_to_jiffies(current->signal->cutime);
-		stime_jiffies = nsecs_to_jiffies(current->signal->cstime);
+		utime_jiffies = nsecs_to_jiffies(sysiso_current->signal->cutime);
+		stime_jiffies = nsecs_to_jiffies(sysiso_current->signal->cstime);
 		jiffies_to_timeval32(utime_jiffies, &r.ru_utime);
 		jiffies_to_timeval32(stime_jiffies, &r.ru_stime);
 		r.ru_minflt = current->signal->cmin_flt;
@@ -1238,7 +1238,7 @@ arch_get_unmapped_area(struct file *filp, unsigned long addr,
 	unsigned long limit;
 
 	/* "32 bit" actually means 31 bit, since pointers sign extend.  */
-	if (current->personality & ADDR_LIMIT_32BIT)
+	if (sysiso_current->personality & ADDR_LIMIT_32BIT)
 		limit = 0x80000000;
 	else
 		limit = TASK_SIZE;
@@ -1300,7 +1300,7 @@ SYSCALL_DEFINE3(osf_readv, unsigned long, fd,
 		const struct iovec __user *, vector, unsigned long, count)
 {
 #ifdef CONFIG_OSF4_COMPAT
-	if (unlikely(personality(current->personality) == PER_OSF4))
+	if (unlikely(personality(sysiso_current->personality) == PER_OSF4))
 		if (osf_fix_iov_len(vector, count))
 			return -EFAULT;
 #endif
@@ -1312,7 +1312,7 @@ SYSCALL_DEFINE3(osf_writev, unsigned long, fd,
 		const struct iovec __user *, vector, unsigned long, count)
 {
 #ifdef CONFIG_OSF4_COMPAT
-	if (unlikely(personality(current->personality) == PER_OSF4))
+	if (unlikely(personality(sysiso_current->personality) == PER_OSF4))
 		if (osf_fix_iov_len(vector, count))
 			return -EFAULT;
 #endif
diff --git a/arch/alpha/kernel/pci-sysfs.c b/arch/alpha/kernel/pci-sysfs.c
index 5808a66e2..9583bb38b 100644
--- a/arch/alpha/kernel/pci-sysfs.c
+++ b/arch/alpha/kernel/pci-sysfs.c
@@ -47,7 +47,7 @@ static int __pci_mmap_fits(struct pci_dev *pdev, int num,
 		return 1;
 	WARN(1, "process \"%s\" tried to map%s 0x%08lx-0x%08lx on %s BAR %d "
 		"(size 0x%08lx)\n",
-		current->comm, sparse ? " sparse" : "", start, start + nr,
+		sysiso_current->comm, sparse ? " sparse" : "", start, start + nr,
 		pci_name(pdev), num, size);
 	return 0;
 }
@@ -267,7 +267,7 @@ static int __legacy_mmap_fits(struct pci_controller *hose,
 		return 1;
 	WARN(1, "process \"%s\" tried to map%s 0x%08lx-0x%08lx on hose %d "
 		"(size 0x%08lx)\n",
-		current->comm, sparse ? " sparse" : "", start, start + nr,
+		sysiso_current->comm, sparse ? " sparse" : "", start, start + nr,
 		hose->index, size);
 	return 0;
 }
diff --git a/arch/alpha/kernel/signal.c b/arch/alpha/kernel/signal.c
index bc077baba..44a06cbcc 100644
--- a/arch/alpha/kernel/signal.c
+++ b/arch/alpha/kernel/signal.c
@@ -152,7 +152,7 @@ restore_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs)
 	struct switch_stack *sw = (struct switch_stack *)regs - 1;
 	long i, err = __get_user(regs->pc, &sc->sc_pc);
 
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	sw->r26 = (unsigned long) ret_from_sys_call;
 
@@ -364,7 +364,7 @@ setup_frame(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)
 	
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->pc, regs->r26);
+		sysiso_current->comm, current->pid, frame, regs->pc, regs->r26);
 #endif
 	return 0;
 }
@@ -418,7 +418,7 @@ setup_rt_frame(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->pc, regs->r26);
+		sysiso_current->comm, current->pid, frame, regs->pc, regs->r26);
 #endif
 
 	return 0;
diff --git a/arch/alpha/kernel/traps.c b/arch/alpha/kernel/traps.c
index e80510640..a49170c03 100644
--- a/arch/alpha/kernel/traps.c
+++ b/arch/alpha/kernel/traps.c
@@ -181,7 +181,8 @@ die_if_kernel(char * str, struct pt_regs *regs, long err, unsigned long *r9_15)
 #ifdef CONFIG_SMP
 	printk("CPU %d ", hard_smp_processor_id());
 #endif
-	printk("%s(%d): %s %ld\n", current->comm, task_pid_nr(current), str, err);
+	printk("%s(%d): %s %ld\n", sysiso_current->comm, task_pid_nr(sysiso_current),
+	       str, err);
 	dik_show_regs(regs, r9_15);
 	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
 	dik_show_trace((unsigned long *)(regs+1), KERN_DEFAULT);
@@ -599,7 +600,7 @@ do_entUna(void * va, unsigned long opcode, unsigned long reg,
  	 */
 
 	printk("%s(%d): unhandled unaligned exception\n",
-	       current->comm, task_pid_nr(current));
+	       sysiso_current->comm, task_pid_nr(current));
 
 	printk("pc = [<%016lx>]  ra = [<%016lx>]  ps = %04lx\n",
 	       pc, una_reg(26), regs->ps);
@@ -735,7 +736,7 @@ do_entUnaUser(void __user * va, unsigned long opcode,
 	if (!(current_thread_info()->status & TS_UAC_NOPRINT)) {
 		if (__ratelimit(&ratelimit)) {
 			printk("%s(%d): unaligned trap at %016lx: %p %lx %ld\n",
-			       current->comm, task_pid_nr(current),
+			       sysiso_current->comm, task_pid_nr(sysiso_current),
 			       regs->pc - 4, va, opcode, reg);
 		}
 	}
diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c
index cb2f88502..8c1bac6ac 100644
--- a/arch/arc/kernel/signal.c
+++ b/arch/arc/kernel/signal.c
@@ -198,7 +198,7 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	struct pt_regs *regs = current_pt_regs();
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/* Since we stacked the signal on a word boundary,
 	 * then 'sp' should be word aligned here.  If it's
diff --git a/arch/arc/kernel/unaligned.c b/arch/arc/kernel/unaligned.c
index d63ebd81f..2404c31b5 100644
--- a/arch/arc/kernel/unaligned.c
+++ b/arch/arc/kernel/unaligned.c
@@ -211,11 +211,13 @@ int misaligned_fixup(unsigned long address, struct pt_regs *regs,
 			     " performance significantly\n. To enable further"
 			     " logging of such instances, please \n"
 			     " echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",
-			     get_task_comm(buf, current), task_pid_nr(current));
+			     get_task_comm(buf, current),
+			     task_pid_nr(sysiso_current));
 	} else {
 		/* Add rate limiting if it gets down to it */
 		pr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",
-			get_task_comm(buf, current), task_pid_nr(current),
+			get_task_comm(buf, current),
+			task_pid_nr(sysiso_current),
 			address, regs->ret);
 
 	}
diff --git a/arch/arm/common/bL_switcher.c b/arch/arm/common/bL_switcher.c
index 9a9aa5354..88d5a239b 100644
--- a/arch/arm/common/bL_switcher.c
+++ b/arch/arm/common/bL_switcher.c
@@ -278,7 +278,7 @@ static int bL_switcher_thread(void *arg)
 	complete(&t->started);
 
 	do {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			flush_signals(current);
 		wait_event_interruptible(t->wq,
 				t->wanted_cluster != -1 ||
diff --git a/arch/arm/kernel/elf.c b/arch/arm/kernel/elf.c
index 254ab7138..3910d1dae 100644
--- a/arch/arm/kernel/elf.c
+++ b/arch/arm/kernel/elf.c
@@ -43,7 +43,7 @@ EXPORT_SYMBOL(elf_check_arch);
 void elf_set_personality(const struct elf32_hdr *x)
 {
 	unsigned int eflags = x->e_flags;
-	unsigned int personality = current->personality & ~PER_MASK;
+	unsigned int personality = sysiso_current->personality & ~PER_MASK;
 
 	/*
 	 * We only support Linux ELF executables, so always set the
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index a41e27ace..c97188bbf 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -188,7 +188,7 @@ asmlinkage int sys_sigreturn(struct pt_regs *regs)
 	struct sigframe __user *frame;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Since we stacked the signal on a 64-bit boundary,
@@ -218,7 +218,7 @@ asmlinkage int sys_rt_sigreturn(struct pt_regs *regs)
 	struct rt_sigframe __user *frame;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Since we stacked the signal on a 64-bit boundary,
@@ -326,7 +326,7 @@ setup_return(struct pt_regs *regs, struct ksignal *ksig,
 	unsigned int idx, thumb = 0;
 	unsigned long cpsr = regs->ARM_cpsr & ~(PSR_f | PSR_E_BIT);
 	bool fdpic = IS_ENABLED(CONFIG_BINFMT_ELF_FDPIC) &&
-		     (current->personality & FDPIC_FUNCPTRS);
+		     (sysiso_current->personality & FDPIC_FUNCPTRS);
 
 	if (fdpic) {
 		unsigned long __user *fdpic_func_desc =
diff --git a/arch/arm/kernel/swp_emulate.c b/arch/arm/kernel/swp_emulate.c
index 6166ba38b..885dd20d3 100644
--- a/arch/arm/kernel/swp_emulate.c
+++ b/arch/arm/kernel/swp_emulate.c
@@ -135,7 +135,7 @@ static int emulate_swpX(unsigned int address, unsigned int *data,
 			__user_swp_asm(*data, address, res, temp);
 		uaccess_restore(__ua_flags);
 
-		if (likely(res != -EAGAIN) || signal_pending(current))
+		if (likely(res != -EAGAIN) || signal_pending(sysiso_current))
 			break;
 
 		cond_resched();
@@ -178,10 +178,10 @@ static int swp_handler(struct pt_regs *regs, unsigned int instr)
 		return -EINVAL;
 	}
 
-	if (current->pid != previous_pid) {
+	if (sysiso_current->pid != previous_pid) {
 		pr_debug("\"%s\" (%ld) uses deprecated SWP{B} instruction\n",
-			 current->comm, (unsigned long)current->pid);
-		previous_pid = current->pid;
+			 sysiso_current->comm, (unsigned long) sysiso_current->pid);
+		previous_pid = sysiso_current->pid;
 	}
 
 	address = regs->uregs[EXTRACT_REG_NUM(instr, RN_OFFSET)];
diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c
index 68112c172..99ced8b79 100644
--- a/arch/arm/kernel/sys_oabi-compat.c
+++ b/arch/arm/kernel/sys_oabi-compat.c
@@ -343,7 +343,7 @@ asmlinkage long sys_oabi_semtimedop(int semid,
 	long err;
 	int i;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 	if (nsops > ns->sc_semopm)
 		return -E2BIG;
 	if (nsops < 1 || nsops > SEMOPM)
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 195dff58b..e8f1426a0 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -258,7 +258,7 @@ void show_stack(struct task_struct *tsk, unsigned long *sp, const char *loglvl)
 
 static int __die(const char *str, int err, struct pt_regs *regs)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	static int die_counter;
 	int ret;
 
@@ -471,7 +471,7 @@ asmlinkage void do_undefinstr(struct pt_regs *regs)
 #ifdef CONFIG_DEBUG_USER
 	if (user_debug & UDBG_UNDEFINED) {
 		pr_info("%s (%d): undefined instruction: pc=%p\n",
-			current->comm, task_pid_nr(current), pc);
+			sysiso_current->comm, task_pid_nr(sysiso_current), pc);
 		__show_regs(regs);
 		dump_instr(KERN_INFO, regs);
 	}
@@ -525,7 +525,7 @@ asmlinkage void bad_mode(struct pt_regs *regs, int reason)
 
 static int bad_syscall(int n, struct pt_regs *regs)
 {
-	if ((current->personality & PER_MASK) != PER_LINUX) {
+	if ((sysiso_current->personality & PER_MASK) != PER_LINUX) {
 		send_sig(SIGSEGV, current, 1);
 		return regs->ARM_r0;
 	}
@@ -533,7 +533,7 @@ static int bad_syscall(int n, struct pt_regs *regs)
 #ifdef CONFIG_DEBUG_USER
 	if (user_debug & UDBG_SYSCALL) {
 		pr_err("[%d] %s: obsolete system call %08x.\n",
-			task_pid_nr(current), current->comm, n);
+			task_pid_nr(sysiso_current), sysiso_current->comm, n);
 		dump_instr(KERN_ERR, regs);
 	}
 #endif
@@ -554,7 +554,7 @@ __do_cache_op(unsigned long start, unsigned long end)
 	do {
 		unsigned long chunk = min(PAGE_SIZE, end - start);
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return 0;
 
 		ret = flush_icache_user_range(start, start + chunk);
@@ -653,7 +653,7 @@ asmlinkage int arm_syscall(int no, struct pt_regs *regs)
 	 */
 	if (user_debug & UDBG_SYSCALL) {
 		pr_err("[%d] %s: arm syscall %d\n",
-		       task_pid_nr(current), current->comm, no);
+		       task_pid_nr(sysiso_current), sysiso_current->comm, no);
 		dump_instr(KERN_ERR, regs);
 		if (user_mode(regs)) {
 			__show_regs(regs);
@@ -719,7 +719,8 @@ baddataabort(int code, unsigned long instr, struct pt_regs *regs)
 	if (user_debug & UDBG_BADABORT) {
 		pr_err("8<--- cut here ---\n");
 		pr_err("[%d] %s: bad data abort: code %d instr 0x%08lx\n",
-		       task_pid_nr(current), current->comm, code, instr);
+		       task_pid_nr(sysiso_current), sysiso_current->comm, code,
+		       instr);
 		dump_instr(KERN_ERR, regs);
 		show_pte(KERN_ERR, current->mm, addr);
 	}
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index ea81e89e7..f3a7ef215 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -965,8 +965,8 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 
 	if (ai_usermode & UM_WARN)
 		printk("Alignment trap: %s (%d) PC=0x%08lx Instr=0x%0*x "
-		       "Address=0x%08lx FSR 0x%03x\n", current->comm,
-			task_pid_nr(current), instrptr,
+		       "Address=0x%08lx FSR 0x%03x\n", sysiso_current->comm,
+			task_pid_nr(sysiso_current), instrptr,
 			isize << 1,
 			isize == 2 ? tinstr : instr,
 		        addr, fsr);
diff --git a/arch/arm/nwfpe/fpmodule.c b/arch/arm/nwfpe/fpmodule.c
index 1122ed459..70e1f3bce 100644
--- a/arch/arm/nwfpe/fpmodule.c
+++ b/arch/arm/nwfpe/fpmodule.c
@@ -136,7 +136,7 @@ void float_raise(signed char flags)
 	if (flags & debug)
  		printk(KERN_DEBUG
 		       "NWFPE: %s[%d] takes exception %08x at %ps from %08lx\n",
-		       current->comm, current->pid, flags,
+		       sysiso_current->comm, sysiso_current->pid, flags,
 		       __builtin_return_address(0), GET_USERREG()->ARM_pc);
 #endif
 
diff --git a/arch/arm/probes/uprobes/core.c b/arch/arm/probes/uprobes/core.c
index f5f790c6e..37fe78356 100644
--- a/arch/arm/probes/uprobes/core.c
+++ b/arch/arm/probes/uprobes/core.c
@@ -132,7 +132,7 @@ void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 
 int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	if (auprobe->prehandler)
 		auprobe->prehandler(auprobe, &utask->autask, regs);
@@ -146,7 +146,7 @@ int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	WARN_ON_ONCE(current->thread.trap_no != UPROBE_TRAP_NR);
 
@@ -169,7 +169,7 @@ bool arch_uprobe_xol_was_trapped(struct task_struct *t)
 
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	current->thread.trap_no = utask->autask.saved_trap_no;
 	instruction_pointer_set(regs, utask->vaddr);
diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h
index 190b494e2..7c1fa2298 100644
--- a/arch/arm64/include/asm/uaccess.h
+++ b/arch/arm64/include/asm/uaccess.h
@@ -44,7 +44,7 @@ static inline unsigned long __range_ok(const void __user *addr, unsigned long si
 	 * the user address before checking.
 	 */
 	if (IS_ENABLED(CONFIG_ARM64_TAGGED_ADDR_ABI) &&
-	    (current->flags & PF_KTHREAD || test_thread_flag(TIF_TAGGED_ADDR)))
+	    (sysiso_current->flags & PF_KTHREAD || test_thread_flag(TIF_TAGGED_ADDR)))
 		addr = untagged_addr(addr);
 
 	__chk_user_ptr(addr);
diff --git a/arch/arm64/kernel/armv8_deprecated.c b/arch/arm64/kernel/armv8_deprecated.c
index 0e86e8b9c..10ac6fe22 100644
--- a/arch/arm64/kernel/armv8_deprecated.c
+++ b/arch/arm64/kernel/armv8_deprecated.c
@@ -335,7 +335,7 @@ static int emulate_swpX(unsigned int address, unsigned int *data,
 		else
 			__user_swp_asm(*data, address, res, temp, temp2);
 
-		if (likely(res != -EAGAIN) || signal_pending(current))
+		if (likely(res != -EAGAIN) || signal_pending(sysiso_current))
 			break;
 
 		cond_resched();
@@ -423,7 +423,8 @@ static int swp_handler(struct pt_regs *regs, u32 instr)
 		trace_instruction_emulation("swp", regs->pc);
 
 	pr_warn_ratelimited("\"%s\" (%ld) uses obsolete SWP{B} instruction at 0x%llx\n",
-			current->comm, (unsigned long)current->pid, regs->pc);
+			sysiso_current->comm, (unsigned long) sysiso_current->pid,
+			regs->pc);
 
 	arm64_skip_faulting_instruction(regs, 4);
 	return 0;
@@ -504,7 +505,8 @@ static int cp15barrier_handler(struct pt_regs *regs, u32 instr)
 
 ret:
 	pr_warn_ratelimited("\"%s\" (%ld) uses deprecated CP15 Barrier instruction at 0x%llx\n",
-			current->comm, (unsigned long)current->pid, regs->pc);
+			sysiso_current->comm, (unsigned long) sysiso_current->pid,
+			regs->pc);
 
 	arm64_skip_faulting_instruction(regs, 4);
 	return 0;
@@ -572,7 +574,8 @@ static int compat_setend_handler(struct pt_regs *regs, u32 big_endian)
 
 	trace_instruction_emulation(insn, regs->pc);
 	pr_warn_ratelimited("\"%s\" (%ld) uses deprecated setend instruction at 0x%llx\n",
-			current->comm, (unsigned long)current->pid, regs->pc);
+			sysiso_current->comm, (unsigned long) sysiso_current->pid,
+			regs->pc);
 
 	return 0;
 }
diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c
index 87731fea5..93a867193 100644
--- a/arch/arm64/kernel/cpuinfo.c
+++ b/arch/arm64/kernel/cpuinfo.c
@@ -136,7 +136,7 @@ static const char *const compat_hwcap2_str[] = {
 static int c_show(struct seq_file *m, void *v)
 {
 	int i, j;
-	bool compat = personality(current->personality) == PER_LINUX32;
+	bool compat = personality(sysiso_current->personality) == PER_LINUX32;
 
 	for_each_online_cpu(i) {
 		struct cpuinfo_arm64 *cpuinfo = &per_cpu(cpu_data, i);
diff --git a/arch/arm64/kernel/probes/uprobes.c b/arch/arm64/kernel/probes/uprobes.c
index 9be668f3f..a48a169fb 100644
--- a/arch/arm64/kernel/probes/uprobes.c
+++ b/arch/arm64/kernel/probes/uprobes.c
@@ -61,7 +61,7 @@ int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,
 
 int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	/* Initialize with an invalid fault code to detect if ol insn trapped */
 	current->thread.fault_code = UPROBE_INV_FAULT_CODE;
@@ -76,7 +76,7 @@ int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	WARN_ON_ONCE(current->thread.fault_code != UPROBE_INV_FAULT_CODE);
 
@@ -119,7 +119,7 @@ bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	/*
 	 * Task has received a fatal signal, so reset back to probbed
@@ -177,7 +177,7 @@ static int uprobe_breakpoint_handler(struct pt_regs *regs,
 static int uprobe_single_step_handler(struct pt_regs *regs,
 		unsigned int esr)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	WARN_ON(utask && (instruction_pointer(regs) != utask->xol_vaddr + 4));
 	if (uprobe_post_sstep_notifier(regs))
diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index 40adb8cdb..b5d82f99e 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -558,7 +558,7 @@ unsigned long get_wchan(struct task_struct *p)
 
 unsigned long arch_align_stack(unsigned long sp)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		sp -= get_random_int() & ~PAGE_MASK;
 	return sp & ~0xf;
 }
diff --git a/arch/arm64/kernel/signal.c b/arch/arm64/kernel/signal.c
index c287b9407..442c4f8c6 100644
--- a/arch/arm64/kernel/signal.c
+++ b/arch/arm64/kernel/signal.c
@@ -538,7 +538,7 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	struct rt_sigframe __user *frame;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Since we stacked the signal on a 128-bit boundary, then 'sp' should
diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c
index d984282b9..a5b7f92b6 100644
--- a/arch/arm64/kernel/signal32.c
+++ b/arch/arm64/kernel/signal32.c
@@ -231,7 +231,7 @@ COMPAT_SYSCALL_DEFINE0(sigreturn)
 	struct compat_sigframe __user *frame;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Since we stacked the signal on a 64-bit boundary,
@@ -262,7 +262,7 @@ COMPAT_SYSCALL_DEFINE0(rt_sigreturn)
 	struct compat_rt_sigframe __user *frame;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Since we stacked the signal on a 64-bit boundary,
diff --git a/arch/arm64/kernel/sys_compat.c b/arch/arm64/kernel/sys_compat.c
index db5159a30..665da5e15 100644
--- a/arch/arm64/kernel/sys_compat.c
+++ b/arch/arm64/kernel/sys_compat.c
@@ -29,7 +29,7 @@ __do_compat_cache_op(unsigned long start, unsigned long end)
 	do {
 		unsigned long chunk = min(PAGE_SIZE, end - start);
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return 0;
 
 		if (cpus_have_const_cap(ARM64_WORKAROUND_1542419)) {
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index b03e383d9..25773a503 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -242,7 +242,7 @@ static void arm64_show_signal(int signo, const char *str)
 {
 	static DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,
 				      DEFAULT_RATELIMIT_BURST);
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	unsigned int esr = tsk->thread.fault_code;
 	struct pt_regs *regs = task_pt_regs(tsk);
 
diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c
index a61fc4f98..6b085d321 100644
--- a/arch/arm64/kernel/vdso.c
+++ b/arch/arm64/kernel/vdso.c
@@ -157,7 +157,7 @@ int vdso_join_timens(struct task_struct *task, struct time_namespace *ns)
 static struct page *find_timens_vvar_page(struct vm_area_struct *vma)
 {
 	if (likely(vma->vm_mm == current->mm))
-		return current->nsproxy->time_ns->vvar_page;
+		return sysiso_current->nsproxy->time_ns->vvar_page;
 
 	/*
 	 * VM_PFNMAP | VM_IO protect .fault() handler from being called
diff --git a/arch/arm64/kvm/reset.c b/arch/arm64/kvm/reset.c
index 5ce36b0a3..f0c847e26 100644
--- a/arch/arm64/kvm/reset.c
+++ b/arch/arm64/kvm/reset.c
@@ -374,7 +374,7 @@ int kvm_arm_setup_stage2(struct kvm *kvm, unsigned long type)
 		phys_shift = KVM_PHYS_SHIFT;
 		if (phys_shift > kvm_ipa_limit) {
 			pr_warn_once("%s using unsupported default IPA limit, upgrade your VMM\n",
-				     current->comm);
+				     sysiso_current->comm);
 			return -EINVAL;
 		}
 	}
diff --git a/arch/csky/kernel/probes/uprobes.c b/arch/csky/kernel/probes/uprobes.c
index 1a9e0961b..f30d9746a 100644
--- a/arch/csky/kernel/probes/uprobes.c
+++ b/arch/csky/kernel/probes/uprobes.c
@@ -47,7 +47,7 @@ int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,
 
 int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	utask->autask.saved_trap_no = current->thread.trap_no;
 	current->thread.trap_no = UPROBE_TRAP_NR;
@@ -61,7 +61,7 @@ int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	WARN_ON_ONCE(current->thread.trap_no != UPROBE_TRAP_NR);
 
@@ -99,7 +99,7 @@ bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	/*
 	 * Task has received a fatal signal, so reset back to probbed
diff --git a/arch/csky/kernel/ptrace.c b/arch/csky/kernel/ptrace.c
index 1a5f54e0d..5406efbdb 100644
--- a/arch/csky/kernel/ptrace.c
+++ b/arch/csky/kernel/ptrace.c
@@ -466,7 +466,7 @@ static void show_tlb(void)
 void show_regs(struct pt_regs *fp)
 {
 	pr_info("\nCURRENT PROCESS:\n\n");
-	pr_info("COMM=%s PID=%d\n", current->comm, current->pid);
+	pr_info("COMM=%s PID=%d\n", sysiso_current->comm, sysiso_current->pid);
 
 	if (current->mm) {
 		pr_info("TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",
diff --git a/arch/csky/kernel/signal.c b/arch/csky/kernel/signal.c
index c7b763d2f..4eac8f7d4 100644
--- a/arch/csky/kernel/signal.c
+++ b/arch/csky/kernel/signal.c
@@ -73,7 +73,7 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	sigset_t set;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	frame = (struct rt_sigframe __user *)regs->usp;
 
diff --git a/arch/h8300/kernel/signal.c b/arch/h8300/kernel/signal.c
index 75a1c36b1..2762f6fb1 100644
--- a/arch/h8300/kernel/signal.c
+++ b/arch/h8300/kernel/signal.c
@@ -79,7 +79,7 @@ restore_sigcontext(struct sigcontext *usc, int *pd0)
 	unsigned int er0;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/* restore passed registers */
 #define COPY(r)  do { err |= get_user(regs->r, &usc->sc_##r); } while (0)
diff --git a/arch/h8300/kernel/traps.c b/arch/h8300/kernel/traps.c
index bdbe988d8..fba467a81 100644
--- a/arch/h8300/kernel/traps.c
+++ b/arch/h8300/kernel/traps.c
@@ -55,7 +55,7 @@ static void dump(struct pt_regs *fp)
 	int		i;
 
 	pr_info("\nCURRENT PROCESS:\n\n");
-	pr_info("COMM=%s PID=%d\n", current->comm, current->pid);
+	pr_info("COMM=%s PID=%d\n", sysiso_current->comm, sysiso_current->pid);
 	if (current->mm) {
 		pr_info("TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",
 			(int) current->mm->start_code,
diff --git a/arch/hexagon/kernel/signal.c b/arch/hexagon/kernel/signal.c
index 94cc7ff52..6ee26a80c 100644
--- a/arch/hexagon/kernel/signal.c
+++ b/arch/hexagon/kernel/signal.c
@@ -228,7 +228,7 @@ asmlinkage int sys_rt_sigreturn(void)
 	sigset_t blocked;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	frame = (struct rt_sigframe __user *)pt_psp(regs);
 	if (!access_ok(frame, sizeof(*frame)))
diff --git a/arch/ia64/kernel/crash.c b/arch/ia64/kernel/crash.c
index 76730f346..5d5b61944 100644
--- a/arch/ia64/kernel/crash.c
+++ b/arch/ia64/kernel/crash.c
@@ -44,7 +44,7 @@ crash_save_this_cpu(void)
 
 	elf_greg_t *dst = (elf_greg_t *)&(prstatus->pr_reg);
 	memset(prstatus, 0, sizeof(*prstatus));
-	prstatus->common.pr_pid = current->pid;
+	prstatus->common.pr_pid = sysiso_current->pid;
 
 	ia64_dump_cpu_regs(dst);
 	cfm = dst[43];
diff --git a/arch/ia64/kernel/fsys.S b/arch/ia64/kernel/fsys.S
index 2094f3249..99a78b436 100644
--- a/arch/ia64/kernel/fsys.S
+++ b/arch/ia64/kernel/fsys.S
@@ -64,7 +64,7 @@ ENTRY(fsys_getpid)
 	.body
 	add r17=IA64_TASK_SIGNAL_OFFSET,r16
 	;;
-	ld8 r17=[r17]				// r17 = current->signal
+	ld8 r17=[r17]				// r17 = sysiso_current->signal
 	add r9=TI_FLAGS+IA64_TASK_SIZE,r16
 	;;
 	ld4 r9=[r9]
diff --git a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
index e628a8860..dbf7f0a82 100644
--- a/arch/ia64/kernel/mca.c
+++ b/arch/ia64/kernel/mca.c
@@ -875,10 +875,10 @@ copy_reg(const u64 *fr, u64 fnat, unsigned long *tr, unsigned long *tnat)
 static void
 ia64_mca_modify_comm(const struct task_struct *previous_current)
 {
-	char *p, comm[sizeof(current->comm)];
+	char *p, comm[sizeof(sysiso_current->comm)];
 	if (previous_current->pid)
 		snprintf(comm, sizeof(comm), "%s %d",
-			current->comm, previous_current->pid);
+			sysiso_current->comm, previous_current->pid);
 	else {
 		int l;
 		if ((p = strchr(previous_current->comm, ' ')))
@@ -886,10 +886,10 @@ ia64_mca_modify_comm(const struct task_struct *previous_current)
 		else
 			l = strlen(previous_current->comm);
 		snprintf(comm, sizeof(comm), "%s %*s %d",
-			current->comm, l, previous_current->comm,
+			sysiso_current->comm, l, previous_current->comm,
 			task_thread_info(previous_current)->cpu);
 	}
-	memcpy(current->comm, comm, sizeof(current->comm));
+	memcpy(sysiso_current->comm, comm, sizeof(sysiso_current->comm));
 }
 
 static void
@@ -990,7 +990,7 @@ ia64_mca_modify_original_stack(struct pt_regs *regs,
 
 	previous_current = curr_task(cpu);
 	ia64_set_curr_task(cpu, current);
-	if ((p = strchr(current->comm, ' ')))
+	if ((p = strchr(sysiso_current->comm, ' ')))
 		*p = '\0';
 
 	/* Best effort attempt to cope with MCA/INIT delivered while in
diff --git a/arch/ia64/kernel/mca_drv.c b/arch/ia64/kernel/mca_drv.c
index 5bfc79be4..212cec9cc 100644
--- a/arch/ia64/kernel/mca_drv.c
+++ b/arch/ia64/kernel/mca_drv.c
@@ -158,9 +158,9 @@ mca_handler_bh(unsigned long paddr, void *iip, unsigned long ipsr)
 	ia64_mlogbuf_dump();
 	printk(KERN_ERR "OS_MCA: process [cpu %d, pid: %d, uid: %d, "
 		"iip: %p, psr: 0x%lx,paddr: 0x%lx](%s) encounters MCA.\n",
-	       raw_smp_processor_id(), current->pid,
-		from_kuid(&init_user_ns, current_uid()),
-		iip, ipsr, paddr, current->comm);
+	       raw_smp_processor_id(), sysiso_current->pid,
+	       from_kuid(&init_user_ns, current_uid()),
+	       iip, ipsr, paddr, sysiso_current->comm);
 
 	spin_lock(&mca_bh_lock);
 	switch (mca_page_isolate(paddr)) {
diff --git a/arch/ia64/kernel/signal.c b/arch/ia64/kernel/signal.c
index c1b299760..102fa5439 100644
--- a/arch/ia64/kernel/signal.c
+++ b/arch/ia64/kernel/signal.c
@@ -47,7 +47,7 @@ restore_sigcontext (struct sigcontext __user *sc, struct sigscratch *scr)
 	long err;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/* restore scratch that always needs gets updated during signal delivery: */
 	err  = __get_user(flags, &sc->sc_flags);
@@ -145,7 +145,7 @@ ia64_rt_sigreturn (struct sigscratch *scr)
 
 #if DEBUG_SIG
 	printk("SIG return (%s:%d): sp=%lx ip=%lx\n",
-	       current->comm, current->pid, scr->pt.r12, scr->pt.cr_iip);
+	       sysiso_current->comm, current->pid, scr->pt.r12, scr->pt.cr_iip);
 #endif
 	if (restore_altstack(&sc->sc_stack))
 		goto give_sigsegv;
@@ -309,7 +309,7 @@ setup_frame(struct ksignal *ksig, sigset_t *set, struct sigscratch *scr)
 
 #if DEBUG_SIG
 	printk("SIG deliver (%s:%d): sig=%d sp=%lx ip=%lx handler=%p\n",
-	       current->comm, current->pid, ksig->sig, scr->pt.r12, frame->sc.sc_ip, frame->handler);
+	       sysiso_current->comm, current->pid, ksig->sig, scr->pt.r12, frame->sc.sc_ip, frame->handler);
 #endif
 	return 0;
 }
diff --git a/arch/ia64/kernel/traps.c b/arch/ia64/kernel/traps.c
index e13cb9059..9e78ddf4d 100644
--- a/arch/ia64/kernel/traps.c
+++ b/arch/ia64/kernel/traps.c
@@ -65,7 +65,8 @@ die (const char *str, struct pt_regs *regs, long err)
 
 	if (++die.lock_owner_depth < 3) {
 		printk("%s[%d]: %s %ld [%d]\n",
-		current->comm, task_pid_nr(current), str, err, ++die_counter);
+		sysiso_current->comm, task_pid_nr(sysiso_current), str, err,
+		++die_counter);
 		if (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV)
 	            != NOTIFY_STOP)
 			show_regs(regs);
@@ -320,7 +321,10 @@ handle_fpu_swa (int fp_fault, struct pt_regs *regs, unsigned long isr)
 				last.time = current_jiffies + 5 * HZ;
 				printk(KERN_WARNING
 		       			"%s(%d): floating-point assist fault at ip %016lx, isr %016lx\n",
-		       			current->comm, task_pid_nr(current), regs->cr_iip + ia64_psr(regs)->ri, isr);
+		       			sysiso_current->comm,
+		       			task_pid_nr(sysiso_current),
+		       			regs->cr_iip + ia64_psr(regs)->ri,
+		       			isr);
 			}
 		}
 	}
@@ -451,7 +455,7 @@ ia64_fault (unsigned long vector, unsigned long isr, unsigned long ifa,
 		if (code == 8) {
 # ifdef CONFIG_IA64_PRINT_HAZARDS
 			printk("%s[%d]: possible hazard @ ip=%016lx (pr = %016lx)\n",
-			       current->comm, task_pid_nr(current),
+			       sysiso_current->comm, task_pid_nr(sysiso_current),
 			       regs.cr_iip + ia64_psr(&regs)->ri, regs.pr);
 # endif
 			return;
diff --git a/arch/ia64/kernel/unaligned.c b/arch/ia64/kernel/unaligned.c
index 6c1a8951d..8d78b29cc 100644
--- a/arch/ia64/kernel/unaligned.c
+++ b/arch/ia64/kernel/unaligned.c
@@ -1331,8 +1331,8 @@ ia64_handle_unaligned (unsigned long ifa, struct pt_regs *regs)
 			size_t len;
 
 			len = sprintf(buf, "%s(%d): unaligned access to 0x%016lx, "
-				      "ip=0x%016lx\n\r", current->comm,
-				      task_pid_nr(current),
+				      "ip=0x%016lx\n\r", sysiso_current->comm,
+				      task_pid_nr(sysiso_current),
 				      ifa, regs->cr_iip + ipsr->ri);
 			/*
 			 * Don't call tty_write_message() if we're in the kernel; we might
@@ -1357,7 +1357,8 @@ ia64_handle_unaligned (unsigned long ifa, struct pt_regs *regs)
 				       "administrator\n"
 				       "echo 0 > /proc/sys/kernel/ignore-"
 				       "unaligned-usertrap to re-enable\n",
-				       current->comm, task_pid_nr(current));
+				       sysiso_current->comm,
+				       task_pid_nr(sysiso_current));
 			}
 		}
 	} else {
diff --git a/arch/ia64/mm/init.c b/arch/ia64/mm/init.c
index 5c6da8d83..9af4bec52 100644
--- a/arch/ia64/mm/init.c
+++ b/arch/ia64/mm/init.c
@@ -121,7 +121,7 @@ ia64_init_addr_space (void)
 	}
 
 	/* map NaT-page at address zero to speed up speculative dereferencing of NULL: */
-	if (!(current->personality & MMAP_PAGE_ZERO)) {
+	if (!(sysiso_current->personality & MMAP_PAGE_ZERO)) {
 		vma = vm_area_alloc(current->mm);
 		if (vma) {
 			vma_set_anonymous(vma);
diff --git a/arch/m68k/coldfire/sltimers.c b/arch/m68k/coldfire/sltimers.c
index f9d572ee6..7496541cd 100644
--- a/arch/m68k/coldfire/sltimers.c
+++ b/arch/m68k/coldfire/sltimers.c
@@ -45,7 +45,7 @@ irqreturn_t mcfslt_profile_tick(int irq, void *dummy)
 {
 	/* Reset Slice Timer 1 */
 	__raw_writel(MCFSLT_SSR_BE | MCFSLT_SSR_TE, PA(MCFSLT_SSR));
-	if (current->pid)
+	if (sysiso_current->pid)
 		profile_tick(CPU_PROFILING);
 	return IRQ_HANDLED;
 }
diff --git a/arch/m68k/coldfire/timers.c b/arch/m68k/coldfire/timers.c
index 05a42d8e0..34c466605 100644
--- a/arch/m68k/coldfire/timers.c
+++ b/arch/m68k/coldfire/timers.c
@@ -159,7 +159,7 @@ irqreturn_t coldfire_profile_tick(int irq, void *dummy)
 {
 	/* Reset ColdFire timer2 */
 	__raw_writeb(MCFTIMER_TER_CAP | MCFTIMER_TER_REF, PA(MCFTIMER_TER));
-	if (current->pid)
+	if (sysiso_current->pid)
 		profile_tick(CPU_PROFILING);
 	return IRQ_HANDLED;
 }
diff --git a/arch/m68k/kernel/signal.c b/arch/m68k/kernel/signal.c
index 338817d0c..fca4ebbee 100644
--- a/arch/m68k/kernel/signal.c
+++ b/arch/m68k/kernel/signal.c
@@ -681,7 +681,7 @@ restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *usc, void __u
 	siginfo_build_tests();
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/* get previous context */
 	if (copy_from_user(&context, usc, sizeof(context)))
@@ -714,7 +714,7 @@ rt_restore_ucontext(struct pt_regs *regs, struct switch_stack *sw,
 	int err;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	err = __get_user(temp, &uc->uc_mcontext.version);
 	if (temp != MCONTEXT_VERSION)
diff --git a/arch/m68k/kernel/traps.c b/arch/m68k/kernel/traps.c
index 9718ce94c..e16a2e6fb 100644
--- a/arch/m68k/kernel/traps.c
+++ b/arch/m68k/kernel/traps.c
@@ -502,7 +502,7 @@ static inline void bus_error030 (struct frame *fp)
 	unsigned long desc;
 #endif
 
-	pr_debug("pid = %x  ", current->pid);
+	pr_debug("pid = %x  ", sysiso_current->pid);
 	pr_debug("SSW=%#06x  ", ssw);
 
 	if (ssw & (FC | FB))
@@ -853,7 +853,7 @@ void show_registers(struct pt_regs *regs)
 	       regs->d4, regs->d5, regs->a0, regs->a1);
 
 	pr_info("Process %s (pid: %d, task=%p)\n",
-		current->comm, task_pid_nr(current), current);
+		sysiso_current->comm, task_pid_nr(sysiso_current), current);
 	addr = (unsigned long)&fp->un;
 	pr_info("Frame format=%X ", regs->format);
 	switch (regs->format) {
@@ -993,7 +993,7 @@ void bad_super_trap (struct frame *fp)
 				fp->un.fmtb.daddr, space_names[ssw & DFC],
 				fp->ptregs.pc);
 	}
-	pr_err("Current process id is %d\n", task_pid_nr(current));
+	pr_err("Current process id is %d\n", task_pid_nr(sysiso_current));
 	die_if_kernel("BAD KERNEL TRAP", &fp->ptregs, 0);
 }
 
diff --git a/arch/microblaze/kernel/signal.c b/arch/microblaze/kernel/signal.c
index fc61eb0eb..2f539e1fb 100644
--- a/arch/microblaze/kernel/signal.c
+++ b/arch/microblaze/kernel/signal.c
@@ -87,7 +87,7 @@ asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
 	int rval;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (!access_ok(frame, sizeof(*frame)))
 		goto badframe;
@@ -220,7 +220,7 @@ static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
 
 #ifdef DEBUG_SIG
 	pr_info("SIG deliver (%s:%d): sp=%p pc=%08lx\n",
-		current->comm, current->pid, frame, regs->pc);
+		sysiso_current->comm, current->pid, frame, regs->pc);
 #endif
 
 	return 0;
diff --git a/arch/microblaze/pci/pci-common.c b/arch/microblaze/pci/pci-common.c
index 557585f1b..c3394af29 100644
--- a/arch/microblaze/pci/pci-common.c
+++ b/arch/microblaze/pci/pci-common.c
@@ -326,7 +326,7 @@ int pci_mmap_legacy_page_range(struct pci_bus *bus,
 		 */
 		if ((offset + size) > hose->isa_mem_size) {
 			pr_debug("Process %s (pid:%d) mapped non-existing PCI",
-				current->comm, current->pid);
+				sysiso_current->comm, sysiso_current->pid);
 			pr_debug("legacy memory for 0%04x:%02x\n",
 				pci_domain_nr(bus), bus->number);
 			if (vma->vm_flags & VM_SHARED)
diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c
index 0216ff24c..5c6c5a928 100644
--- a/arch/mips/kernel/branch.c
+++ b/arch/mips/kernel/branch.c
@@ -830,17 +830,17 @@ int __compute_return_epc_for_insn(struct pt_regs *regs,
 
 sigill_dsp:
 	pr_debug("%s: DSP branch but not DSP ASE - sending SIGILL.\n",
-		 current->comm);
+		 sysiso_current->comm);
 	force_sig(SIGILL);
 	return -EFAULT;
 sigill_r2r6:
 	pr_debug("%s: R2 branch but r2-to-r6 emulator is not present - sending SIGILL.\n",
-		 current->comm);
+		 sysiso_current->comm);
 	force_sig(SIGILL);
 	return -EFAULT;
 sigill_r6:
 	pr_debug("%s: R6 branch but no MIPSr6 ISA support - sending SIGILL.\n",
-		 current->comm);
+		 sysiso_current->comm);
 	force_sig(SIGILL);
 	return -EFAULT;
 }
@@ -868,7 +868,7 @@ int __compute_return_epc(struct pt_regs *regs)
 	return __compute_return_epc_for_insn(regs, insn);
 
 unaligned:
-	printk("%s: unaligned epc - sending SIGBUS.\n", current->comm);
+	printk("%s: unaligned epc - sending SIGBUS.\n", sysiso_current->comm);
 	force_sig(SIGBUS);
 	return -EFAULT;
 }
diff --git a/arch/mips/kernel/kprobes.c b/arch/mips/kernel/kprobes.c
index 75bff0f77..948065b8a 100644
--- a/arch/mips/kernel/kprobes.c
+++ b/arch/mips/kernel/kprobes.c
@@ -219,7 +219,7 @@ static int evaluate_branch_instruction(struct kprobe *p, struct pt_regs *regs,
 	return 0;
 
 unaligned:
-	pr_notice("%s: unaligned epc - sending SIGBUS.\n", current->comm);
+	pr_notice("%s: unaligned epc - sending SIGBUS.\n", sysiso_current->comm);
 	force_sig(SIGBUS);
 	return -EFAULT;
 
diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 95aa86fa6..a18131e26 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -74,7 +74,7 @@ void exit_thread(struct task_struct *tsk)
 	 * User threads may have allocated a delay slot emulation frame.
 	 * If so, clean up that allocation.
 	 */
-	if (!(current->flags & PF_KTHREAD))
+	if (!(sysiso_current->flags & PF_KTHREAD))
 		dsemul_thread_cleanup(tsk);
 }
 
@@ -699,7 +699,7 @@ unsigned long mips_stack_top(void)
 		top -= shm_align_mask + 1;
 
 	/* Space to randomize the VDSO base */
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		top -= VDSO_RANDOMIZE_SIZE;
 
 	return top;
@@ -711,7 +711,7 @@ unsigned long mips_stack_top(void)
  */
 unsigned long arch_align_stack(unsigned long sp)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		sp -= get_random_int() & ~PAGE_MASK;
 
 	return sp & ALMASK;
diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 18c509c59..74ab9ef1a 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -134,7 +134,7 @@ int rtlx_open(int index, int can_sleep)
 					smp_rmb();
 					if (*p != NULL)
 						break;
-					if (!signal_pending(current)) {
+					if (!signal_pending(sysiso_current)) {
 						schedule();
 						continue;
 					}
diff --git a/arch/mips/kernel/signal.c b/arch/mips/kernel/signal.c
index c9b2a7556..bc74bbd4e 100644
--- a/arch/mips/kernel/signal.c
+++ b/arch/mips/kernel/signal.c
@@ -520,7 +520,7 @@ int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc)
 	int i;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	err |= __get_user(regs->cp0_epc, &sc->sc_pc);
 
@@ -737,7 +737,7 @@ static int setup_frame(void *sig_return, struct ksignal *ksig,
 	regs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
-	       current->comm, current->pid,
+	       sysiso_current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 	return 0;
 }
@@ -784,7 +784,7 @@ static int setup_rt_frame(void *sig_return, struct ksignal *ksig,
 	regs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
-	       current->comm, current->pid,
+	       sysiso_current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 
 	return 0;
diff --git a/arch/mips/kernel/signal_n32.c b/arch/mips/kernel/signal_n32.c
index 7bd00fad6..7058441a7 100644
--- a/arch/mips/kernel/signal_n32.c
+++ b/arch/mips/kernel/signal_n32.c
@@ -131,7 +131,7 @@ static int setup_rt_frame_n32(void *sig_return, struct ksignal *ksig,
 	regs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
-	       current->comm, current->pid,
+	       sysiso_current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 
 	return 0;
diff --git a/arch/mips/kernel/signal_o32.c b/arch/mips/kernel/signal_o32.c
index 299a7a28c..4f84dc5c8 100644
--- a/arch/mips/kernel/signal_o32.c
+++ b/arch/mips/kernel/signal_o32.c
@@ -90,7 +90,7 @@ static int restore_sigcontext32(struct pt_regs *regs,
 	int i;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	err |= __get_user(regs->cp0_epc, &sc->sc_pc);
 	err |= __get_user(regs->hi, &sc->sc_mdhi);
@@ -145,7 +145,7 @@ static int setup_frame_32(void *sig_return, struct ksignal *ksig,
 	regs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
-	       current->comm, current->pid,
+	       sysiso_current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 
 	return 0;
@@ -231,7 +231,7 @@ static int setup_rt_frame_32(void *sig_return, struct ksignal *ksig,
 	regs->cp0_epc = regs->regs[25] = (unsigned long) ksig->ka.sa.sa_handler;
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
-	       current->comm, current->pid,
+	       sysiso_current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 
 	return 0;
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 6f07362de..701c6da01 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -368,8 +368,9 @@ void show_registers(struct pt_regs *regs)
 	__show_regs(regs);
 	print_modules();
 	printk("Process %s (pid: %d, threadinfo=%p, task=%p, tls=%0*lx)\n",
-	       current->comm, current->pid, current_thread_info(), current,
-	      field, current_thread_info()->tp_value);
+	       sysiso_current->comm, sysiso_current->pid, current_thread_info(),
+	       current,
+	       field, current_thread_info()->tp_value);
 	if (cpu_has_userlocal) {
 		unsigned long tls;
 
diff --git a/arch/mips/kernel/uprobes.c b/arch/mips/kernel/uprobes.c
index 9db2a6db5..76eb4b6d5 100644
--- a/arch/mips/kernel/uprobes.c
+++ b/arch/mips/kernel/uprobes.c
@@ -104,7 +104,7 @@ bool is_trap_insn(uprobe_opcode_t *insn)
  */
 int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	/*
 	 * Now find the EPC where to resume after the breakpoint has been
@@ -125,7 +125,7 @@ int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs)
 
 int arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	current->thread.trap_nr = utask->autask.saved_trap_nr;
 	regs->cp0_epc = aup->resume_epc;
@@ -188,7 +188,7 @@ int arch_uprobe_exception_notify(struct notifier_block *self,
 void arch_uprobe_abort_xol(struct arch_uprobe *aup,
 	struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	instruction_pointer_set(regs, utask->vaddr);
 }
diff --git a/arch/mips/kernel/vdso.c b/arch/mips/kernel/vdso.c
index 3d0cf471f..bbd9ad4d8 100644
--- a/arch/mips/kernel/vdso.c
+++ b/arch/mips/kernel/vdso.c
@@ -78,7 +78,7 @@ static unsigned long vdso_base(void)
 		base += PAGE_SIZE;
 	}
 
-	if (current->flags & PF_RANDOMIZE) {
+	if (sysiso_current->flags & PF_RANDOMIZE) {
 		base += get_random_int() & (VDSO_RANDOMIZE_SIZE - 1);
 		base = PAGE_ALIGN(base);
 	}
diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c
index 75c6f264c..62b59d20b 100644
--- a/arch/mips/kvm/mips.c
+++ b/arch/mips/kvm/mips.c
@@ -1340,7 +1340,7 @@ int kvm_mips_handle_exit(struct kvm_vcpu *vcpu)
 
 	if (!(ret & RESUME_HOST)) {
 		/* Only check for signals if not already exiting to userspace */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			run->exit_reason = KVM_EXIT_INTR;
 			ret = (-EINTR << 2) | RESUME_HOST;
 			++vcpu->stat.signal_exits;
@@ -1555,7 +1555,7 @@ static int kvm_mips_csr_die_notify(struct notifier_block *self,
 		return NOTIFY_DONE;
 
 	/* Return immediately if guest context isn't active */
-	if (!(current->flags & PF_VCPU))
+	if (!(sysiso_current->flags & PF_VCPU))
 		return NOTIFY_DONE;
 
 	/* Should never get here from user mode */
diff --git a/arch/mips/kvm/vz.c b/arch/mips/kvm/vz.c
index 4adca5abb..f14851676 100644
--- a/arch/mips/kvm/vz.c
+++ b/arch/mips/kvm/vz.c
@@ -2577,7 +2577,7 @@ static int kvm_vz_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 	 * restore wired guest TLB entries (while in guest context).
 	 */
 	kvm_restore_gc0_wired(cop0);
-	if (current->flags & PF_VCPU) {
+	if (sysiso_current->flags & PF_VCPU) {
 		tlbw_use_hazard();
 		kvm_vz_vcpu_load_tlb(vcpu, cpu);
 		kvm_vz_vcpu_load_wired(vcpu);
@@ -2700,7 +2700,7 @@ static int kvm_vz_vcpu_put(struct kvm_vcpu *vcpu, int cpu)
 {
 	struct mips_coproc *cop0 = vcpu->arch.cop0;
 
-	if (current->flags & PF_VCPU)
+	if (sysiso_current->flags & PF_VCPU)
 		kvm_vz_vcpu_save_wired(vcpu);
 
 	kvm_lose_fpu(vcpu);
diff --git a/arch/mips/math-emu/dsemul.c b/arch/mips/math-emu/dsemul.c
index e2d46cb93..b4559b38e 100644
--- a/arch/mips/math-emu/dsemul.c
+++ b/arch/mips/math-emu/dsemul.c
@@ -116,7 +116,7 @@ static int alloc_emuframe(void)
 	}
 
 	/* Success! */
-	pr_debug("allocate emuframe %d to %d\n", idx, current->pid);
+	pr_debug("allocate emuframe %d to %d\n", idx, sysiso_current->pid);
 out_unlock:
 	spin_unlock(&mm_ctx->bd_emupage_lock);
 	return idx;
@@ -128,7 +128,7 @@ static void free_emuframe(int idx, struct mm_struct *mm)
 
 	spin_lock(&mm_ctx->bd_emupage_lock);
 
-	pr_debug("free emuframe %d from %d\n", idx, current->pid);
+	pr_debug("free emuframe %d from %d\n", idx, sysiso_current->pid);
 	bitmap_clear(mm_ctx->bd_emupage_allocmap, idx, 1);
 
 	/* If some thread is waiting for a frame, now's its chance */
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index e7abda9c0..53af89c00 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -50,7 +50,7 @@ static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,
 
 #if 0
 	printk("Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n", raw_smp_processor_id(),
-	       current->comm, current->pid, field, address, write,
+	       sysiso_current->comm, current->pid, field, address, write,
 	       field, regs->cp0_epc);
 #endif
 
@@ -126,7 +126,7 @@ static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,
 #if 0
 				pr_notice("Cpu%d[%s:%d:%0*lx:%ld:%0*lx] XI violation\n",
 					  raw_smp_processor_id(),
-					  current->comm, current->pid,
+					  sysiso_current->comm, current->pid,
 					  field, address, write,
 					  field, regs->cp0_epc);
 #endif
@@ -137,7 +137,7 @@ static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,
 #if 0
 				pr_notice("Cpu%d[%s:%d:%0*lx:%ld:%0*lx] RI violation\n",
 					  raw_smp_processor_id(),
-					  current->comm, current->pid,
+					  sysiso_current->comm, current->pid,
 					  field, address, write,
 					  field, regs->cp0_epc);
 #endif
diff --git a/arch/mips/netlogic/xlp/cop2-ex.c b/arch/mips/netlogic/xlp/cop2-ex.c
index 21e439b3d..5fdab614c 100644
--- a/arch/mips/netlogic/xlp/cop2-ex.c
+++ b/arch/mips/netlogic/xlp/cop2-ex.c
@@ -107,7 +107,7 @@ static int nlm_cu2_call(struct notifier_block *nfb, unsigned long action,
 		write_c0_status(status & ~ST0_CU2);
 		local_irq_restore(flags);
 		pr_info("COP2 access enabled for pid %d (%s)\n",
-					current->pid, current->comm);
+					sysiso_current->pid, sysiso_current->comm);
 		return NOTIFY_BAD;	/* Don't call default notifier */
 	}
 
diff --git a/arch/nds32/kernel/signal.c b/arch/nds32/kernel/signal.c
index 7e3ca430a..23b44fe25 100644
--- a/arch/nds32/kernel/signal.c
+++ b/arch/nds32/kernel/signal.c
@@ -139,7 +139,7 @@ asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
 	struct rt_sigframe __user *frame;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Since we stacked the signal on a 64-bit boundary,
diff --git a/arch/nds32/kernel/traps.c b/arch/nds32/kernel/traps.c
index f06421c64..6fd6d9ce2 100644
--- a/arch/nds32/kernel/traps.c
+++ b/arch/nds32/kernel/traps.c
@@ -120,7 +120,7 @@ DEFINE_SPINLOCK(die_lock);
  */
 void die(const char *str, struct pt_regs *regs, int err)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	static int die_counter;
 
 	console_verbose();
@@ -156,7 +156,7 @@ void die_if_kernel(const char *str, struct pt_regs *regs, int err)
 
 int bad_syscall(int n, struct pt_regs *regs)
 {
-	if (current->personality != PER_LINUX) {
+	if (sysiso_current->personality != PER_LINUX) {
 		send_sig(SIGSEGV, current, 1);
 		return regs->uregs[0];
 	}
diff --git a/arch/nios2/kernel/misaligned.c b/arch/nios2/kernel/misaligned.c
index 23e0544e1..eba5ef23a 100644
--- a/arch/nios2/kernel/misaligned.c
+++ b/arch/nios2/kernel/misaligned.c
@@ -159,7 +159,7 @@ asmlinkage void handle_unaligned_c(struct pt_regs *fp, int cause)
 			pr_err("fault during user misaligned fixup @ %#lx; isn=%08x addr=0x%08x sp=0x%08lx pid=%d\n",
 				fp->ea,
 				(unsigned int)isn, addr, fp->sp,
-				current->pid);
+				sysiso_current->pid);
 
 			_exception(SIGSEGV, fp, SEGV_MAPERR, fp->ea);
 			return;
diff --git a/arch/nios2/kernel/process.c b/arch/nios2/kernel/process.c
index 9ff37ba2b..ec70178f7 100644
--- a/arch/nios2/kernel/process.c
+++ b/arch/nios2/kernel/process.c
@@ -155,7 +155,7 @@ void dump(struct pt_regs *fp)
 	int		i;
 
 	pr_emerg("\nCURRENT PROCESS:\n\n");
-	pr_emerg("COMM=%s PID=%d\n", current->comm, current->pid);
+	pr_emerg("COMM=%s PID=%d\n", sysiso_current->comm, sysiso_current->pid);
 
 	if (current->mm) {
 		pr_emerg("TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",
diff --git a/arch/nios2/kernel/signal.c b/arch/nios2/kernel/signal.c
index 2009ae2d3..f26bc8ac0 100644
--- a/arch/nios2/kernel/signal.c
+++ b/arch/nios2/kernel/signal.c
@@ -43,7 +43,7 @@ static inline int rt_restore_ucontext(struct pt_regs *regs,
 	int err;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	err = __get_user(temp, &uc->uc_mcontext.version);
 	if (temp != MCONTEXT_VERSION)
diff --git a/arch/nios2/mm/fault.c b/arch/nios2/mm/fault.c
index 9476feecf..9fb56e986 100644
--- a/arch/nios2/mm/fault.c
+++ b/arch/nios2/mm/fault.c
@@ -178,7 +178,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long cause,
 	if (user_mode(regs)) {
 		if (unhandled_signal(current, SIGSEGV) && printk_ratelimit()) {
 			pr_info("%s: unhandled page fault (%d) at 0x%08lx, "
-				"cause %ld\n", current->comm, SIGSEGV, address, cause);
+				"cause %ld\n", sysiso_current->comm, SIGSEGV, address, cause);
 			show_regs(regs);
 		}
 		_exception(SIGSEGV, regs, code, address);
diff --git a/arch/openrisc/kernel/signal.c b/arch/openrisc/kernel/signal.c
index 1ebcff271..d4b774329 100644
--- a/arch/openrisc/kernel/signal.c
+++ b/arch/openrisc/kernel/signal.c
@@ -42,7 +42,7 @@ static int restore_sigcontext(struct pt_regs *regs,
 	int err = 0;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/*
 	 * Restore the regs from &sc->regs.
diff --git a/arch/openrisc/kernel/traps.c b/arch/openrisc/kernel/traps.c
index aa1e70940..d27fac201 100644
--- a/arch/openrisc/kernel/traps.c
+++ b/arch/openrisc/kernel/traps.c
@@ -89,7 +89,7 @@ void show_registers(struct pt_regs *regs)
 	       regs->gpr[11], regs->orig_gpr11);
 
 	printk("Process %s (pid: %d, stackpage=%08lx)\n",
-	       current->comm, current->pid, (unsigned long)current);
+	       sysiso_current->comm, sysiso_current->pid, (unsigned long)current);
 	/*
 	 * When in-kernel, we also print out the stack and code at the
 	 * time of the fault..
diff --git a/arch/parisc/kernel/irq.c b/arch/parisc/kernel/irq.c
index 0d46b19dc..2d7eb1a55 100644
--- a/arch/parisc/kernel/irq.c
+++ b/arch/parisc/kernel/irq.c
@@ -434,7 +434,7 @@ static inline void stack_overflow_check(struct pt_regs *regs)
 
 	pr_emerg("stackcheck: %s will most likely overflow irq stack "
 		 "(sp:%lx, stk bottom-top:%lx-%lx)\n",
-		current->comm, sp, stack_start, stack_start + IRQ_STACK_SIZE);
+		sysiso_current->comm, sp, stack_start, stack_start + IRQ_STACK_SIZE);
 	goto panic_check;
 
 check_kernel_stack:
@@ -451,7 +451,7 @@ static inline void stack_overflow_check(struct pt_regs *regs)
 
 	pr_emerg("stackcheck: %s will most likely overflow kernel stack "
 		 "(sp:%lx, stk bottom-top:%lx-%lx)\n",
-		current->comm, sp, stack_start, stack_start + THREAD_SIZE);
+		sysiso_current->comm, sp, stack_start, stack_start + THREAD_SIZE);
 
 #ifdef CONFIG_IRQSTACKS
 panic_check:
diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c
index bbfe23c40..8bf6aad6d 100644
--- a/arch/parisc/kernel/signal.c
+++ b/arch/parisc/kernel/signal.c
@@ -97,7 +97,7 @@ sys_rt_sigreturn(struct pt_regs *regs, int in_syscall)
 		sigframe_size = PARISC_RT_SIGFRAME_SIZE32;
 #endif
 
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	/* Unwind the user stack to get the rt_sigframe structure. */
 	frame = (struct rt_sigframe __user *)
@@ -398,7 +398,7 @@ setup_rt_frame(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs,
 
 
 	DBG(1,"setup_rt_frame: sig deliver (%s,%d) frame=0x%p sp=%#lx iaoq=%#lx/%#lx rp=%#lx\n",
-	       current->comm, current->pid, frame, regs->gr[30],
+	       sysiso_current->comm, current->pid, frame, regs->gr[30],
 	       regs->iaoq[0], regs->iaoq[1], rp);
 
 	return 0;
@@ -473,7 +473,7 @@ static void check_syscallno_in_delay_branch(struct pt_regs *regs)
 	}
 
 	pr_warn("syscall restart: %s (pid %d): unexpected opcode 0x%08x\n",
-		current->comm, task_pid_nr(current), opcode);
+		sysiso_current->comm, task_pid_nr(sysiso_current), opcode);
 }
 
 static inline void
diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c
index 5f1253731..272672ae5 100644
--- a/arch/parisc/kernel/sys_parisc.c
+++ b/arch/parisc/kernel/sys_parisc.c
@@ -92,7 +92,7 @@ static unsigned long mmap_upper_limit(struct rlimit *rlim_stack)
 	stack_base = calc_max_stack_size(stack_base);
 
 	/* Add space for stack randomization. */
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		stack_base += (STACK_RND_MASK << PAGE_SHIFT);
 
 	return PAGE_ALIGN(STACK_TOP - stack_base);
@@ -222,7 +222,7 @@ arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
 
 static int mmap_is_legacy(void)
 {
-	if (current->personality & ADDR_COMPAT_LAYOUT)
+	if (sysiso_current->personality & ADDR_COMPAT_LAYOUT)
 		return 1;
 
 	/* parisc stack always grows up - so a unlimited stack should
@@ -238,7 +238,7 @@ static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
 
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		rnd = get_random_int() & MMAP_RND_MASK;
 
 	return rnd << PAGE_SHIFT;
@@ -383,7 +383,7 @@ long parisc_personality(unsigned long personality)
 {
 	long err;
 
-	if (personality(current->personality) == PER_LINUX32
+	if (personality(sysiso_current->personality) == PER_LINUX32
 	    && personality(personality) == PER_LINUX)
 		personality = (personality & ~PER_MASK) | PER_LINUX32;
 
diff --git a/arch/parisc/kernel/sys_parisc32.c b/arch/parisc/kernel/sys_parisc32.c
index 2a12a547b..cc584bbe4 100644
--- a/arch/parisc/kernel/sys_parisc32.c
+++ b/arch/parisc/kernel/sys_parisc32.c
@@ -20,7 +20,7 @@ asmlinkage long sys32_unimplemented(int r26, int r25, int r24, int r23,
 	int r22, int r21, int r20)
 {
     printk(KERN_ERR "%s(%d): Unimplemented 32 on 64 syscall #%d!\n", 
-    	current->comm, current->pid, r20);
+    	sysiso_current->comm, sysiso_current->pid, r20);
     return -ENOSYS;
 }
 
diff --git a/arch/parisc/kernel/traps.c b/arch/parisc/kernel/traps.c
index 747c328fb..b945153b5 100644
--- a/arch/parisc/kernel/traps.c
+++ b/arch/parisc/kernel/traps.c
@@ -216,7 +216,8 @@ void die_if_kernel(char *str, struct pt_regs *regs, long err)
 
 		parisc_printk_ratelimited(1, regs,
 			KERN_CRIT "%s (pid %d): %s (code %ld) at " RFMT "\n",
-			current->comm, task_pid_nr(current), str, err, regs->iaoq[0]);
+			sysiso_current->comm, task_pid_nr(sysiso_current), str, err,
+			regs->iaoq[0]);
 
 		return;
 	}
@@ -247,7 +248,7 @@ void die_if_kernel(char *str, struct pt_regs *regs, long err)
 	
 	if (err)
 		printk(KERN_CRIT "%s (pid %d): %s (code %ld)\n",
-			current->comm, task_pid_nr(current), str, err);
+			sysiso_current->comm, task_pid_nr(sysiso_current), str, err);
 
 	/* Wot's wrong wif bein' racy? */
 	if (current->thread.flags & PARISC_KERNEL_DEATH) {
@@ -316,7 +317,7 @@ static void handle_break(struct pt_regs *regs)
 		parisc_printk_ratelimited(0, regs,
 			KERN_DEBUG "break %d,%d: pid=%d command='%s'\n",
 			iir & 31, (iir>>13) & ((1<<13)-1),
-			task_pid_nr(current), current->comm);
+			task_pid_nr(sysiso_current), sysiso_current->comm);
 
 	/* send standard GDB signal */
 	handle_gdb_break(regs, TRAP_BRKPT);
@@ -752,7 +753,7 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 		if (user_mode(regs)) {
 			parisc_printk_ratelimited(0, regs, KERN_DEBUG
 				"handle_interruption() pid=%d command='%s'\n",
-				task_pid_nr(current), current->comm);
+				task_pid_nr(sysiso_current), sysiso_current->comm);
 			/* SIGBUS, for lack of a better one. */
 			force_sig_fault(SIGBUS, BUS_OBJERR,
 					(void __user *)regs->ior);
@@ -769,7 +770,7 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 		parisc_printk_ratelimited(0, regs, KERN_DEBUG
 				"User fault %d on space 0x%08lx, pid=%d command='%s'\n",
 				code, fault_space,
-				task_pid_nr(current), current->comm);
+				task_pid_nr(sysiso_current), sysiso_current->comm);
 		force_sig_fault(SIGSEGV, SEGV_MAPERR,
 				(void __user *)regs->ior);
 		return;
diff --git a/arch/parisc/kernel/unaligned.c b/arch/parisc/kernel/unaligned.c
index 237d20dd5..c8132edf2 100644
--- a/arch/parisc/kernel/unaligned.c
+++ b/arch/parisc/kernel/unaligned.c
@@ -452,7 +452,8 @@ void handle_unaligned(struct pt_regs *regs)
 			__ratelimit(&ratelimit)) {
 			char buf[256];
 			sprintf(buf, "%s(%d): unaligned access to 0x" RFMT " at ip=0x" RFMT "\n",
-				current->comm, task_pid_nr(current), regs->ior, regs->iaoq[0]);
+				sysiso_current->comm, task_pid_nr(sysiso_current),
+				regs->ior, regs->iaoq[0]);
 			printk(KERN_WARNING "%s", buf);
 #ifdef DEBUG_UNALIGNED
 			show_regs(regs);
diff --git a/arch/powerpc/kernel/mce.c b/arch/powerpc/kernel/mce.c
index fd829f7f2..406beb905 100644
--- a/arch/powerpc/kernel/mce.c
+++ b/arch/powerpc/kernel/mce.c
@@ -573,7 +573,7 @@ void machine_check_print_event_info(struct machine_check_event *evt,
 
 	if (in_guest || user_mode) {
 		printk("%sMCE: CPU%d: PID: %d Comm: %s %sNIP: [%016llx]%s\n",
-			level, evt->cpu, current->pid, current->comm,
+			level, evt->cpu, sysiso_current->pid, sysiso_current->comm,
 			in_guest ? "Guest " : "", evt->srr0, pa_str);
 	} else {
 		printk("%sMCE: CPU%d: NIP: [%016llx] %pS%s\n",
diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index c35734309..70e470a25 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -660,7 +660,8 @@ int pci_mmap_legacy_page_range(struct pci_bus *bus,
 		if ((offset + size) > hose->isa_mem_size) {
 			printk(KERN_DEBUG
 			       "Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\n",
-			       current->comm, current->pid, pci_domain_nr(bus), bus->number);
+			       sysiso_current->comm, sysiso_current->pid,
+			       pci_domain_nr(bus), bus->number);
 			if (vma->vm_flags & VM_SHARED)
 				return shmem_zero_setup(vma);
 			return 0;
diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c
index 50436b52c..1937e68fe 100644
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@ -1387,8 +1387,8 @@ void show_user_instructions(struct pt_regs *regs)
 		}
 
 		if (!seq_buf_has_overflowed(&s))
-			pr_info("%s[%d]: code: %s\n", current->comm,
-				current->pid, s.buffer);
+			pr_info("%s[%d]: code: %s\n", sysiso_current->comm,
+				sysiso_current->pid, s.buffer);
 	}
 }
 
@@ -2273,7 +2273,7 @@ void notrace __ppc64_runlatch_off(void)
 
 unsigned long arch_align_stack(unsigned long sp)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		sp -= get_random_int() & ~PAGE_MASK;
 	return sp & ~0xf;
 }
diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c
index ff80bbad2..3a1a8f9c1 100644
--- a/arch/powerpc/kernel/rtas.c
+++ b/arch/powerpc/kernel/rtas.c
@@ -1055,7 +1055,7 @@ static bool block_rtas_call(int token, int nargs,
 err:
 	pr_err_ratelimited("sys_rtas: RTAS call blocked - exploit attempt?\n");
 	pr_err_ratelimited("sys_rtas: token=0x%x, nargs=%d (called by %s)\n",
-			   token, nargs, current->comm);
+			   token, nargs, sysiso_current->comm);
 	return true;
 }
 
diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c
index 060858196..e9ead3967 100644
--- a/arch/powerpc/kernel/signal_32.c
+++ b/arch/powerpc/kernel/signal_32.c
@@ -1041,7 +1041,7 @@ SYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,
 		if (!user_write_access_begin(old_ctx, ctx_size))
 			return -EFAULT;
 		unsafe_save_user_regs(regs, mctx, NULL, ctx_has_vsx_region, failed);
-		unsafe_put_sigset_t(&old_ctx->uc_sigmask, &current->blocked, failed);
+		unsafe_put_sigset_t(&old_ctx->uc_sigmask, &sysiso_current->blocked, failed);
 		unsafe_put_user(to_user_ptr(mctx), &old_ctx->uc_regs, failed);
 		user_write_access_end();
 	}
@@ -1088,7 +1088,7 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	unsigned long tmp;
 #endif
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	rt_sf = (struct rt_sigframe __user *)
 		(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);
@@ -1293,7 +1293,7 @@ SYSCALL_DEFINE0(sigreturn)
 	unsigned long long msr_hi = 0;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	sf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);
 	sc = &sf->sctx;
diff --git a/arch/powerpc/kernel/signal_64.c b/arch/powerpc/kernel/signal_64.c
index 1831bba05..a1972e067 100644
--- a/arch/powerpc/kernel/signal_64.c
+++ b/arch/powerpc/kernel/signal_64.c
@@ -680,7 +680,7 @@ SYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,
 
 		unsafe_setup_sigcontext(&old_ctx->uc_mcontext, current, 0, NULL,
 					0, ctx_has_vsx_region, efault_out);
-		unsafe_copy_to_user(&old_ctx->uc_sigmask, &current->blocked,
+		unsafe_copy_to_user(&old_ctx->uc_sigmask, &sysiso_current->blocked,
 				    sizeof(sigset_t), efault_out);
 
 		user_write_access_end();
@@ -738,7 +738,7 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	unsigned long msr;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (!access_ok(uc, sizeof(*uc)))
 		goto badframe;
diff --git a/arch/powerpc/kernel/syscalls.c b/arch/powerpc/kernel/syscalls.c
index 825931e40..61db1bdd5 100644
--- a/arch/powerpc/kernel/syscalls.c
+++ b/arch/powerpc/kernel/syscalls.c
@@ -86,7 +86,7 @@ long ppc64_personality(unsigned long personality)
 {
 	long ret;
 
-	if (personality(current->personality) == PER_LINUX32
+	if (personality(sysiso_current->personality) == PER_LINUX32
 	    && personality(personality) == PER_LINUX)
 		personality = (personality & ~PER_MASK) | PER_LINUX32;
 	ret = sys_personality(personality);
diff --git a/arch/powerpc/kernel/sysfs.c b/arch/powerpc/kernel/sysfs.c
index defecb3b1..afbaf8040 100644
--- a/arch/powerpc/kernel/sysfs.c
+++ b/arch/powerpc/kernel/sysfs.c
@@ -52,7 +52,7 @@ static ssize_t store_smt_snooze_delay(struct device *dev,
 				      size_t count)
 {
 	pr_warn_once("%s (%d) stored to unsupported smt_snooze_delay, which has no effect.\n",
-		     current->comm, current->pid);
+		     sysiso_current->comm, sysiso_current->pid);
 	return count;
 }
 
@@ -61,7 +61,7 @@ static ssize_t show_smt_snooze_delay(struct device *dev,
 				     char *buf)
 {
 	pr_warn_once("%s (%d) read from unsupported smt_snooze_delay\n",
-		     current->comm, current->pid);
+		     sysiso_current->comm, sysiso_current->pid);
 	return sprintf(buf, "100\n");
 }
 
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 11741703d..e26a8ff66 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -145,7 +145,7 @@ bool die_will_crash(void)
 	if (kexec_should_crash(current))
 		return true;
 	if (in_interrupt() || panic_on_oops ||
-			!current->pid || is_global_init(current))
+			!sysiso_current->pid || is_global_init(current))
 		return true;
 
 	return false;
@@ -238,7 +238,7 @@ static void oops_end(unsigned long flags, struct pt_regs *regs,
 	 * know we are going to panic, delay for 1 second so we have a
 	 * chance to get clean backtraces from all CPUs that are oopsing.
 	 */
-	if (in_interrupt() || panic_on_oops || !current->pid ||
+	if (in_interrupt() || panic_on_oops || !sysiso_current->pid ||
 	    is_global_init(current)) {
 		mdelay(MSEC_PER_SEC);
 	}
@@ -322,7 +322,7 @@ static void show_signal_msg(int signr, struct pt_regs *regs, int code,
 		return;
 
 	pr_info("%s[%d]: %s (%d) at %lx nip %lx lr %lx code %x",
-		current->comm, current->pid, signame(signr), signr,
+		sysiso_current->comm, sysiso_current->pid, signame(signr), signr,
 		addr, regs->nip, regs->link, code);
 
 	print_vma_addr(KERN_CONT " in ", regs->nip);
@@ -886,7 +886,7 @@ static void p9_hmi_special_emu(struct pt_regs *regs)
 	if ((instr & 0xfc00073e) != 0x7c000618) {
 		pr_devel("HMI vec emu: not vector CI %i:%s[%d] nip=%016lx"
 			 " instr=%08x\n",
-			 smp_processor_id(), current->comm, current->pid,
+			 smp_processor_id(), sysiso_current->comm, current->pid,
 			 regs->nip, instr);
 		return;
 	}
@@ -921,7 +921,7 @@ static void p9_hmi_special_emu(struct pt_regs *regs)
 	if (!access_ok(addr, 16)) {
 		pr_devel("HMI vec emu: bad access %i:%s[%d] nip=%016lx"
 			 " instr=%08x addr=%016lx\n",
-			 smp_processor_id(), current->comm, current->pid,
+			 smp_processor_id(), sysiso_current->comm, current->pid,
 			 regs->nip, instr, (unsigned long)addr);
 		return;
 	}
@@ -936,14 +936,14 @@ static void p9_hmi_special_emu(struct pt_regs *regs)
 	if (rc) {
 		pr_devel("HMI vec emu: page fault %i:%s[%d] nip=%016lx"
 			 " instr=%08x addr=%016lx\n",
-			 smp_processor_id(), current->comm, current->pid,
+			 smp_processor_id(), sysiso_current->comm, current->pid,
 			 regs->nip, instr, (unsigned long)addr);
 		return;
 	}
 
 	pr_devel("HMI vec emu: emulated vector CI %i:%s[%d] nip=%016lx"
 		 " instr=%08x addr=%016lx\n",
-		 smp_processor_id(), current->comm, current->pid, regs->nip,
+		 smp_processor_id(), sysiso_current->comm, current->pid, regs->nip,
 		 instr, (unsigned long) addr);
 
 	/* Grab instruction "selector" */
@@ -962,7 +962,7 @@ static void p9_hmi_special_emu(struct pt_regs *regs)
 	if (!(msr & msr_mask)) {
 		pr_devel("HMI vec emu: MSR fac clear %i:%s[%d] nip=%016lx"
 			 " instr=%08x msr:%016lx\n",
-			 smp_processor_id(), current->comm, current->pid,
+			 smp_processor_id(), sysiso_current->comm, current->pid,
 			 regs->nip, instr, msr);
 		return;
 	}
@@ -2077,7 +2077,7 @@ DEFINE_INTERRUPT_HANDLER(altivec_assist_exception)
 		/* didn't recognize the instruction */
 		/* XXX quick hack for now: set the non-Java bit in the VSCR */
 		printk_ratelimited(KERN_ERR "Unrecognized altivec instruction "
-				   "in %s at %lx\n", current->comm, regs->nip);
+				   "in %s at %lx\n", sysiso_current->comm, regs->nip);
 		current->thread.vr_state.vscr.u[3] |= 0x10000;
 	}
 }
@@ -2141,7 +2141,7 @@ DEFINE_INTERRUPT_HANDLER(SPEFloatingPointException)
 	} else if (err == -EINVAL) {
 		/* didn't recognize the instruction */
 		printk(KERN_ERR "unrecognized spe instruction "
-		       "in %s at %lx\n", current->comm, regs->nip);
+		       "in %s at %lx\n", sysiso_current->comm, regs->nip);
 	} else {
 		_exception(SIGFPE, regs, code, regs->nip);
 	}
@@ -2175,7 +2175,7 @@ DEFINE_INTERRUPT_HANDLER(SPEFloatingPointRoundException)
 	} else if (err == -EINVAL) {
 		/* didn't recognize the instruction */
 		printk(KERN_ERR "unrecognized spe instruction "
-		       "in %s at %lx\n", current->comm, regs->nip);
+		       "in %s at %lx\n", sysiso_current->comm, regs->nip);
 	} else {
 		_exception(SIGFPE, regs, FPE_FLTUNK, regs->nip);
 		return;
@@ -2271,7 +2271,7 @@ u32 ppc_warn_emulated;
 
 void ppc_warn_emulated_print(const char *type)
 {
-	pr_warn_ratelimited("%s used emulated %s instruction\n", current->comm,
+	pr_warn_ratelimited("%s used emulated %s instruction\n", sysiso_current->comm,
 			    type);
 }
 
diff --git a/arch/powerpc/kernel/uprobes.c b/arch/powerpc/kernel/uprobes.c
index c6975467d..b5e045933 100644
--- a/arch/powerpc/kernel/uprobes.c
+++ b/arch/powerpc/kernel/uprobes.c
@@ -106,7 +106,7 @@ bool arch_uprobe_xol_was_trapped(struct task_struct *t)
  */
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	WARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);
 
@@ -162,7 +162,7 @@ int arch_uprobe_exception_notify(struct notifier_block *self,
  */
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	current->thread.trap_nr = utask->autask.saved_trap_nr;
 	instruction_pointer_set(regs, utask->vaddr);
diff --git a/arch/powerpc/kernel/vdso.c b/arch/powerpc/kernel/vdso.c
index 717f2c9a7..74b7e91ca 100644
--- a/arch/powerpc/kernel/vdso.c
+++ b/arch/powerpc/kernel/vdso.c
@@ -132,7 +132,7 @@ int vdso_join_timens(struct task_struct *task, struct time_namespace *ns)
 static struct page *find_timens_vvar_page(struct vm_area_struct *vma)
 {
 	if (likely(vma->vm_mm == current->mm))
-		return current->nsproxy->time_ns->vvar_page;
+		return sysiso_current->nsproxy->time_ns->vvar_page;
 
 	/*
 	 * VM_PFNMAP | VM_IO protect .fault() handler from being called
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index 2acb1c96c..664b66894 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -4303,7 +4303,7 @@ static int kvmppc_run_vcpu(struct kvm_vcpu *vcpu)
 	 * If the vcore is already running, we may be able to start
 	 * this thread straight away and have it join in.
 	 */
-	if (!signal_pending(current)) {
+	if (!signal_pending(sysiso_current)) {
 		if ((vc->vcore_state == VCORE_PIGGYBACK ||
 		     vc->vcore_state == VCORE_RUNNING) &&
 			   !VCORE_IS_EXITING(vc)) {
@@ -4317,7 +4317,7 @@ static int kvmppc_run_vcpu(struct kvm_vcpu *vcpu)
 	}
 
 	while (vcpu->arch.state == KVMPPC_VCPU_RUNNABLE &&
-	       !signal_pending(current)) {
+	       !signal_pending(sysiso_current)) {
 		/* See if the MMU is ready to go */
 		if (!vcpu->kvm->arch.mmu_ready) {
 			spin_unlock(&vc->lock);
@@ -4455,7 +4455,7 @@ int kvmhv_run_single_vcpu(struct kvm_vcpu *vcpu, u64 time_limit,
 
 	local_irq_disable();
 	hard_irq_disable();
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		goto sigpend;
 	if (lazy_irq_pending() || need_resched() || !kvm->arch.mmu_ready)
 		goto out;
@@ -4543,7 +4543,7 @@ int kvmhv_run_single_vcpu(struct kvm_vcpu *vcpu, u64 time_limit,
 	    !kvmppc_vcpu_woken(vcpu)) {
 		kvmppc_set_timer(vcpu);
 		while (vcpu->arch.ceded && !kvmppc_vcpu_woken(vcpu)) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				vcpu->stat.signal_exits++;
 				run->exit_reason = KVM_EXIT_INTR;
 				vcpu->arch.ret = -EINTR;
@@ -4625,7 +4625,7 @@ static int kvmppc_vcpu_run_hv(struct kvm_vcpu *vcpu)
 	kvmppc_core_prepare_to_enter(vcpu);
 
 	/* No need to go into the guest when all we'll do is come back out */
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		run->exit_reason = KVM_EXIT_INTR;
 		return -EINTR;
 	}
@@ -5297,7 +5297,7 @@ static int kvmppc_core_init_vm_hv(struct kvm *kvm)
 	/*
 	 * Create a debugfs directory for the VM
 	 */
-	snprintf(buf, sizeof(buf), "vm%d", current->pid);
+	snprintf(buf, sizeof(buf), "vm%d", sysiso_current->pid);
 	kvm->arch.debugfs_dir = debugfs_create_dir(buf, kvm_debugfs_dir);
 	kvmppc_mmu_debugfs_init(kvm);
 	if (radix_enabled())
diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c
index b4e6f70b9..0cdef094c 100644
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@ -90,7 +90,7 @@ int kvmppc_prepare_to_enter(struct kvm_vcpu *vcpu)
 			continue;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			kvmppc_account_exit(vcpu, SIGNAL_EXITS);
 			vcpu->run->exit_reason = KVM_EXIT_INTR;
 			r = -EINTR;
diff --git a/arch/powerpc/kvm/timing.c b/arch/powerpc/kvm/timing.c
index ba56a5cbb..833212a39 100644
--- a/arch/powerpc/kvm/timing.c
+++ b/arch/powerpc/kvm/timing.c
@@ -210,7 +210,7 @@ void kvmppc_create_vcpu_debugfs(struct kvm_vcpu *vcpu, unsigned int id)
 	struct dentry *debugfs_file;
 
 	snprintf(dbg_fname, sizeof(dbg_fname), "vm%u_vcpu%u_timing",
-		 current->pid, id);
+		 sysiso_current->pid, id);
 	debugfs_file = debugfs_create_file(dbg_fname, 0666, kvm_debugfs_dir,
 						vcpu, &kvmppc_exit_timing_fops);
 
diff --git a/arch/powerpc/mm/book3s64/hash_utils.c b/arch/powerpc/mm/book3s64/hash_utils.c
index c145776d3..c3ab8fff3 100644
--- a/arch/powerpc/mm/book3s64/hash_utils.c
+++ b/arch/powerpc/mm/book3s64/hash_utils.c
@@ -1267,7 +1267,7 @@ void hash_failure_debug(unsigned long ea, unsigned long access,
 	if (!printk_ratelimit())
 		return;
 	pr_info("mm: Hashing failure ! EA=0x%lx access=0x%lx current=%s\n",
-		ea, access, current->comm);
+		ea, access, sysiso_current->comm);
 	pr_info("    trap=0x%lx vsid=0x%lx ssize=%d base psize=%d psize %d pte=0x%lx\n",
 		trap, vsid, ssize, psize, lpsize, pte);
 }
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index a8d0ce85d..5bcd29e41 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -146,7 +146,7 @@ static int do_sigbus(struct pt_regs *regs, unsigned long address,
 		unsigned int lsb = 0; /* shutup gcc */
 
 		pr_err("MCE: Killing %s:%d due to hardware memory corruption fault at %lx\n",
-			current->comm, current->pid, address);
+			sysiso_current->comm, sysiso_current->pid, address);
 
 		if (fault & VM_FAULT_HWPOISON_LARGE)
 			lsb = hstate_index_to_shift(VM_FAULT_GET_HINDEX(fault));
@@ -169,7 +169,7 @@ static int mm_fault_error(struct pt_regs *regs, unsigned long addr,
 	 * Kernel page fault interrupted by SIGKILL. We have no reason to
 	 * continue processing.
 	 */
-	if (fatal_signal_pending(current) && !user_mode(regs))
+	if (fatal_signal_pending(sysiso_current) && !user_mode(regs))
 		return SIGKILL;
 
 	/* Out of memory */
@@ -309,7 +309,8 @@ static void sanity_check_fault(bool is_write, bool is_user,
 			return;
 
 		pr_crit_ratelimited("%s[%d]: User access of kernel address (%lx) - exploit attempt? (uid: %d)\n",
-				   current->comm, current->pid, address,
+				   sysiso_current->comm, sysiso_current->pid,
+				   address,
 				   from_kuid(&init_user_ns, current_uid()));
 		return;
 	}
diff --git a/arch/powerpc/mm/mmap.c b/arch/powerpc/mm/mmap.c
index ae683fdc7..a66b6e958 100644
--- a/arch/powerpc/mm/mmap.c
+++ b/arch/powerpc/mm/mmap.c
@@ -27,7 +27,7 @@
 
 static inline int mmap_is_legacy(struct rlimit *rlim_stack)
 {
-	if (current->personality & ADDR_COMPAT_LAYOUT)
+	if (sysiso_current->personality & ADDR_COMPAT_LAYOUT)
 		return 1;
 
 	if (rlim_stack->rlim_cur == RLIM_INFINITY)
@@ -52,7 +52,7 @@ unsigned long arch_mmap_rnd(void)
 
 static inline unsigned long stack_maxrandom_size(void)
 {
-	if (!(current->flags & PF_RANDOMIZE))
+	if (!(sysiso_current->flags & PF_RANDOMIZE))
 		return 0;
 
 	/* 8MB for 32bit, 1GB for 64bit */
@@ -208,7 +208,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 {
 	unsigned long random_factor = 0UL;
 
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
 	if (radix_enabled())
diff --git a/arch/powerpc/platforms/83xx/suspend.c b/arch/powerpc/platforms/83xx/suspend.c
index bb147d34d..27c84fc8b 100644
--- a/arch/powerpc/platforms/83xx/suspend.c
+++ b/arch/powerpc/platforms/83xx/suspend.c
@@ -266,7 +266,7 @@ static int agent_thread_fn(void *data)
 		wait_event_interruptible(agent_wq, pci_pm_state >= 2);
 		try_to_freeze();
 
-		if (signal_pending(current) || pci_pm_state < 2)
+		if (signal_pending(sysiso_current) || pci_pm_state < 2)
 			continue;
 
 		/* With a preemptible kernel (or SMP), this could race with
diff --git a/arch/powerpc/platforms/book3s/vas-api.c b/arch/powerpc/platforms/book3s/vas-api.c
index 30172e52e..2e24ca38b 100644
--- a/arch/powerpc/platforms/book3s/vas-api.c
+++ b/arch/powerpc/platforms/book3s/vas-api.c
@@ -79,7 +79,7 @@ int get_vas_user_win_ref(struct vas_user_win_ref *task_ref)
 	if (!task_ref->mm) {
 		put_pid(task_ref->pid);
 		pr_err("VAS: pid(%d): mm_struct is not found\n",
-				current->pid);
+				sysiso_current->pid);
 		return -EPERM;
 	}
 
@@ -92,7 +92,7 @@ int get_vas_user_win_ref(struct vas_user_win_ref *task_ref)
 	 * reference until window closed to make sure tgid is not
 	 * reused.
 	 */
-	task_ref->tgid = find_get_pid(task_tgid_vnr(current));
+	task_ref->tgid = find_get_pid(task_tgid_vnr(sysiso_current));
 
 	return 0;
 }
diff --git a/arch/powerpc/platforms/cell/spufs/coredump.c b/arch/powerpc/platforms/cell/spufs/coredump.c
index 1a5876180..9ff74cacd 100644
--- a/arch/powerpc/platforms/cell/spufs/coredump.c
+++ b/arch/powerpc/platforms/cell/spufs/coredump.c
@@ -68,7 +68,7 @@ static struct spu_context *coredump_next_context(int *fd)
 {
 	struct spu_context *ctx;
 	struct file *file;
-	int n = iterate_fd(current->files, *fd, match_context, NULL);
+	int n = iterate_fd(sysiso_current->files, *fd, match_context, NULL);
 	if (!n)
 		return NULL;
 	*fd = n - 1;
diff --git a/arch/powerpc/platforms/cell/spufs/file.c b/arch/powerpc/platforms/cell/spufs/file.c
index 62d90a5e2..e53029c0d 100644
--- a/arch/powerpc/platforms/cell/spufs/file.c
+++ b/arch/powerpc/platforms/cell/spufs/file.c
@@ -321,7 +321,7 @@ static vm_fault_t spufs_ps_fault(struct vm_fault *vmf,
 	if (offset >= ps_size)
 		return VM_FAULT_SIGBUS;
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return VM_FAULT_SIGBUS;
 
 	/*
diff --git a/arch/powerpc/platforms/cell/spufs/run.c b/arch/powerpc/platforms/cell/spufs/run.c
index ce52b8749..26f0d1afc 100644
--- a/arch/powerpc/platforms/cell/spufs/run.c
+++ b/arch/powerpc/platforms/cell/spufs/run.c
@@ -256,7 +256,7 @@ static int spu_run_fini(struct spu_context *ctx, u32 *npc,
 	spu_switch_log_notify(NULL, ctx, SWITCH_LOG_EXIT, *status);
 	spu_release(ctx);
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		ret = -ERESTARTSYS;
 
 	return ret;
@@ -408,7 +408,7 @@ long spufs_run_spu(struct spu_context *ctx, u32 *npc, u32 *event)
 		if (ret)
 			break;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			ret = -ERESTARTSYS;
 	} while (!ret && !(status & (SPU_STATUS_STOPPED_BY_STOP |
 				      SPU_STATUS_STOPPED_BY_HALT |
diff --git a/arch/powerpc/platforms/cell/spufs/sched.c b/arch/powerpc/platforms/cell/spufs/sched.c
index 369206489..1d76b0f57 100644
--- a/arch/powerpc/platforms/cell/spufs/sched.c
+++ b/arch/powerpc/platforms/cell/spufs/sched.c
@@ -106,7 +106,7 @@ void __spu_update_sched_info(struct spu_context *ctx)
 	 * memory ordering here because retrieving the controlling thread is
 	 * per definition racy.
 	 */
-	ctx->tid = current->pid;
+	ctx->tid = sysiso_current->pid;
 
 	/*
 	 * We do our own priority calculations, so we normally want
@@ -223,8 +223,8 @@ static void spu_bind_context(struct spu *spu, struct spu_context *ctx)
 	spu->flags = 0;
 	ctx->spu = spu;
 	ctx->ops = &spu_hw_ops;
-	spu->pid = current->pid;
-	spu->tgid = current->tgid;
+	spu->pid = sysiso_current->pid;
+	spu->tgid = sysiso_current->tgid;
 	spu->ibox_callback = spufs_ibox_callback;
 	spu->wbox_callback = spufs_wbox_callback;
 	spu->stop_callback = spufs_stop_callback;
@@ -537,7 +537,7 @@ static void spu_prio_wait(struct spu_context *ctx)
 
 	spin_lock(&spu_prio->runq_lock);
 	prepare_to_wait_exclusive(&ctx->stop_wq, &wait, TASK_INTERRUPTIBLE);
-	if (!signal_pending(current)) {
+	if (!signal_pending(sysiso_current)) {
 		__spu_add_to_rq(ctx);
 		spin_unlock(&spu_prio->runq_lock);
 		mutex_unlock(&ctx->state_mutex);
@@ -780,7 +780,7 @@ int spu_activate(struct spu_context *ctx, unsigned long flags)
 		return 0;
 
 spu_activate_top:
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	spu = spu_get_idle(ctx);
@@ -1072,7 +1072,7 @@ static int show_spu_loadavg(struct seq_file *s, void *private)
 		LOAD_INT(c), LOAD_FRAC(c),
 		count_active_contexts(),
 		atomic_read(&nr_spu_contexts),
-		idr_get_cursor(&task_active_pid_ns(current)->idr) - 1);
+		idr_get_cursor(&task_active_pid_ns(sysiso_current)->idr) - 1);
 	return 0;
 };
 
diff --git a/arch/powerpc/platforms/cell/spufs/spufs.h b/arch/powerpc/platforms/cell/spufs/spufs.h
index afc1d6604..f4b642b1a 100644
--- a/arch/powerpc/platforms/cell/spufs/spufs.h
+++ b/arch/powerpc/platforms/cell/spufs/spufs.h
@@ -310,7 +310,7 @@ extern char *isolated_loader;
 		if (condition)						\
 			break;						\
 		spu_release(ctx);					\
-		if (signal_pending(current)) {				\
+		if (signal_pending(sysiso_current)) {				\
 			__ret = -ERESTARTSYS;				\
 			break;						\
 		}							\
diff --git a/arch/powerpc/platforms/chrp/nvram.c b/arch/powerpc/platforms/chrp/nvram.c
index e820332b5..7591ebf49 100644
--- a/arch/powerpc/platforms/chrp/nvram.c
+++ b/arch/powerpc/platforms/chrp/nvram.c
@@ -27,7 +27,7 @@ static unsigned char chrp_nvram_read_val(int addr)
 
 	if (addr >= nvram_size) {
 		printk(KERN_DEBUG "%s: read addr %d > nvram_size %u\n",
-		       current->comm, addr, nvram_size);
+		       sysiso_current->comm, addr, nvram_size);
 		return 0xff;
 	}
 	spin_lock_irqsave(&nvram_lock, flags);
@@ -48,7 +48,7 @@ static void chrp_nvram_write_val(int addr, unsigned char val)
 
 	if (addr >= nvram_size) {
 		printk(KERN_DEBUG "%s: write addr %d > nvram_size %u\n",
-		       current->comm, addr, nvram_size);
+		       sysiso_current->comm, addr, nvram_size);
 		return;
 	}
 	spin_lock_irqsave(&nvram_lock, flags);
diff --git a/arch/powerpc/xmon/xmon.c b/arch/powerpc/xmon/xmon.c
index dd8241c00..909a2c07d 100644
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@ -1880,7 +1880,7 @@ static void excprint(struct pt_regs *fp)
 #endif
 	if (current) {
 		printf("    pid   = %d, comm = %s\n",
-		       current->pid, current->comm);
+		       sysiso_current->pid, sysiso_current->comm);
 	}
 
 	if (trap == INTERRUPT_PROGRAM)
diff --git a/arch/riscv/kernel/probes/uprobes.c b/arch/riscv/kernel/probes/uprobes.c
index 7a057b5f0..c206cdf78 100644
--- a/arch/riscv/kernel/probes/uprobes.c
+++ b/arch/riscv/kernel/probes/uprobes.c
@@ -52,7 +52,7 @@ int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,
 
 int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	utask->autask.saved_cause = current->thread.bad_cause;
 	current->thread.bad_cause = UPROBE_TRAP_NR;
@@ -66,7 +66,7 @@ int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	WARN_ON_ONCE(current->thread.bad_cause != UPROBE_TRAP_NR);
 
@@ -104,7 +104,7 @@ bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
 
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	/*
 	 * Task has received a fatal signal, so reset back to probbed
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index c2d5ecbe5..960510b5d 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -103,7 +103,7 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	sigset_t set;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	frame = (struct rt_sigframe __user *)regs->sp;
 
@@ -222,7 +222,7 @@ static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
 
 #if DEBUG_SIG
 	pr_info("SIG deliver (%s:%d): sig=%d pc=%p ra=%p sp=%p\n",
-		current->comm, task_pid_nr(current), ksig->sig,
+		sysiso_current->comm, task_pid_nr(current), ksig->sig,
 		(void *)regs->epc, (void *)regs->ra, frame);
 #endif
 
diff --git a/arch/s390/crypto/prng.c b/arch/s390/crypto/prng.c
index 234d791ca..5b08da35c 100644
--- a/arch/s390/crypto/prng.c
+++ b/arch/s390/crypto/prng.c
@@ -520,7 +520,7 @@ static ssize_t prng_tdes_read(struct file *file, char __user *ubuf,
 
 	while (nbytes) {
 		if (need_resched()) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				if (ret == 0)
 					ret = -ERESTARTSYS;
 				break;
@@ -603,7 +603,7 @@ static ssize_t prng_sha512_read(struct file *file, char __user *ubuf,
 
 	while (nbytes) {
 		if (need_resched()) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				if (ret == 0)
 					ret = -ERESTARTSYS;
 				break;
diff --git a/arch/s390/kernel/compat_signal.c b/arch/s390/kernel/compat_signal.c
index cca142fbb..a5551a0ec 100644
--- a/arch/s390/kernel/compat_signal.c
+++ b/arch/s390/kernel/compat_signal.c
@@ -90,7 +90,7 @@ static int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)
 	int i;
 
 	/* Alwys make any pending restarted system call return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (__copy_from_user(&user_sregs, &sregs->regs, sizeof(user_sregs)))
 		return -EFAULT;
diff --git a/arch/s390/kernel/nmi.c b/arch/s390/kernel/nmi.c
index 20f8e1868..07032f1c8 100644
--- a/arch/s390/kernel/nmi.c
+++ b/arch/s390/kernel/nmi.c
@@ -174,7 +174,7 @@ void __s390_handle_mcck(void)
 		printk(KERN_EMERG "mcck: Terminating task because of machine "
 		       "malfunction (code 0x%016lx).\n", mcck.mcck_code);
 		printk(KERN_EMERG "mcck: task: %s, pid: %d.\n",
-		       current->comm, current->pid);
+		       sysiso_current->comm, sysiso_current->pid);
 		do_exit(SIGSEGV);
 	}
 }
diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c
index 350e94d0c..d61899cba 100644
--- a/arch/s390/kernel/process.c
+++ b/arch/s390/kernel/process.c
@@ -67,8 +67,8 @@ void flush_thread(void)
 
 void arch_setup_new_exec(void)
 {
-	if (S390_lowcore.current_pid != current->pid) {
-		S390_lowcore.current_pid = current->pid;
+	if (S390_lowcore.current_pid != sysiso_current->pid) {
+		S390_lowcore.current_pid = sysiso_current->pid;
 		if (test_facility(40))
 			lpp(&S390_lowcore.lpp);
 	}
@@ -212,7 +212,7 @@ unsigned long get_wchan(struct task_struct *p)
 
 unsigned long arch_align_stack(unsigned long sp)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		sp -= get_random_int() & ~PAGE_MASK;
 	return sp & ~0xf;
 }
diff --git a/arch/s390/kernel/signal.c b/arch/s390/kernel/signal.c
index 307f5d995..8c25cef4c 100644
--- a/arch/s390/kernel/signal.c
+++ b/arch/s390/kernel/signal.c
@@ -142,7 +142,7 @@ static int restore_sigregs(struct pt_regs *regs, _sigregs __user *sregs)
 	_sigregs user_sregs;
 
 	/* Alwys make any pending restarted system call return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (__copy_from_user(&user_sregs, sregs, sizeof(user_sregs)))
 		return -EFAULT;
@@ -509,7 +509,7 @@ void arch_do_signal_or_restart(struct pt_regs *regs, bool has_signal)
 		case -ERESTART_RESTARTBLOCK:
 			/* Restart with sys_restart_syscall */
 			regs->gprs[2] = regs->orig_gpr2;
-			current->restart_block.arch_data = regs->psw.addr;
+			sysiso_current->restart_block.arch_data = regs->psw.addr;
 			if (is_compat_task())
 				regs->psw.addr = VDSO32_SYMBOL(current, restart_syscall);
 			else
diff --git a/arch/s390/kernel/syscall.c b/arch/s390/kernel/syscall.c
index 8fe2d23b6..e7a61bd82 100644
--- a/arch/s390/kernel/syscall.c
+++ b/arch/s390/kernel/syscall.c
@@ -88,9 +88,9 @@ SYSCALL_DEFINE5(s390_ipc, uint, call, int, first, unsigned long, second,
 
 SYSCALL_DEFINE1(s390_personality, unsigned int, personality)
 {
-	unsigned int ret = current->personality;
+	unsigned int ret = sysiso_current->personality;
 
-	if (personality(current->personality) == PER_LINUX32 &&
+	if (personality(sysiso_current->personality) == PER_LINUX32 &&
 	    personality(personality) == PER_LINUX)
 		personality |= PER_LINUX32;
 
@@ -121,9 +121,9 @@ static void do_syscall(struct pt_regs *regs)
 
 	regs->gprs[2] = nr;
 
-	if (nr == __NR_restart_syscall && !(current->restart_block.arch_data & 1)) {
-		regs->psw.addr = current->restart_block.arch_data;
-		current->restart_block.arch_data = 1;
+	if (nr == __NR_restart_syscall && !(sysiso_current->restart_block.arch_data & 1)) {
+		regs->psw.addr = sysiso_current->restart_block.arch_data;
+		sysiso_current->restart_block.arch_data = 1;
 	}
 	nr = syscall_enter_from_user_mode_work(regs, nr);
 
diff --git a/arch/s390/kernel/uprobes.c b/arch/s390/kernel/uprobes.c
index bd3ef121c..1079e334c 100644
--- a/arch/s390/kernel/uprobes.c
+++ b/arch/s390/kernel/uprobes.c
@@ -78,7 +78,7 @@ static int check_per_event(unsigned short cause, unsigned long control,
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
 	int fixup = probe_get_fixup_type(auprobe->insn);
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	clear_tsk_thread_flag(current, TIF_UPROBE_SINGLESTEP);
 	update_cr_regs(current);
diff --git a/arch/s390/kernel/vdso.c b/arch/s390/kernel/vdso.c
index 99694260c..d86aa6469 100644
--- a/arch/s390/kernel/vdso.c
+++ b/arch/s390/kernel/vdso.c
@@ -46,7 +46,7 @@ struct vdso_data *arch_get_vdso_data(void *vvar_page)
 static struct page *find_timens_vvar_page(struct vm_area_struct *vma)
 {
 	if (likely(vma->vm_mm == current->mm))
-		return current->nsproxy->time_ns->vvar_page;
+		return sysiso_current->nsproxy->time_ns->vvar_page;
 	/*
 	 * VM_PFNMAP | VM_IO protect .fault() handler from being called
 	 * through interfaces like /proc/$pid/mem or
diff --git a/arch/s390/kvm/intercept.c b/arch/s390/kvm/intercept.c
index 2bd8f854f..8d13a85ca 100644
--- a/arch/s390/kvm/intercept.c
+++ b/arch/s390/kvm/intercept.c
@@ -95,7 +95,7 @@ static int handle_validity(struct kvm_vcpu *vcpu)
 	vcpu->stat.exit_validity++;
 	trace_kvm_s390_intercept_validity(vcpu, viwhy);
 	KVM_EVENT(3, "validity intercept 0x%x for pid %u (kvm 0x%pK)", viwhy,
-		  current->pid, vcpu->kvm);
+		  sysiso_current->pid, vcpu->kvm);
 
 	/* do not warn on invalid runtime instrumentation mode */
 	WARN_ONCE(viwhy != 0x44, "kvm: unhandled validity intercept 0x%x\n",
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index 1c97493d2..b3ec23e07 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -634,7 +634,7 @@ void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)
 				mark_page_dirty(kvm, cur_gfn + i);
 		}
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return;
 		cond_resched();
 	}
@@ -2711,7 +2711,7 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 			((char *) kvm->arch.sca + sca_offset);
 	mutex_unlock(&kvm_lock);
 
-	sprintf(debug_name, "kvm-%u", current->pid);
+	sprintf(debug_name, "kvm-%u", sysiso_current->pid);
 
 	kvm->arch.dbf = debug_register(debug_name, 32, 1, 7 * sizeof(long));
 	if (!kvm->arch.dbf)
@@ -2786,7 +2786,7 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	kvm_s390_vsie_init(kvm);
 	if (use_gisa)
 		kvm_s390_gisa_init(kvm);
-	KVM_EVENT(3, "vm 0x%pK created by pid %u", kvm, current->pid);
+	KVM_EVENT(3, "vm 0x%pK created by pid %u", kvm, sysiso_current->pid);
 
 	return 0;
 out_err:
@@ -4224,7 +4224,7 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)
 		vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
 
 		rc = vcpu_post_run(vcpu, exit_reason);
-	} while (!signal_pending(current) && !guestdbg_exit_pending(vcpu) && !rc);
+	} while (!signal_pending(sysiso_current) && !guestdbg_exit_pending(vcpu) && !rc);
 
 	srcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);
 	return rc;
@@ -4443,7 +4443,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 	might_fault();
 	rc = __vcpu_run(vcpu);
 
-	if (signal_pending(current) && !rc) {
+	if (signal_pending(sysiso_current) && !rc) {
 		kvm_run->exit_reason = KVM_EXIT_INTR;
 		rc = -EINTR;
 	}
diff --git a/arch/s390/kvm/pv.c b/arch/s390/kvm/pv.c
index c8841f476..2440da12f 100644
--- a/arch/s390/kvm/pv.c
+++ b/arch/s390/kvm/pv.c
@@ -275,7 +275,7 @@ int kvm_s390_pv_unpack(struct kvm *kvm, unsigned long addr, unsigned long size,
 		ret = unpack_one(kvm, addr, tweak, offset, rc, rrc);
 		if (ret == -EAGAIN) {
 			cond_resched();
-			if (fatal_signal_pending(current))
+			if (fatal_signal_pending(sysiso_current))
 				break;
 			continue;
 		}
diff --git a/arch/s390/kvm/vsie.c b/arch/s390/kvm/vsie.c
index acda4b6fc..edce6eb0e 100644
--- a/arch/s390/kvm/vsie.c
+++ b/arch/s390/kvm/vsie.c
@@ -1273,7 +1273,7 @@ static int vsie_run(struct kvm_vcpu *vcpu, struct vsie_page *vsie_page)
 
 		if (rc == -EAGAIN)
 			rc = 0;
-		if (rc || scb_s->icptcode || signal_pending(current) ||
+		if (rc || scb_s->icptcode || signal_pending(sysiso_current) ||
 		    kvm_s390_vcpu_has_irq(vcpu, 0) ||
 		    kvm_s390_vcpu_sie_inhibited(vcpu))
 			break;
@@ -1394,7 +1394,7 @@ int kvm_s390_handle_vsie(struct kvm_vcpu *vcpu)
 	if (unlikely(scb_addr & 0x1ffUL))
 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
 
-	if (signal_pending(current) || kvm_s390_vcpu_has_irq(vcpu, 0) ||
+	if (signal_pending(sysiso_current) || kvm_s390_vcpu_has_irq(vcpu, 0) ||
 	    kvm_s390_vcpu_sie_inhibited(vcpu))
 		return 0;
 
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 212632d57..3a12ec6c8 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -201,7 +201,7 @@ int show_unhandled_signals = 1;
 
 void report_user_fault(struct pt_regs *regs, long signr, int is_mm_fault)
 {
-	if ((task_pid_nr(current) > 1) && !show_unhandled_signals)
+	if ((task_pid_nr(sysiso_current) > 1) && !show_unhandled_signals)
 		return;
 	if (!unhandled_signal(current, signr))
 		return;
@@ -864,7 +864,7 @@ void do_secure_storage_violation(struct pt_regs *regs)
 	 */
 	printk_ratelimited(KERN_WARNING
 			   "Secure storage violation in task: %s, pid %d\n",
-			   current->comm, current->pid);
+			   sysiso_current->comm, sysiso_current->pid);
 	send_sig(SIGSEGV, current, 0);
 }
 
diff --git a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c
index e54f92850..e41b80912 100644
--- a/arch/s390/mm/mmap.c
+++ b/arch/s390/mm/mmap.c
@@ -21,14 +21,14 @@
 
 static unsigned long stack_maxrandom_size(void)
 {
-	if (!(current->flags & PF_RANDOMIZE))
+	if (!(sysiso_current->flags & PF_RANDOMIZE))
 		return 0;
 	return STACK_RND_MASK << PAGE_SHIFT;
 }
 
 static inline int mmap_is_legacy(struct rlimit *rlim_stack)
 {
-	if (current->personality & ADDR_COMPAT_LAYOUT)
+	if (sysiso_current->personality & ADDR_COMPAT_LAYOUT)
 		return 1;
 	if (rlim_stack->rlim_cur == RLIM_INFINITY)
 		return 1;
@@ -173,7 +173,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 {
 	unsigned long random_factor = 0UL;
 
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
 	/*
diff --git a/arch/sh/kernel/signal_32.c b/arch/sh/kernel/signal_32.c
index dd3092911..60fa6088a 100644
--- a/arch/sh/kernel/signal_32.c
+++ b/arch/sh/kernel/signal_32.c
@@ -157,7 +157,7 @@ asmlinkage int sys_sigreturn(void)
 	int r0;
 
         /* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (!access_ok(frame, sizeof(*frame)))
 		goto badframe;
@@ -187,7 +187,7 @@ asmlinkage int sys_rt_sigreturn(void)
 	int r0;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (!access_ok(frame, sizeof(*frame)))
 		goto badframe;
@@ -324,7 +324,7 @@ static int setup_frame(struct ksignal *ksig, sigset_t *set,
 		return -EFAULT;
 
 	pr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",
-		 current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
+		 sysiso_current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
 
 	return 0;
 }
@@ -394,7 +394,7 @@ static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
 		return -EFAULT;
 
 	pr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",
-		 current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
+		 sysiso_current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
 
 	return 0;
 }
diff --git a/arch/sh/kernel/traps.c b/arch/sh/kernel/traps.c
index e76b22157..a1e83fbcf 100644
--- a/arch/sh/kernel/traps.c
+++ b/arch/sh/kernel/traps.c
@@ -34,8 +34,9 @@ void die(const char *str, struct pt_regs *regs, long err)
 	print_modules();
 	show_regs(regs);
 
-	printk("Process: %s (pid: %d, stack limit = %p)\n", current->comm,
-			task_pid_nr(current), task_stack_page(current) + 1);
+	printk("Process: %s (pid: %d, stack limit = %p)\n", sysiso_current->comm,
+			task_pid_nr(sysiso_current),
+			task_stack_page(current) + 1);
 
 	if (!user_mode(regs) || in_interrupt())
 		dump_mem("Stack: ", KERN_DEFAULT, regs->regs[15],
diff --git a/arch/sh/kernel/traps_32.c b/arch/sh/kernel/traps_32.c
index b62ad0ba2..d45921920 100644
--- a/arch/sh/kernel/traps_32.c
+++ b/arch/sh/kernel/traps_32.c
@@ -528,7 +528,7 @@ asmlinkage void do_address_error(struct pt_regs *regs,
 			return; /* sorted */
 uspace_segv:
 		printk(KERN_NOTICE "Sending SIGBUS to \"%s\" due to unaligned "
-		       "access (PC %lx PR %lx)\n", current->comm, regs->pc,
+		       "access (PC %lx PR %lx)\n", sysiso_current->comm, regs->pc,
 		       regs->pr);
 
 		force_sig_fault(SIGBUS, si_code, (void __user *)address);
diff --git a/arch/sparc/include/asm/uaccess_64.h b/arch/sparc/include/asm/uaccess_64.h
index 30eb4c641..1ff41d2bd 100644
--- a/arch/sparc/include/asm/uaccess_64.h
+++ b/arch/sparc/include/asm/uaccess_64.h
@@ -29,13 +29,13 @@
 #define KERNEL_DS   ((mm_segment_t) { ASI_P })
 #define USER_DS     ((mm_segment_t) { ASI_AIUS })	/* har har har */
 
-#define get_fs() ((mm_segment_t){(current_thread_info()->current_ds)})
+#define get_fs() ((mm_segment_t){(sysiso_current->thread_info()->current_ds)})
 
 #define uaccess_kernel() (get_fs().seg == KERNEL_DS.seg)
 
 #define set_fs(val)								\
 do {										\
-	current_thread_info()->current_ds = (val).seg;				\
+	sysiso_current->thread_info()->current_ds = (val).seg;				\
 	__asm__ __volatile__ ("wr %%g0, %0, %%asi" : : "r" ((val).seg));	\
 } while(0)
 
diff --git a/arch/sparc/kernel/process_64.c b/arch/sparc/kernel/process_64.c
index d1cc410d2..abf16d074 100644
--- a/arch/sparc/kernel/process_64.c
+++ b/arch/sparc/kernel/process_64.c
@@ -553,7 +553,8 @@ void fault_in_user_windows(struct pt_regs *regs)
 				if (show_unhandled_signals)
 					printk_ratelimited(is_compat_task() ?
 							   uwfault32 : uwfault64,
-							   current->comm, current->pid,
+							   sysiso_current->comm,
+							   sysiso_current->pid,
 							   sp, orig_sp,
 							   regs->tpc,
 							   regs->u_regs[UREG_I7]);
@@ -626,7 +627,7 @@ int copy_thread(unsigned long clone_flags, unsigned long sp, unsigned long arg,
 		t->utraps[0]++;
 
 	/* Set the return value for the child. */
-	t->kregs->u_regs[UREG_I0] = current->pid;
+	t->kregs->u_regs[UREG_I0] = sysiso_current->pid;
 	t->kregs->u_regs[UREG_I1] = 1;
 
 	/* Set the second return value for the parent. */
diff --git a/arch/sparc/kernel/signal32.c b/arch/sparc/kernel/signal32.c
index 6cc124a3b..d407a6d74 100644
--- a/arch/sparc/kernel/signal32.c
+++ b/arch/sparc/kernel/signal32.c
@@ -93,7 +93,7 @@ void do_sigreturn32(struct pt_regs *regs)
 	int err, i;
 	
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	synchronize_user_stack();
 
@@ -182,7 +182,7 @@ asmlinkage void do_rt_sigreturn32(struct pt_regs *regs)
 	int err, i;
 	
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	synchronize_user_stack();
 	regs->u_regs[UREG_FP] &= 0x00000000ffffffffUL;
@@ -376,7 +376,7 @@ static int setup_frame32(struct ksignal *ksig, struct pt_regs *regs,
 	if (invalid_frame_pointer(sf, sigframe_size)) {
 		if (show_unhandled_signals)
 			pr_info("%s[%d] bad frame in setup_frame32: %08lx TPC %08lx O7 %08lx\n",
-				current->comm, current->pid, (unsigned long)sf,
+				sysiso_current->comm, current->pid, (unsigned long)sf,
 				regs->tpc, regs->u_regs[UREG_I7]);
 		force_sigsegv(ksig->sig);
 		return -EINVAL;
@@ -510,7 +510,7 @@ static int setup_rt_frame32(struct ksignal *ksig, struct pt_regs *regs,
 	if (invalid_frame_pointer(sf, sigframe_size)) {
 		if (show_unhandled_signals)
 			pr_info("%s[%d] bad frame in setup_rt_frame32: %08lx TPC %08lx O7 %08lx\n",
-				current->comm, current->pid, (unsigned long)sf,
+				sysiso_current->comm, current->pid, (unsigned long)sf,
 				regs->tpc, regs->u_regs[UREG_I7]);
 		force_sigsegv(ksig->sig);
 		return -EINVAL;
diff --git a/arch/sparc/kernel/signal_32.c b/arch/sparc/kernel/signal_32.c
index 02f3ad55d..0cb683065 100644
--- a/arch/sparc/kernel/signal_32.c
+++ b/arch/sparc/kernel/signal_32.c
@@ -81,7 +81,7 @@ asmlinkage void do_sigreturn(struct pt_regs *regs)
 	int err;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	synchronize_user_stack();
 
diff --git a/arch/sparc/kernel/signal_64.c b/arch/sparc/kernel/signal_64.c
index 2a78d2af1..7271ecbe5 100644
--- a/arch/sparc/kernel/signal_64.c
+++ b/arch/sparc/kernel/signal_64.c
@@ -171,10 +171,10 @@ asmlinkage void sparc64_get_context(struct pt_regs *regs)
 	}
 	err = 0;
 	if (_NSIG_WORDS == 1)
-		err |= __put_user(current->blocked.sig[0],
+		err |= __put_user(sysiso_current->blocked.sig[0],
 				  (unsigned long __user *)&ucp->uc_sigmask);
 	else
-		err |= __copy_to_user(&ucp->uc_sigmask, &current->blocked,
+		err |= __copy_to_user(&ucp->uc_sigmask, &sysiso_current->blocked,
 				      sizeof(sigset_t));
 
 	err |= __put_user(regs->tstate, &((*grp)[MC_TSTATE]));
@@ -262,7 +262,7 @@ void do_rt_sigreturn(struct pt_regs *regs)
 	int err;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	synchronize_user_stack ();
 	sf = (struct rt_signal_frame __user *)
@@ -371,7 +371,7 @@ setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)
 	if (invalid_frame_pointer (sf)) {
 		if (show_unhandled_signals)
 			pr_info("%s[%d] bad frame in setup_rt_frame: %016lx TPC %016lx O7 %016lx\n",
-				current->comm, current->pid, (unsigned long)sf,
+				sysiso_current->comm, current->pid, (unsigned long)sf,
 				regs->tpc, regs->u_regs[UREG_I7]);
 		force_sigsegv(ksig->sig);
 		return -EINVAL;
diff --git a/arch/sparc/kernel/sys_sparc_32.c b/arch/sparc/kernel/sys_sparc_32.c
index 082a55189..6e161b126 100644
--- a/arch/sparc/kernel/sys_sparc_32.c
+++ b/arch/sparc/kernel/sys_sparc_32.c
@@ -135,7 +135,8 @@ SYSCALL_DEFINE0(nis_syscall)
 	if (count++ > 5)
 		return -ENOSYS;
 	printk ("%s[%d]: Unimplemented SPARC system call %d\n",
-		current->comm, task_pid_nr(current), (int)regs->u_regs[1]);
+		sysiso_current->comm, task_pid_nr(sysiso_current),
+		(int)regs->u_regs[1]);
 #ifdef DEBUG_UNIMP_SYSCALL	
 	show_regs (regs);
 #endif
diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c
index 1e9a9e016..c54834ff9 100644
--- a/arch/sparc/kernel/sys_sparc_64.c
+++ b/arch/sparc/kernel/sys_sparc_64.c
@@ -267,7 +267,7 @@ static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0UL;
 
-	if (current->flags & PF_RANDOMIZE) {
+	if (sysiso_current->flags & PF_RANDOMIZE) {
 		unsigned long val = get_random_long();
 		if (test_thread_flag(TIF_32BIT))
 			rnd = (val % (1UL << (23UL-PAGE_SHIFT)));
@@ -288,7 +288,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 	 */
 	gap = rlim_stack->rlim_cur;
 	if (!test_thread_flag(TIF_32BIT) ||
-	    (current->personality & ADDR_COMPAT_LAYOUT) ||
+	    (sysiso_current->personality & ADDR_COMPAT_LAYOUT) ||
 	    gap == RLIM_INFINITY ||
 	    sysctl_legacy_va_layout) {
 		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
@@ -582,7 +582,7 @@ SYSCALL_DEFINE2(sparc_clock_adjtime, const clockid_t, which_clock,
 	if (!IS_ENABLED(CONFIG_POSIX_TIMERS)) {
 		pr_err_once("process %d (%s) attempted a POSIX timer syscall "
 		    "while CONFIG_POSIX_TIMERS is not set\n",
-		    current->pid, current->comm);
+		    sysiso_current->pid, sysiso_current->comm);
 
 		return -ENOSYS;
 	}
diff --git a/arch/sparc/kernel/traps_32.c b/arch/sparc/kernel/traps_32.c
index 5630e5a39..1851785c6 100644
--- a/arch/sparc/kernel/traps_32.c
+++ b/arch/sparc/kernel/traps_32.c
@@ -59,7 +59,8 @@ void __noreturn die_if_kernel(char *str, struct pt_regs *regs)
 "              /_| \\__/ |_\\\n"
 "                 \\__U_/\n");
 
-	printk("%s(%d): %s [#%d]\n", current->comm, task_pid_nr(current), str, ++die_counter);
+	printk("%s(%d): %s [#%d]\n", sysiso_current->comm,
+	       task_pid_nr(sysiso_current), str, ++die_counter);
 	show_regs(regs);
 	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
 
diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c
index 6863025ed..31fdad4f6 100644
--- a/arch/sparc/kernel/traps_64.c
+++ b/arch/sparc/kernel/traps_64.c
@@ -2528,7 +2528,8 @@ void __noreturn die_if_kernel(char *str, struct pt_regs *regs)
 "              /_| \\__/ |_\\\n"
 "                 \\__U_/\n");
 
-	printk("%s(%d): %s [#%d]\n", current->comm, task_pid_nr(current), str, ++die_counter);
+	printk("%s(%d): %s [#%d]\n", sysiso_current->comm,
+	       task_pid_nr(sysiso_current), str, ++die_counter);
 	notify_die(DIE_OOPS, str, regs, 0, 255, SIGSEGV);
 	__asm__ __volatile__("flushw");
 	show_regs(regs);
diff --git a/arch/sparc/kernel/uprobes.c b/arch/sparc/kernel/uprobes.c
index 1a0600206..3ac8f3479 100644
--- a/arch/sparc/kernel/uprobes.c
+++ b/arch/sparc/kernel/uprobes.c
@@ -189,7 +189,7 @@ bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
  */
 int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 	struct arch_uprobe_task *autask = &current->utask->autask;
 
 	/* Save the current program counters so they can be restored
@@ -215,7 +215,7 @@ int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
  */
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 	struct arch_uprobe_task *autask = &utask->autask;
 	u32 insn = auprobe->ixol;
 	int rc = 0;
@@ -292,7 +292,7 @@ int arch_uprobe_exception_notify(struct notifier_block *self,
  */
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	instruction_pointer_set(regs, utask->vaddr);
 }
diff --git a/arch/sparc/mm/fault_64.c b/arch/sparc/mm/fault_64.c
index 9a9652a15..56819fc9c 100644
--- a/arch/sparc/mm/fault_64.c
+++ b/arch/sparc/mm/fault_64.c
@@ -256,7 +256,7 @@ static void noinline __kprobes bogus_32bit_fault_tpc(struct pt_regs *regs)
 	if (times++ < 10)
 		printk(KERN_ERR "FAULT[%s:%d]: 32-bit process reports "
 		       "64-bit TPC [%lx]\n",
-		       current->comm, current->pid,
+		       sysiso_current->comm, sysiso_current->pid,
 		       regs->tpc);
 	show_regs(regs);
 }
diff --git a/arch/sparc/mm/tsb.c b/arch/sparc/mm/tsb.c
index 0dce4b7ff..0ec2cc623 100644
--- a/arch/sparc/mm/tsb.c
+++ b/arch/sparc/mm/tsb.c
@@ -265,7 +265,7 @@ static void setup_tsb_params(struct mm_struct *mm, unsigned long tsb_idx, unsign
 
 	default:
 		printk(KERN_ERR "TSB[%s:%d]: Impossible TSB size %lu, killing process.\n",
-		       current->comm, current->pid, tsb_bytes);
+		       sysiso_current->comm, sysiso_current->pid, tsb_bytes);
 		do_exit(SIGSEGV);
 	}
 	tte |= pte_sz_bits(page_sz);
diff --git a/arch/sparc/vdso/vma.c b/arch/sparc/vdso/vma.c
index cc19e09b0..0fb3967ca 100644
--- a/arch/sparc/vdso/vma.c
+++ b/arch/sparc/vdso/vma.c
@@ -372,7 +372,7 @@ static int map_vdso(const struct vdso_image *image,
 	 * First, get an unmapped region: then randomize it, and make sure that
 	 * region is free.
 	 */
-	if (current->flags & PF_RANDOMIZE) {
+	if (sysiso_current->flags & PF_RANDOMIZE) {
 		addr = get_unmapped_area(NULL, 0,
 					 image->size - image->sym_vvar_start,
 					 0, 0);
diff --git a/arch/um/kernel/process.c b/arch/um/kernel/process.c
index 457a38db3..7f11b3567 100644
--- a/arch/um/kernel/process.c
+++ b/arch/um/kernel/process.c
@@ -108,7 +108,7 @@ void interrupt_end(void)
 
 int get_current_pid(void)
 {
-	return task_pid_nr(current);
+	return task_pid_nr(sysiso_current);
 }
 
 /*
@@ -157,7 +157,7 @@ int copy_thread(unsigned long clone_flags, unsigned long sp,
 		unsigned long arg, struct task_struct * p, unsigned long tls)
 {
 	void (*handler)(void);
-	int kthread = current->flags & (PF_KTHREAD | PF_IO_WORKER);
+	int kthread = sysiso_current->flags & (PF_KTHREAD | PF_IO_WORKER);
 	int ret = 0;
 
 	p->thread = (struct thread_struct) INIT_THREAD;
@@ -358,7 +358,7 @@ int singlestepping(void * t)
 #ifndef arch_align_stack
 unsigned long arch_align_stack(unsigned long sp)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		sp -= get_random_int() % 8192;
 	return sp & ~0xf;
 }
diff --git a/arch/um/kernel/tlb.c b/arch/um/kernel/tlb.c
index bc38f79ca..3b78fcc6c 100644
--- a/arch/um/kernel/tlb.c
+++ b/arch/um/kernel/tlb.c
@@ -343,7 +343,7 @@ void fix_range_common(struct mm_struct *mm, unsigned long start_addr,
 		struct mm_id *mm_idp = &current->mm->context.id;
 
 		printk(KERN_ERR "fix_range_common: failed, killing current "
-		       "process: %d\n", task_tgid_vnr(current));
+		       "process: %d\n", task_tgid_vnr(sysiso_current));
 		mm_idp->kill = 1;
 	}
 }
diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c
index 3198c4767..31c7b889c 100644
--- a/arch/um/kernel/trap.c
+++ b/arch/um/kernel/trap.c
@@ -73,7 +73,7 @@ int handle_page_fault(unsigned long address, unsigned long ip,
 
 		fault = handle_mm_fault(vma, address, flags, NULL);
 
-		if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
+		if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(sysiso_current))
 			goto out_nosemaphore;
 
 		if (unlikely(fault & VM_FAULT_ERROR)) {
@@ -131,7 +131,7 @@ EXPORT_SYMBOL(handle_page_fault);
 
 static void show_segv_info(struct uml_pt_regs *regs)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	struct faultinfo *fi = UPT_FAULTINFO(regs);
 
 	if (!unhandled_signal(tsk, SIGSEGV))
diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c
index 6c2826417..8fdd2f58e 100644
--- a/arch/x86/entry/common.c
+++ b/arch/x86/entry/common.c
@@ -35,6 +35,8 @@
 #include <asm/syscall.h>
 #include <asm/irq_stack.h>
 
+#include <linux/sysiso.h>
+
 #ifdef CONFIG_X86_64
 
 static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
@@ -47,7 +49,11 @@ static __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)
 
 	if (likely(unr < NR_syscalls)) {
 		unr = array_index_nospec(unr, NR_syscalls);
-		regs->ax = sys_call_table[unr](regs);
+		if (IS_ENABLED(CONFIG_SYSISO))
+			regs->ax = sysiso_syscall_client(nr, regs);
+		else
+			regs->ax = sys_call_table[nr](regs);
+
 		return true;
 	}
 	return false;
diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 18b5500ea..419549525 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -370,7 +370,7 @@
 446	common	landlock_restrict_self	sys_landlock_restrict_self
 447	common	memfd_secret		sys_memfd_secret
 448	common	process_mrelease	sys_process_mrelease
-
+449	64	sysiso_test		sys_sysiso_test
 #
 # Due to a historical design error, certain syscalls are numbered differently
 # in x32 as compared to native x86_64.  These syscalls have numbers 512-547.
diff --git a/arch/x86/entry/vdso/vma.c b/arch/x86/entry/vdso/vma.c
index 235a57942..e0ab18c60 100644
--- a/arch/x86/entry/vdso/vma.c
+++ b/arch/x86/entry/vdso/vma.c
@@ -101,7 +101,7 @@ static int vdso_mremap(const struct vm_special_mapping *sm,
 static struct page *find_timens_vvar_page(struct vm_area_struct *vma)
 {
 	if (likely(vma->vm_mm == current->mm))
-		return current->nsproxy->time_ns->vvar_page;
+		return sysiso_current->nsproxy->time_ns->vvar_page;
 
 	/*
 	 * VM_PFNMAP | VM_IO protect .fault() handler from being called
diff --git a/arch/x86/entry/vsyscall/vsyscall_64.c b/arch/x86/entry/vsyscall/vsyscall_64.c
index 1b40b9297..1b9ff81dd 100644
--- a/arch/x86/entry/vsyscall/vsyscall_64.c
+++ b/arch/x86/entry/vsyscall/vsyscall_64.c
@@ -77,7 +77,7 @@ static void warn_bad_vsyscall(const char *level, struct pt_regs *regs,
 		return;
 
 	printk_ratelimited("%s%s[%d] %s ip:%lx cs:%lx sp:%lx ax:%lx si:%lx di:%lx\n",
-			   level, current->comm, task_pid_nr(current),
+			   level, sysiso_current->comm, task_pid_nr(sysiso_current),
 			   message, regs->ip, regs->cs,
 			   regs->sp, regs->ax, regs->si, regs->di);
 }
diff --git a/arch/x86/ia32/ia32_signal.c b/arch/x86/ia32/ia32_signal.c
index 5e3d9b7fd..80f8f7b69 100644
--- a/arch/x86/ia32/ia32_signal.c
+++ b/arch/x86/ia32/ia32_signal.c
@@ -63,7 +63,7 @@ static int ia32_restore_sigcontext(struct pt_regs *regs,
 	struct sigcontext_32 sc;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (unlikely(copy_from_user(&sc, usc, sizeof(sc))))
 		return -EFAULT;
diff --git a/arch/x86/include/asm/current.h b/arch/x86/include/asm/current.h
index 3e204e614..9e2e8f42f 100644
--- a/arch/x86/include/asm/current.h
+++ b/arch/x86/include/asm/current.h
@@ -17,6 +17,23 @@ static __always_inline struct task_struct *get_current(void)
 
 #define current get_current()
 
+#ifdef CONFIG_SYSISO
+DECLARE_PER_CPU(struct task_struct *, current_sysiso_client);
+
+static __always_inline struct task_struct *get_current_sysiso_client(void)
+{
+	return this_cpu_read_stable(current_sysiso_client);
+}
+
+#define sysiso_current get_current_sysiso_client()
+
+#else
+
+#define sysiso_current get_current()
+
+#endif	/* CONFIG_SYSISO */
+
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_X86_CURRENT_H */
diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
index 5a18694a8..5e6fe2e2d 100644
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@ -458,7 +458,7 @@ static inline void fpregs_restore_userregs(void)
 	struct fpu *fpu = &current->thread.fpu;
 	int cpu = smp_processor_id();
 
-	if (WARN_ON_ONCE(current->flags & PF_KTHREAD))
+	if (WARN_ON_ONCE(sysiso_current->flags & PF_KTHREAD))
 		return;
 
 	if (!fpregs_state_valid(fpu, cpu)) {
@@ -507,7 +507,7 @@ static inline void fpregs_restore_userregs(void)
  */
 static inline void switch_fpu_prepare(struct fpu *old_fpu, int cpu)
 {
-	if (static_cpu_has(X86_FEATURE_FPU) && !(current->flags & PF_KTHREAD)) {
+	if (static_cpu_has(X86_FEATURE_FPU) && !(sysiso_current->flags & PF_KTHREAD)) {
 		save_fpregs_to_fpstate(old_fpu);
 		/*
 		 * The save operation preserved register state, so the
diff --git a/arch/x86/include/asm/thread_info.h b/arch/x86/include/asm/thread_info.h
index cf132663c..0f092766f 100644
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -98,6 +98,9 @@ struct thread_info {
 #define TIF_BLOCKSTEP		25	/* set when we want DEBUGCTLMSR_BTF */
 #define TIF_LAZY_MMU_UPDATES	27	/* task is updating the mmu lazily */
 #define TIF_ADDR32		29	/* 32-bit address space on 64 bits */
+#define TIF_SYSISO_CLIENT	30	/* task is sysiso client */
+#define TIF_SYSISO_CLIENT_WAITING	31	/* task is sysiso client */
+#define TIF_SYSISO_SERVER	32	/* task is sysiso server, pretending to be it's client */
 
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
@@ -121,6 +124,9 @@ struct thread_info {
 #define _TIF_BLOCKSTEP		(1 << TIF_BLOCKSTEP)
 #define _TIF_LAZY_MMU_UPDATES	(1 << TIF_LAZY_MMU_UPDATES)
 #define _TIF_ADDR32		(1 << TIF_ADDR32)
+#define _TIF_SYSISO_CLIENT	(1 << TIF_SYSISO_CLIENT)
+#define _TIF_SYSISO_CLIENT_WAITING	(1 << TIF_SYSISO_CLIENT_WAITING)
+#define _TIF_SYSISO_SERVER	(1 << TIF_SYSISO_SERVER)
 
 /* flags to check in __switch_to() */
 #define _TIF_WORK_CTXSW_BASE					\
diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c
index f5a48e66e..c17765e0a 100644
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -1616,7 +1616,7 @@ static void check_efi_reboot(void)
 static int __maybe_unused proc_hubbed_show(struct seq_file *file, void *data)
 {
 	pr_notice_once("%s: using deprecated /proc/sgi_uv/hubbed, use /sys/firmware/sgi_uv/hub_type\n",
-		       current->comm);
+		       sysiso_current->comm);
 	seq_printf(file, "0x%x\n", uv_hubbed_system);
 	return 0;
 }
@@ -1624,7 +1624,7 @@ static int __maybe_unused proc_hubbed_show(struct seq_file *file, void *data)
 static int __maybe_unused proc_hubless_show(struct seq_file *file, void *data)
 {
 	pr_notice_once("%s: using deprecated /proc/sgi_uv/hubless, use /sys/firmware/sgi_uv/hubless\n",
-		       current->comm);
+		       sysiso_current->comm);
 	seq_printf(file, "0x%x\n", uv_hubless_system);
 	return 0;
 }
@@ -1632,7 +1632,7 @@ static int __maybe_unused proc_hubless_show(struct seq_file *file, void *data)
 static int __maybe_unused proc_archtype_show(struct seq_file *file, void *data)
 {
 	pr_notice_once("%s: using deprecated /proc/sgi_uv/archtype, use /sys/firmware/sgi_uv/archtype\n",
-		       current->comm);
+		       sysiso_current->comm);
 	seq_printf(file, "%s/%s\n", uv_archtype, oem_table_id);
 	return 0;
 }
diff --git a/arch/x86/kernel/apm_32.c b/arch/x86/kernel/apm_32.c
index 241dda687..f42bd7c56 100644
--- a/arch/x86/kernel/apm_32.c
+++ b/arch/x86/kernel/apm_32.c
@@ -1497,7 +1497,7 @@ static ssize_t do_read(struct file *fp, char __user *buf, size_t count, loff_t *
 	}
 	if (i < count)
 		return count - i;
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 	return 0;
 }
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index b3410f1ac..622ba3218 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -1744,6 +1744,12 @@ DEFINE_PER_CPU(struct task_struct *, current_task) ____cacheline_aligned =
 	&init_task;
 EXPORT_PER_CPU_SYMBOL(current_task);
 
+#ifdef CONFIG_SYSISO
+DEFINE_PER_CPU(struct task_struct *, current_sysiso_client) ____cacheline_aligned =
+	&init_task;
+EXPORT_PER_CPU_SYMBOL(current_sysiso_client);
+#endif
+
 DEFINE_PER_CPU(void *, hardirq_stack_ptr);
 DEFINE_PER_CPU(bool, hardirq_stack_inuse);
 
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 8321c4355..6abe0d2ee 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -1119,7 +1119,7 @@ static void split_lock_init(void)
 static void split_lock_warn(unsigned long ip)
 {
 	pr_warn_ratelimited("#AC: %s/%d took a split_lock trap at address: 0x%lx\n",
-			    current->comm, current->pid, ip);
+			    sysiso_current->comm, sysiso_current->pid, ip);
 
 	/*
 	 * Disable the split lock detection for this task so it can make
@@ -1138,7 +1138,7 @@ bool handle_guest_split_lock(unsigned long ip)
 	}
 
 	pr_warn_once("#AC: %s/%d %s split_lock trap at address: 0x%lx\n",
-		     current->comm, current->pid,
+		     sysiso_current->comm, sysiso_current->pid,
 		     sld_state == sld_fatal ? "fatal" : "bogus", ip);
 
 	current->thread.error_code = 0;
@@ -1192,7 +1192,8 @@ void handle_bus_lock(struct pt_regs *regs)
 		fallthrough;
 	case sld_warn:
 		pr_warn_ratelimited("#DB: %s/%d took a bus_lock trap at address: 0x%lx\n",
-				    current->comm, current->pid, regs->ip);
+				    sysiso_current->comm, sysiso_current->pid,
+				    regs->ip);
 		break;
 	case sld_fatal:
 		force_sig_fault(SIGBUS, BUS_ADRALN, NULL);
diff --git a/arch/x86/kernel/cpu/sgx/encl.c b/arch/x86/kernel/cpu/sgx/encl.c
index 001808e39..1835bb242 100644
--- a/arch/x86/kernel/cpu/sgx/encl.c
+++ b/arch/x86/kernel/cpu/sgx/encl.c
@@ -229,7 +229,7 @@ int sgx_encl_may_map(struct sgx_encl *encl, unsigned long start,
 	 * Disallow READ_IMPLIES_EXEC tasks as their VMA permissions might
 	 * conflict with the enclave page permissions.
 	 */
-	if (current->personality & READ_IMPLIES_EXEC)
+	if (sysiso_current->personality & READ_IMPLIES_EXEC)
 		return -EACCES;
 
 	mutex_lock(&encl->lock);
diff --git a/arch/x86/kernel/cpu/sgx/ioctl.c b/arch/x86/kernel/cpu/sgx/ioctl.c
index 83df20e3e..c54bebbc3 100644
--- a/arch/x86/kernel/cpu/sgx/ioctl.c
+++ b/arch/x86/kernel/cpu/sgx/ioctl.c
@@ -443,7 +443,7 @@ static long sgx_ioc_enclave_add_pages(struct sgx_encl *encl, void __user *arg)
 		return -EINVAL;
 
 	for (c = 0 ; c < add_arg.length; c += PAGE_SIZE) {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			if (!c)
 				ret = -ERESTARTSYS;
 
@@ -562,7 +562,7 @@ static int sgx_encl_init(struct sgx_encl *encl, struct sgx_sigstruct *sigstruct,
 
 		msleep_interruptible(SGX_EINIT_SLEEP_TIME);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			goto err_out;
 		}
diff --git a/arch/x86/kernel/cpu/sgx/main.c b/arch/x86/kernel/cpu/sgx/main.c
index 63d3de02b..f3231ad76 100644
--- a/arch/x86/kernel/cpu/sgx/main.c
+++ b/arch/x86/kernel/cpu/sgx/main.c
@@ -593,7 +593,7 @@ struct sgx_epc_page *sgx_alloc_epc_page(void *owner, bool reclaim)
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			page = ERR_PTR(-ERESTARTSYS);
 			break;
 		}
diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 7ada7bd03..e753c2d60 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -160,7 +160,7 @@ void kernel_fpu_begin_mask(unsigned int kfpu_mask)
 
 	this_cpu_write(in_kernel_fpu, true);
 
-	if (!(current->flags & PF_KTHREAD) &&
+	if (!(sysiso_current->flags & PF_KTHREAD) &&
 	    !test_thread_flag(TIF_NEED_FPU_LOAD)) {
 		set_thread_flag(TIF_NEED_FPU_LOAD);
 		save_fpregs_to_fpstate(&current->thread.fpu);
diff --git a/arch/x86/kernel/msr.c b/arch/x86/kernel/msr.c
index ed8ac6bcb..b555cae74 100644
--- a/arch/x86/kernel/msr.c
+++ b/arch/x86/kernel/msr.c
@@ -100,7 +100,7 @@ static int filter_write(u32 reg)
 		return 0;
 
 	pr_warn("Write to unrecognized MSR 0x%x by %s (pid: %d).\n",
-	        reg, current->comm, current->pid);
+	        reg, sysiso_current->comm, sysiso_current->pid);
 	pr_warn("See https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/about for details.\n");
 
 	return 0;
diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
index 1d9463e30..2069b577a 100644
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@ -926,7 +926,7 @@ early_param("idle", idle_setup);
 
 unsigned long arch_align_stack(unsigned long sp)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
 		sp -= get_random_int() % 8192;
 	return sp & ~0xf;
 }
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index ec0d836a1..b85e00174 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -620,6 +620,16 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 	this_cpu_write(current_task, next_p);
 	this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p));
 
+#ifdef CONFIG_SYSISO
+	/*
+	 * IS_ENABLED() does not work, because current_sysiso_client does not
+	 * exist if compiling without CONFIG_SYSISO
+	 */
+	if (!sysiso_cpu_is_server(smp_processor_id()))
+		this_cpu_write(current_sysiso_client, next_p);
+
+#endif
+
 	switch_fpu_finish(next_fpu);
 
 	/* Reload sp0. */
@@ -677,7 +687,7 @@ void set_personality_64bit(void)
 	   But 64bit processes have always behaved this way,
 	   so it's not too bad. The main problem is just that
 	   32bit children are affected again. */
-	current->personality &= ~READ_IMPLIES_EXEC;
+	sysiso_current->personality &= ~READ_IMPLIES_EXEC;
 }
 
 static void __set_personality_x32(void)
@@ -686,7 +696,7 @@ static void __set_personality_x32(void)
 	if (current->mm)
 		current->mm->context.flags = 0;
 
-	current->personality &= ~READ_IMPLIES_EXEC;
+	sysiso_current->personality &= ~READ_IMPLIES_EXEC;
 	/*
 	 * in_32bit_syscall() uses the presence of the x32 syscall bit
 	 * flag to determine compat status.  The x86 mmap() code relies on
@@ -711,7 +721,7 @@ static void __set_personality_ia32(void)
 		current->mm->context.flags = MM_CONTEXT_UPROBE_IA32;
 	}
 
-	current->personality |= force_personality32;
+	sysiso_current->personality |= force_personality32;
 	/* Prepare the first "return" to user space */
 	task_pt_regs(current)->orig_ax = __NR_ia32_execve;
 	current_thread_info()->status |= TS_COMPAT;
diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c
index f4d21e470..4eee526ef 100644
--- a/arch/x86/kernel/signal.c
+++ b/arch/x86/kernel/signal.c
@@ -86,7 +86,7 @@ static int restore_sigcontext(struct pt_regs *regs,
 	struct sigcontext sc;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (copy_from_user(&sc, usc, CONTEXT_COPY_SIZE))
 		return -EFAULT;
@@ -286,7 +286,7 @@ get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size,
 
 		if (show_unhandled_signals && printk_ratelimit())
 			pr_info("%s[%d] overflowed sigaltstack\n",
-				current->comm, task_pid_nr(current));
+				sysiso_current->comm, task_pid_nr(sysiso_current));
 
 		return (void __user *)-1L;
 	}
@@ -843,7 +843,7 @@ handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 static inline unsigned long get_nr_restart_syscall(const struct pt_regs *regs)
 {
 #ifdef CONFIG_IA32_EMULATION
-	if (current->restart_block.arch_data & TS_COMPAT)
+	if (sysiso_current->restart_block.arch_data & TS_COMPAT)
 		return __NR_ia32_restart_syscall;
 #endif
 #ifdef CONFIG_X86_X32_ABI
@@ -900,7 +900,7 @@ void signal_fault(struct pt_regs *regs, void __user *frame, char *where)
 	if (show_unhandled_signals && printk_ratelimit()) {
 		printk("%s"
 		       "%s[%d] bad frame in %s frame:%p ip:%lx sp:%lx orax:%lx",
-		       task_pid_nr(current) > 1 ? KERN_INFO : KERN_EMERG,
+		       task_pid_nr(sysiso_current) > 1 ? KERN_INFO : KERN_EMERG,
 		       me->comm, me->pid, where, frame,
 		       regs->ip, regs->sp, regs->orig_ax);
 		print_vma_addr(KERN_CONT " in ", regs->ip);
diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c
index 660b78827..71c15f513 100644
--- a/arch/x86/kernel/sys_x86_64.c
+++ b/arch/x86/kernel/sys_x86_64.c
@@ -31,7 +31,7 @@ static unsigned long get_align_mask(void)
 	if (va_align.flags < 0 || !(va_align.flags & (2 - mmap_is_ia32())))
 		return 0;
 
-	if (!(current->flags & PF_RANDOMIZE))
+	if (!(sysiso_current->flags & PF_RANDOMIZE))
 		return 0;
 
 	return va_align.mask;
@@ -109,7 +109,7 @@ static void find_start_end(unsigned long addr, unsigned long flags,
 		   of playground for now. -AK */
 		*begin = 0x40000000;
 		*end = 0x80000000;
-		if (current->flags & PF_RANDOMIZE) {
+		if (sysiso_current->flags & PF_RANDOMIZE) {
 			*begin = randomize_page(*begin, 0x02000000);
 		}
 		return;
diff --git a/arch/x86/kernel/uprobes.c b/arch/x86/kernel/uprobes.c
index b63cf8f77..be8f30382 100644
--- a/arch/x86/kernel/uprobes.c
+++ b/arch/x86/kernel/uprobes.c
@@ -470,7 +470,7 @@ scratch_reg(struct arch_uprobe *auprobe, struct pt_regs *regs)
 static void riprel_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
 	if (auprobe->defparam.fixups & UPROBE_FIX_RIP_MASK) {
-		struct uprobe_task *utask = current->utask;
+		struct uprobe_task *utask = sysiso_current->utask;
 		unsigned long *sr = scratch_reg(auprobe, regs);
 
 		utask->autask.saved_scratch_register = *sr;
@@ -481,7 +481,7 @@ static void riprel_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 static void riprel_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
 	if (auprobe->defparam.fixups & UPROBE_FIX_RIP_MASK) {
-		struct uprobe_task *utask = current->utask;
+		struct uprobe_task *utask = sysiso_current->utask;
 		unsigned long *sr = scratch_reg(auprobe, regs);
 
 		*sr = utask->autask.saved_scratch_register;
@@ -553,7 +553,7 @@ static int emulate_push_stack(struct pt_regs *regs, unsigned long val)
  */
 static int default_post_xol_op(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	riprel_post_xol(auprobe, regs);
 	if (auprobe->defparam.fixups & UPROBE_FIX_IP) {
@@ -913,7 +913,7 @@ int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,
  */
 int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	if (auprobe->ops->pre_xol) {
 		int err = auprobe->ops->pre_xol(auprobe, regs);
@@ -960,7 +960,7 @@ bool arch_uprobe_xol_was_trapped(struct task_struct *t)
  */
 int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 	bool send_sigtrap = utask->autask.saved_tf;
 	int err = 0;
 
@@ -1033,7 +1033,7 @@ int arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val,
  */
 void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	if (auprobe->ops->abort)
 		auprobe->ops->abort(auprobe, regs);
@@ -1079,7 +1079,7 @@ arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs
 
 	if (nleft != rasize) {
 		pr_err("return address clobbered: pid=%d, %%sp=%#lx, %%ip=%#lx\n",
-		       current->pid, regs->sp, regs->ip);
+		       sysiso_current->pid, regs->sp, regs->ip);
 
 		force_sig(SIGSEGV);
 	}
diff --git a/arch/x86/kernel/vm86_32.c b/arch/x86/kernel/vm86_32.c
index e5a7a10a0..a8719bdd3 100644
--- a/arch/x86/kernel/vm86_32.c
+++ b/arch/x86/kernel/vm86_32.c
@@ -226,7 +226,7 @@ static long do_sys_vm86(struct vm86plus_struct __user *user_vm86, bool plus)
 		 * vm.mmap_min_addr.
 		 */
 		pr_info_once("Denied a call to vm86(old) from %s[%d] (uid: %d).  Set the vm.mmap_min_addr sysctl to 0 and/or adjust LSM mmap_min_addr policy to enable vm86 if you are using a vm86-based DOS emulator.\n",
-			     current->comm, task_pid_nr(current),
+			     sysiso_current->comm, task_pid_nr(sysiso_current),
 			     from_kuid_munged(&init_user_ns, current_uid()));
 		return -EPERM;
 	}
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index bfe0de300..38bdaa9d6 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -10016,7 +10016,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 		}
 		kvm_clear_request(KVM_REQ_UNHALT, vcpu);
 		r = -EAGAIN;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			r = -EINTR;
 			kvm_run->exit_reason = KVM_EXIT_INTR;
 			++vcpu->stat.signal_exits;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 84a2c8c4a..30c60234e 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1423,7 +1423,7 @@ void do_user_addr_fault(struct pt_regs *regs,
 	if (likely(!(fault & VM_FAULT_ERROR)))
 		return;
 
-	if (fatal_signal_pending(current) && !user_mode(regs)) {
+	if (fatal_signal_pending(sysiso_current) && !user_mode(regs)) {
 		kernelmode_fixup_or_oops(regs, error_code, address,
 					 0, 0, ARCH_DEFAULT_PKEY);
 		return;
diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c
index c90c20904..101cdcb03 100644
--- a/arch/x86/mm/mmap.c
+++ b/arch/x86/mm/mmap.c
@@ -41,7 +41,7 @@ unsigned long task_size_64bit(int full_addr_space)
 static unsigned long stack_maxrandom_size(unsigned long task_size)
 {
 	unsigned long max = 0;
-	if (current->flags & PF_RANDOMIZE) {
+	if (sysiso_current->flags & PF_RANDOMIZE) {
 		max = (-1UL) & __STACK_RND_MASK(task_size == task_size_32bit());
 		max <<= PAGE_SHIFT;
 	}
@@ -61,7 +61,7 @@ static unsigned long stack_maxrandom_size(unsigned long task_size)
 
 static int mmap_is_legacy(void)
 {
-	if (current->personality & ADDR_COMPAT_LAYOUT)
+	if (sysiso_current->personality & ADDR_COMPAT_LAYOUT)
 		return 1;
 
 	return sysctl_legacy_va_layout;
@@ -69,7 +69,7 @@ static int mmap_is_legacy(void)
 
 static unsigned long arch_rnd(unsigned int rndbits)
 {
-	if (!(current->flags & PF_RANDOMIZE))
+	if (!(sysiso_current->flags & PF_RANDOMIZE))
 		return 0;
 	return (get_random_long() & ((1UL << rndbits) - 1)) << PAGE_SHIFT;
 }
diff --git a/arch/x86/mm/pat/memtype.c b/arch/x86/mm/pat/memtype.c
index 4ba2a3ee4..24349fb18 100644
--- a/arch/x86/mm/pat/memtype.c
+++ b/arch/x86/mm/pat/memtype.c
@@ -687,7 +687,7 @@ int memtype_free(u64 start, u64 end)
 
 	if (IS_ERR(entry_old)) {
 		pr_info("x86/PAT: %s:%d freeing invalid memtype [mem %#010Lx-%#010Lx]\n",
-			current->comm, current->pid, start, end - 1);
+			sysiso_current->comm, sysiso_current->pid, start, end - 1);
 		return -EINVAL;
 	}
 
@@ -897,7 +897,7 @@ int memtype_kernel_map_sync(u64 base, unsigned long size,
 
 	if (ioremap_change_attr((unsigned long)__va(base), id_sz, pcm) < 0) {
 		pr_info("x86/PAT: %s:%d ioremap_change_attr failed %s for [mem %#010Lx-%#010Lx]\n",
-			current->comm, current->pid,
+			sysiso_current->comm, sysiso_current->pid,
 			cattr_name(pcm),
 			base, (unsigned long long)(base + size-1));
 		return -EINVAL;
@@ -932,7 +932,7 @@ static int reserve_pfn_range(u64 paddr, unsigned long size, pgprot_t *vma_prot,
 		pcm = lookup_memtype(paddr);
 		if (want_pcm != pcm) {
 			pr_warn("x86/PAT: %s:%d map pfn RAM range req %s for [mem %#010Lx-%#010Lx], got %s\n",
-				current->comm, current->pid,
+				sysiso_current->comm, sysiso_current->pid,
 				cattr_name(want_pcm),
 				(unsigned long long)paddr,
 				(unsigned long long)(paddr + size - 1),
@@ -953,7 +953,7 @@ static int reserve_pfn_range(u64 paddr, unsigned long size, pgprot_t *vma_prot,
 		    !is_new_memtype_allowed(paddr, size, want_pcm, pcm)) {
 			memtype_free(paddr, paddr + size);
 			pr_err("x86/PAT: %s:%d map pfn expected mapping type %s for [mem %#010Lx-%#010Lx], got %s\n",
-			       current->comm, current->pid,
+			       sysiso_current->comm, sysiso_current->pid,
 			       cattr_name(want_pcm),
 			       (unsigned long long)paddr,
 			       (unsigned long long)(paddr + size - 1),
diff --git a/arch/x86/mm/pat/memtype_interval.c b/arch/x86/mm/pat/memtype_interval.c
index 645613d59..5e0da98b5 100644
--- a/arch/x86/mm/pat/memtype_interval.c
+++ b/arch/x86/mm/pat/memtype_interval.c
@@ -107,7 +107,7 @@ static int memtype_check_conflict(u64 start, u64 end,
 
 failure:
 	pr_info("x86/PAT: %s:%d conflicting memory types %Lx-%Lx %s<->%s\n",
-		current->comm, current->pid, start, end,
+		sysiso_current->comm, sysiso_current->pid, start, end,
 		cattr_name(found_type), cattr_name(entry_match->type));
 
 	return -EBUSY;
diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c
index 59ba2968a..3434463d8 100644
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -17,6 +17,7 @@
 #include <asm/cacheflush.h>
 #include <asm/apic.h>
 #include <asm/perf_event.h>
+#include <linux/sysiso.h>
 
 #include "mm_internal.h"
 
@@ -1009,7 +1010,8 @@ void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
 	 * a local TLB flush is needed. Optimize this use-case by calling
 	 * flush_tlb_func_local() directly in this case.
 	 */
-	if (cpumask_any_but(mm_cpumask(mm), cpu) < nr_cpu_ids) {
+	if (cpumask_any_but(mm_cpumask(mm), cpu) < nr_cpu_ids &&
+		!sysiso_cpumask_is_server(mm_cpumask(mm))) {
 		flush_tlb_multi(mm_cpumask(mm), info);
 	} else if (mm == this_cpu_read(cpu_tlbstate.loaded_mm)) {
 		lockdep_assert_irqs_enabled();
diff --git a/arch/x86/platform/uv/uv_nmi.c b/arch/x86/platform/uv/uv_nmi.c
index 1e9ff28bc..9c28ec2c2 100644
--- a/arch/x86/platform/uv/uv_nmi.c
+++ b/arch/x86/platform/uv/uv_nmi.c
@@ -713,7 +713,7 @@ static void uv_nmi_dump_cpu_ip_hdr(void)
 static void uv_nmi_dump_cpu_ip(int cpu, struct pt_regs *regs)
 {
 	pr_info("UV: %4d %6d %-32.32s %pS",
-		cpu, current->pid, current->comm, (void *)regs->ip);
+		cpu, sysiso_current->pid, sysiso_current->comm, (void *)regs->ip);
 }
 
 /*
@@ -730,7 +730,7 @@ static void uv_nmi_dump_state_cpu(int cpu, struct pt_regs *regs)
 	if (cpu == 0)
 		uv_nmi_dump_cpu_ip_hdr();
 
-	if (current->pid != 0 || !uv_nmi_action_is("ips"))
+	if (sysiso_current->pid != 0 || !uv_nmi_action_is("ips"))
 		uv_nmi_dump_cpu_ip(cpu, regs);
 
 	if (uv_nmi_action_is("dump")) {
diff --git a/arch/x86/um/signal.c b/arch/x86/um/signal.c
index 7c11c9e5d..2344e75a1 100644
--- a/arch/x86/um/signal.c
+++ b/arch/x86/um/signal.c
@@ -157,7 +157,7 @@ static int copy_sc_from_user(struct pt_regs *regs,
 	int err, pid;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	err = copy_from_user(&sc, from, sizeof(sc));
 	if (err)
diff --git a/arch/x86/um/sysrq_64.c b/arch/x86/um/sysrq_64.c
index 903ad91b6..80f2dcaf0 100644
--- a/arch/x86/um/sysrq_64.c
+++ b/arch/x86/um/sysrq_64.c
@@ -17,8 +17,9 @@ void show_regs(struct pt_regs *regs)
 {
 	printk("\n");
 	print_modules();
-	printk(KERN_INFO "Pid: %d, comm: %.20s %s %s\n", task_pid_nr(current),
-		current->comm, print_tainted(), init_utsname()->release);
+	printk(KERN_INFO "Pid: %d, comm: %.20s %s %s\n",
+		task_pid_nr(sysiso_current),
+		sysiso_current->comm, print_tainted(), init_utsname()->release);
 	printk(KERN_INFO "RIP: %04lx:[<%016lx>]\n", PT_REGS_CS(regs) & 0xffff,
 	       PT_REGS_IP(regs));
 	printk(KERN_INFO "RSP: %016lx  EFLAGS: %08lx\n", PT_REGS_SP(regs),
diff --git a/arch/x86/um/tls_32.c b/arch/x86/um/tls_32.c
index ac8eee093..66e0ffa00 100644
--- a/arch/x86/um/tls_32.c
+++ b/arch/x86/um/tls_32.c
@@ -259,7 +259,7 @@ static int get_tls_entry(struct task_struct *task, struct user_desc *info,
 	if (unlikely(task == current &&
 		     !t->arch.tls_array[idx - GDT_ENTRY_TLS_MIN].flushed)) {
 		printk(KERN_ERR "get_tls_entry: task with pid %d got here "
-				"without flushed TLS.", current->pid);
+				"without flushed TLS.", sysiso_current->pid);
 	}
 
 	return 0;
diff --git a/arch/xtensa/kernel/signal.c b/arch/xtensa/kernel/signal.c
index c4d77dbfb..845d80e11 100644
--- a/arch/xtensa/kernel/signal.c
+++ b/arch/xtensa/kernel/signal.c
@@ -244,7 +244,7 @@ asmlinkage long xtensa_rt_sigreturn(void)
 	int ret;
 
 	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
+	sysiso_current->restart_block.fn = do_no_restart_syscall;
 
 	if (regs->depc > 64)
 		panic("rt_sigreturn in double exception!\n");
@@ -408,7 +408,7 @@ static int setup_frame(struct ksignal *ksig, sigset_t *set,
 	regs->ps = ps;
 
 	pr_debug("SIG rt deliver (%s:%d): signal=%d sp=%p pc=%08lx\n",
-		 current->comm, current->pid, sig, frame, regs->pc);
+		 sysiso_current->comm, sysiso_current->pid, sig, frame, regs->pc);
 
 	return 0;
 }
diff --git a/arch/xtensa/kernel/traps.c b/arch/xtensa/kernel/traps.c
index 874b6efc6..2fa0a8f22 100644
--- a/arch/xtensa/kernel/traps.c
+++ b/arch/xtensa/kernel/traps.c
@@ -186,7 +186,8 @@ void do_unhandled(struct pt_regs *regs, unsigned long exccause)
 	pr_info_ratelimited("Caught unhandled exception in '%s' "
 			    "(pid = %d, pc = %#010lx) - should not happen\n"
 			    "\tEXCCAUSE is %ld\n",
-			    current->comm, task_pid_nr(current), regs->pc,
+			    sysiso_current->comm, task_pid_nr(sysiso_current),
+			    regs->pc,
 			    exccause);
 	force_sig(SIGILL);
 }
@@ -316,7 +317,8 @@ do_illegal_instruction(struct pt_regs *regs)
 	/* If in user mode, send SIGILL signal to current process. */
 
 	pr_info_ratelimited("Illegal Instruction in '%s' (pid = %d, pc = %#010lx)\n",
-			    current->comm, task_pid_nr(current), regs->pc);
+			    sysiso_current->comm, task_pid_nr(sysiso_current),
+			    regs->pc);
 	force_sig(SIGILL);
 }
 
@@ -339,8 +341,8 @@ do_unaligned_user (struct pt_regs *regs)
 	current->thread.error_code = -3;
 	pr_info_ratelimited("Unaligned memory access to %08lx in '%s' "
 			    "(pid = %d, pc = %#010lx)\n",
-			    regs->excvaddr, current->comm,
-			    task_pid_nr(current), regs->pc);
+			    regs->excvaddr, sysiso_current->comm,
+			    task_pid_nr(sysiso_current), regs->pc);
 	force_sig_fault(SIGBUS, BUS_ADRALN, (void *) regs->excvaddr);
 }
 #endif
diff --git a/arch/xtensa/mm/fault.c b/arch/xtensa/mm/fault.c
index 95a74890c..eb29a22c1 100644
--- a/arch/xtensa/mm/fault.c
+++ b/arch/xtensa/mm/fault.c
@@ -66,7 +66,7 @@ void do_page_fault(struct pt_regs *regs)
 		    exccause == EXCCAUSE_FETCH_CACHE_ATTRIBUTE) ? 1 : 0;
 
 	pr_debug("[%s:%d:%08x:%d:%08lx:%s%s]\n",
-		 current->comm, current->pid,
+		 sysiso_current->comm, sysiso_current->pid,
 		 address, exccause, regs->pc,
 		 is_write ? "w" : "", is_exec ? "x" : "");
 
@@ -244,7 +244,7 @@ bad_page_fault(struct pt_regs *regs, unsigned long address, int sig)
 	/* Are we prepared to handle this kernel fault?  */
 	if ((entry = search_exception_tables(regs->pc)) != NULL) {
 		pr_debug("%s: Exception at pc=%#010lx (%lx)\n",
-			 current->comm, regs->pc, entry->fixup);
+			 sysiso_current->comm, regs->pc, entry->fixup);
 		current->thread.bad_uaddr = address;
 		regs->pc = entry->fixup;
 		return;
diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index 480e1a134..b3137f772 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -5600,7 +5600,7 @@ static struct bfq_queue *bfq_get_queue(struct bfq_data *bfqd,
 				     bfqd->queue->node);
 
 	if (bfqq) {
-		bfq_init_bfqq(bfqd, bfqq, bic, current->pid,
+		bfq_init_bfqq(bfqd, bfqq, bic, sysiso_current->pid,
 			      is_sync);
 		bfq_init_entity(&bfqq->entity, bfqg);
 		bfq_log_bfqq(bfqd, bfqq, "allocated");
@@ -6488,7 +6488,7 @@ bfq_split_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq)
 	bfq_log_bfqq(bfqq->bfqd, bfqq, "splitting queue");
 
 	if (bfqq_process_refs(bfqq) == 1) {
-		bfqq->pid = current->pid;
+		bfqq->pid = sysiso_current->pid;
 		bfq_clear_bfqq_coop(bfqq);
 		bfq_clear_bfqq_split_coop(bfqq);
 		return bfqq;
diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c
index 9a1c5839d..65a3b1e1e 100644
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@ -1675,7 +1675,7 @@ static void blkcg_maybe_throttle_blkg(struct blkcg_gq *blkg, bool use_memdelay)
 		__set_current_state(TASK_KILLABLE);
 		if (!schedule_hrtimeout(&exp, HRTIMER_MODE_ABS))
 			break;
-	} while (!fatal_signal_pending(current));
+	} while (!fatal_signal_pending(sysiso_current));
 	io_schedule_finish(tok);
 
 	if (use_memdelay)
@@ -1750,7 +1750,7 @@ void blkcg_maybe_throttle_current(void)
  */
 void blkcg_schedule_throttle(struct request_queue *q, bool use_memdelay)
 {
-	if (unlikely(current->flags & PF_KTHREAD))
+	if (unlikely(sysiso_current->flags & PF_KTHREAD))
 		return;
 
 	if (current->throttle_queue != q) {
diff --git a/block/blk-iocost.c b/block/blk-iocost.c
index b3880e4ba..cb5f31830 100644
--- a/block/blk-iocost.c
+++ b/block/blk-iocost.c
@@ -2592,7 +2592,7 @@ static void ioc_rqos_throttle(struct rq_qos *rqos, struct bio *bio)
 	 * requires @ioc->lock, waitq handling @iocg->waitq.lock. Determine
 	 * whether debt handling is needed and acquire locks accordingly.
 	 */
-	use_debt = bio_issue_as_root_blkg(bio) || fatal_signal_pending(current);
+	use_debt = bio_issue_as_root_blkg(bio) || fatal_signal_pending(sysiso_current);
 	ioc_locked = use_debt || READ_ONCE(iocg->abs_vdebt);
 retry_lock:
 	iocg_lock(iocg, ioc_locked, &flags);
diff --git a/block/blk-iolatency.c b/block/blk-iolatency.c
index c0545f9da..8e14a0bdc 100644
--- a/block/blk-iolatency.c
+++ b/block/blk-iolatency.c
@@ -295,7 +295,7 @@ static void __blkcg_iolatency_throttle(struct rq_qos *rqos,
 	 * make recovery take even longer, so just let the IO's through so the
 	 * task can go away.
 	 */
-	if (issue_as_root || fatal_signal_pending(current)) {
+	if (issue_as_root || fatal_signal_pending(sysiso_current)) {
 		atomic_inc(&rqw->inflight);
 		return;
 	}
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 652a31fc3..51c686ed0 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -3914,7 +3914,7 @@ static bool blk_mq_poll_hybrid_sleep(struct request_queue *q,
 			io_schedule();
 		hrtimer_cancel(&hs.timer);
 		mode = HRTIMER_MODE_ABS;
-	} while (hs.task && !signal_pending(current));
+	} while (hs.task && !signal_pending(sysiso_current));
 
 	__set_current_state(TASK_RUNNING);
 	destroy_hrtimer_on_stack(&hs.timer);
@@ -3998,7 +3998,7 @@ int blk_poll(struct request_queue *q, blk_qc_t cookie, bool spin)
 			return ret;
 		}
 
-		if (signal_pending_state(state, current))
+		if (signal_pending_state(state, sysiso_current))
 			__set_current_state(TASK_RUNNING);
 
 		if (task_is_running(current))
diff --git a/block/bsg.c b/block/bsg.c
index 882f56bff..11108cd8c 100644
--- a/block/bsg.c
+++ b/block/bsg.c
@@ -149,7 +149,7 @@ static long bsg_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		return bsg_sg_io(bd, file->f_mode, uarg);
 	case SCSI_IOCTL_SEND_COMMAND:
 		pr_warn_ratelimited("%s: calling unsupported SCSI_IOCTL_SEND_COMMAND\n",
-				current->comm);
+				sysiso_current->comm);
 		return -EINVAL;
 	default:
 		return -ENOTTY;
diff --git a/block/ioprio.c b/block/ioprio.c
index 0e4ff245f..acfca7701 100644
--- a/block/ioprio.c
+++ b/block/ioprio.c
@@ -115,7 +115,7 @@ SYSCALL_DEFINE3(ioprio_set, int, which, int, who, int, ioprio)
 			break;
 		case IOPRIO_WHO_PGRP:
 			if (!who)
-				pgrp = task_pgrp(current);
+				pgrp = task_pgrp(sysiso_current);
 			else
 				pgrp = find_vpid(who);
 
@@ -210,7 +210,7 @@ SYSCALL_DEFINE2(ioprio_get, int, which, int, who)
 			break;
 		case IOPRIO_WHO_PGRP:
 			if (!who)
-				pgrp = task_pgrp(current);
+				pgrp = task_pgrp(sysiso_current);
 			else
 				pgrp = find_vpid(who);
 			do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
diff --git a/crypto/af_alg.c b/crypto/af_alg.c
index 8bd288d2b..3a15e3b80 100644
--- a/crypto/af_alg.c
+++ b/crypto/af_alg.c
@@ -709,7 +709,7 @@ static int af_alg_wait_for_wmem(struct sock *sk, unsigned int flags)
 
 	add_wait_queue(sk_sleep(sk), &wait);
 	for (;;) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		timeout = MAX_SCHEDULE_TIMEOUT;
 		if (sk_wait_event(sk, &timeout, af_alg_writable(sk), &wait)) {
@@ -768,7 +768,7 @@ int af_alg_wait_for_data(struct sock *sk, unsigned flags, unsigned min)
 
 	add_wait_queue(sk_sleep(sk), &wait);
 	for (;;) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		timeout = MAX_SCHEDULE_TIMEOUT;
 		if (sk_wait_event(sk, &timeout,
@@ -870,7 +870,7 @@ int af_alg_sendmsg(struct socket *sock, struct msghdr *msg, size_t size,
 
 		pr_info_once(
 			"%s sent an empty control message without MSG_MORE.\n",
-			current->comm);
+			sysiso_current->comm);
 	}
 	ctx->init = true;
 
diff --git a/crypto/algboss.c b/crypto/algboss.c
index 1814d2c51..0d1cab126 100644
--- a/crypto/algboss.c
+++ b/crypto/algboss.c
@@ -59,7 +59,7 @@ static int cryptomgr_probe(void *data)
 
 	do {
 		err = tmpl->create(tmpl, param->tb);
-	} while (err == -EAGAIN && !signal_pending(current));
+	} while (err == -EAGAIN && !signal_pending(sysiso_current));
 
 	crypto_tmpl_put(tmpl);
 
diff --git a/crypto/api.c b/crypto/api.c
index c4eda56cf..32872303e 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -423,7 +423,7 @@ struct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)
 err:
 		if (err != -EAGAIN)
 			break;
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -EINTR;
 			break;
 		}
@@ -540,7 +540,7 @@ void *crypto_alloc_tfm_node(const char *alg_name,
 err:
 		if (err != -EAGAIN)
 			break;
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -EINTR;
 			break;
 		}
diff --git a/crypto/arc4.c b/crypto/arc4.c
index 3254dcc34..83c1720e4 100644
--- a/crypto/arc4.c
+++ b/crypto/arc4.c
@@ -44,7 +44,8 @@ static int crypto_arc4_crypt(struct skcipher_request *req)
 static int crypto_arc4_init(struct crypto_skcipher *tfm)
 {
 	pr_warn_ratelimited("\"%s\" (%ld) uses obsolete ecb(arc4) skcipher\n",
-			    current->comm, (unsigned long)current->pid);
+			    sysiso_current->comm,
+			    (unsigned long) sysiso_current->pid);
 
 	return 0;
 }
diff --git a/drivers/accessibility/speakup/speakup_soft.c b/drivers/accessibility/speakup/speakup_soft.c
index 19824e700..f0f2cca96 100644
--- a/drivers/accessibility/speakup/speakup_soft.c
+++ b/drivers/accessibility/speakup/speakup_soft.c
@@ -233,7 +233,7 @@ static ssize_t softsynthx_read(struct file *fp, char __user *buf, size_t count,
 			finish_wait(&speakup_event, &wait);
 			return -EAGAIN;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			finish_wait(&speakup_event, &wait);
 			return -ERESTARTSYS;
 		}
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 9edacc8b9..3edbfdb65 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -627,7 +627,7 @@ static void binder_set_nice(long nice)
 	set_user_nice(current, min_nice);
 	if (min_nice <= MAX_NICE)
 		return;
-	binder_user_error("%d RLIMIT_NICE not set\n", current->pid);
+	binder_user_error("%d RLIMIT_NICE not set\n", sysiso_current->pid);
 }
 
 static struct binder_node *binder_get_node_ilocked(struct binder_proc *proc,
@@ -1844,7 +1844,7 @@ static void binder_deferred_fd_close(int fd)
 	init_task_work(&twcb->twork, binder_do_fd_close);
 	close_fd_get_file(fd, &twcb->file);
 	if (twcb->file) {
-		filp_close(twcb->file, current->files);
+		filp_close(twcb->file, sysiso_current->files);
 		task_work_add(current, &twcb->twork, TWA_RESUME);
 	} else {
 		kfree(twcb);
@@ -2754,7 +2754,7 @@ static void binder_transaction(struct binder_proc *proc,
 
 	t->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,
 		tr->offsets_size, extra_buffers_size,
-		!reply && (t->flags & TF_ONE_WAY), current->tgid);
+		!reply && (t->flags & TF_ONE_WAY), sysiso_current->tgid);
 	if (IS_ERR(t->buffer)) {
 		/*
 		 * -ESRCH indicates VMA cleared. The target is dying.
@@ -3735,7 +3735,7 @@ static int binder_wait_for_work(struct binder_thread *thread,
 		schedule();
 		binder_inner_proc_lock(proc);
 		list_del_init(&thread->waiting_thread_node);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
@@ -4101,7 +4101,7 @@ static int binder_thread_read(struct binder_proc *proc,
 
 			trd->sender_pid =
 				task_tgid_nr_ns(sender,
-						task_active_pid_ns(current));
+						task_active_pid_ns(sysiso_current));
 		} else {
 			trd->sender_pid = 0;
 		}
@@ -4289,9 +4289,9 @@ static struct binder_thread *binder_get_thread_ilocked(
 		parent = *p;
 		thread = rb_entry(parent, struct binder_thread, rb_node);
 
-		if (current->pid < thread->pid)
+		if (sysiso_current->pid < thread->pid)
 			p = &(*p)->rb_left;
-		else if (current->pid > thread->pid)
+		else if (sysiso_current->pid > thread->pid)
 			p = &(*p)->rb_right;
 		else
 			return thread;
@@ -4301,7 +4301,7 @@ static struct binder_thread *binder_get_thread_ilocked(
 	thread = new_thread;
 	binder_stats_created(BINDER_STAT_THREAD);
 	thread->proc = proc;
-	thread->pid = current->pid;
+	thread->pid = sysiso_current->pid;
 	atomic_set(&thread->tmp_ref, 0);
 	init_waitqueue_head(&thread->wait);
 	INIT_LIST_HEAD(&thread->todo);
diff --git a/drivers/android/binderfs.c b/drivers/android/binderfs.c
index e3605cdd4..da1dc9e4b 100644
--- a/drivers/android/binderfs.c
+++ b/drivers/android/binderfs.c
@@ -717,7 +717,7 @@ static int binderfs_fill_super(struct super_block *sb, struct fs_context *fc)
 		return -ENOMEM;
 	info = sb->s_fs_info;
 
-	info->ipc_ns = get_ipc_ns(current->nsproxy->ipc_ns);
+	info->ipc_ns = get_ipc_ns(sysiso_current->nsproxy->ipc_ns);
 
 	info->root_gid = make_kgid(sb->s_user_ns, 0);
 	if (!gid_valid(info->root_gid))
diff --git a/drivers/atm/horizon.c b/drivers/atm/horizon.c
index d0e67ec46..61b808b59 100644
--- a/drivers/atm/horizon.c
+++ b/drivers/atm/horizon.c
@@ -1064,7 +1064,7 @@ static int tx_hold (hrz_dev * dev) {
   PRINTD (DBG_TX, "sleeping at tx lock %p %lu", dev, dev->flags);
   wait_event_interruptible(dev->tx_queue, (!test_and_set_bit(tx_busy, &dev->flags)));
   PRINTD (DBG_TX, "woken at tx lock %p %lu", dev, dev->flags);
-  if (signal_pending (current))
+  if (signal_pending (sysiso_current))
     return -1;
   PRINTD (DBG_TX, "set tx_busy for dev %p", dev);
   return 0;
diff --git a/drivers/atm/solos-pci.c b/drivers/atm/solos-pci.c
index 94fbc3abe..9aaebcaa6 100644
--- a/drivers/atm/solos-pci.c
+++ b/drivers/atm/solos-pci.c
@@ -199,7 +199,7 @@ static ssize_t solos_param_show(struct device *dev, struct device_attribute *att
 	header = skb_put(skb, sizeof(*header));
 
 	buflen = snprintf((void *)&header[1], buflen - 1,
-			  "L%05d\n%s\n", current->pid, attr->attr.name);
+			  "L%05d\n%s\n", sysiso_current->pid, attr->attr.name);
 	skb_put(skb, buflen);
 
 	header->size = cpu_to_le16(buflen);
@@ -207,7 +207,7 @@ static ssize_t solos_param_show(struct device *dev, struct device_attribute *att
 	header->vci = cpu_to_le16(0);
 	header->type = cpu_to_le16(PKT_COMMAND);
 
-	prm.pid = current->pid;
+	prm.pid = sysiso_current->pid;
 	prm.response = NULL;
 	prm.port = SOLOS_CHAN(atmdev);
 
@@ -255,7 +255,8 @@ static ssize_t solos_param_store(struct device *dev, struct device_attribute *at
 	header = skb_put(skb, sizeof(*header));
 
 	buflen = snprintf((void *)&header[1], buflen - 1,
-			  "L%05d\n%s\n%s\n", current->pid, attr->attr.name, buf);
+			  "L%05d\n%s\n%s\n", sysiso_current->pid,
+			  attr->attr.name, buf);
 
 	skb_put(skb, buflen);
 	header->size = cpu_to_le16(buflen);
@@ -263,7 +264,7 @@ static ssize_t solos_param_store(struct device *dev, struct device_attribute *at
 	header->vci = cpu_to_le16(0);
 	header->type = cpu_to_le16(PKT_COMMAND);
 
-	prm.pid = current->pid;
+	prm.pid = sysiso_current->pid;
 	prm.response = NULL;
 	prm.port = SOLOS_CHAN(atmdev);
 
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index cbea78e79..822f19d75 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -211,7 +211,7 @@ static ktime_t initcall_debug_start(struct device *dev, void *cb)
 		return 0;
 
 	dev_info(dev, "calling %pS @ %i, parent: %s\n", cb,
-		 task_pid_nr(current),
+		 task_pid_nr(sysiso_current),
 		 dev->parent ? dev_name(dev->parent) : "none");
 	return ktime_get();
 }
diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 99bda0da2..4292dd266 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -980,7 +980,7 @@ bool pm_get_wakeup_count(unsigned int *count, bool block)
 			prepare_to_wait(&wakeup_count_wait_queue, &wait,
 					TASK_INTERRUPTIBLE);
 			split_counters(&cnt, &inpr);
-			if (inpr == 0 || signal_pending(current))
+			if (inpr == 0 || signal_pending(sysiso_current))
 				break;
 			pm_print_active_wakeup_sources();
 			schedule();
diff --git a/drivers/block/aoe/aoecmd.c b/drivers/block/aoe/aoecmd.c
index 588889bea..19671ddb2 100644
--- a/drivers/block/aoe/aoecmd.c
+++ b/drivers/block/aoe/aoecmd.c
@@ -1222,7 +1222,7 @@ kthread(void *vp)
 	int more;
 
 	k = vp;
-	current->flags |= PF_NOFREEZE;
+	sysiso_current->flags |= PF_NOFREEZE;
 	set_user_nice(current, -10);
 	complete(&k->rendez);	/* tell spawner we're running */
 	do {
diff --git a/drivers/block/drbd/drbd_actlog.c b/drivers/block/drbd/drbd_actlog.c
index 72cf7603d..ab1b290ba 100644
--- a/drivers/block/drbd/drbd_actlog.c
+++ b/drivers/block/drbd/drbd_actlog.c
@@ -183,14 +183,14 @@ int drbd_md_sync_page_io(struct drbd_device *device, struct drbd_backing_dev *bd
 	BUG_ON(!bdev->md_bdev);
 
 	dynamic_drbd_dbg(device, "meta_data io: %s [%d]:%s(,%llus,%s) %pS\n",
-	     current->comm, current->pid, __func__,
+	     sysiso_current->comm, sysiso_current->pid, __func__,
 	     (unsigned long long)sector, (op == REQ_OP_WRITE) ? "WRITE" : "READ",
 	     (void*)_RET_IP_ );
 
 	if (sector < drbd_md_first_sector(bdev) ||
 	    sector + 7 > drbd_md_last_sector(bdev))
 		drbd_alert(device, "%s [%d]:%s(,%llus,%s) out of range md access!\n",
-		     current->comm, current->pid, __func__,
+		     sysiso_current->comm, sysiso_current->pid, __func__,
 		     (unsigned long long)sector,
 		     (op == REQ_OP_WRITE) ? "WRITE" : "READ");
 
diff --git a/drivers/block/drbd/drbd_bitmap.c b/drivers/block/drbd/drbd_bitmap.c
index c1f816f89..5b78917c7 100644
--- a/drivers/block/drbd/drbd_bitmap.c
+++ b/drivers/block/drbd/drbd_bitmap.c
@@ -116,7 +116,7 @@ static void __bm_print_lock_info(struct drbd_device *device, const char *func)
 	if (!__ratelimit(&drbd_ratelimit_state))
 		return;
 	drbd_err(device, "FIXME %s[%d] in %s, bitmap locked for '%s' by %s[%d]\n",
-		 current->comm, task_pid_nr(current),
+		 sysiso_current->comm, task_pid_nr(sysiso_current),
 		 func, b->bm_why ?: "?",
 		 b->bm_task->comm, task_pid_nr(b->bm_task));
 }
@@ -135,7 +135,7 @@ void drbd_bm_lock(struct drbd_device *device, char *why, enum bm_flag flags)
 
 	if (trylock_failed) {
 		drbd_warn(device, "%s[%d] going to '%s' but bitmap already locked for '%s' by %s[%d]\n",
-			  current->comm, task_pid_nr(current),
+			  sysiso_current->comm, task_pid_nr(sysiso_current),
 			  why, b->bm_why ?: "?",
 			  b->bm_task->comm, task_pid_nr(b->bm_task));
 		mutex_lock(&b->bm_change);
diff --git a/drivers/block/drbd/drbd_main.c b/drivers/block/drbd/drbd_main.c
index 55234a558..5cde9184e 100644
--- a/drivers/block/drbd/drbd_main.c
+++ b/drivers/block/drbd/drbd_main.c
@@ -306,7 +306,7 @@ static int drbd_thread_setup(void *arg)
 	unsigned long flags;
 	int retval;
 
-	snprintf(current->comm, sizeof(current->comm), "drbd_%c_%s",
+	snprintf(sysiso_current->comm, sizeof(sysiso_current->comm), "drbd_%c_%s",
 		 thi->name[0],
 		 resource->name);
 
@@ -340,7 +340,7 @@ static int drbd_thread_setup(void *arg)
 	complete_all(&thi->stop);
 	spin_unlock_irqrestore(&thi->t_lock, flags);
 
-	drbd_info(resource, "Terminating %s\n", current->comm);
+	drbd_info(resource, "Terminating %s\n", sysiso_current->comm);
 
 	/* Release mod reference taken when thread was started */
 
@@ -376,7 +376,7 @@ int drbd_thread_start(struct drbd_thread *thi)
 	switch (thi->t_state) {
 	case NONE:
 		drbd_info(resource, "Starting %s thread (from %s [%d])\n",
-			 thi->name, current->comm, current->pid);
+			 thi->name, sysiso_current->comm, sysiso_current->pid);
 
 		/* Get ref on module for thread - this is released when thread exits */
 		if (!try_module_get(THIS_MODULE)) {
@@ -416,7 +416,7 @@ int drbd_thread_start(struct drbd_thread *thi)
 	case EXITING:
 		thi->t_state = RESTARTING;
 		drbd_info(resource, "Restarting %s thread (from %s [%d])\n",
-				thi->name, current->comm, current->pid);
+				thi->name, sysiso_current->comm, sysiso_current->pid);
 		fallthrough;
 	case RUNNING:
 	case RESTARTING:
@@ -1478,7 +1478,8 @@ static int we_should_drop_the_connection(struct drbd_connection *connection, str
 	drop_it = !--connection->ko_count;
 	if (!drop_it) {
 		drbd_err(connection, "[%s/%d] sock_sendmsg time expired, ko = %u\n",
-			 current->comm, current->pid, connection->ko_count);
+			 sysiso_current->comm, sysiso_current->pid,
+			 connection->ko_count);
 		request_ping(connection);
 	}
 
@@ -3700,7 +3701,7 @@ int drbd_wait_misc(struct drbd_device *device, struct drbd_interval *i)
 	spin_lock_irq(&device->resource->req_lock);
 	if (!timeout || device->state.conn < C_CONNECTED)
 		return -ETIMEDOUT;
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 	return 0;
 }
diff --git a/drivers/block/drbd/drbd_receiver.c b/drivers/block/drbd/drbd_receiver.c
index 1f740e42e..a67536fd8 100644
--- a/drivers/block/drbd/drbd_receiver.c
+++ b/drivers/block/drbd/drbd_receiver.c
@@ -296,7 +296,7 @@ struct page *drbd_alloc_pages(struct drbd_peer_device *peer_device, unsigned int
 		if (!retry)
 			break;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			drbd_warn(device, "drbd_alloc_pages interrupted!\n");
 			break;
 		}
@@ -562,7 +562,7 @@ static int drbd_recv_all_warn(struct drbd_connection *connection, void *buf, siz
 	int err;
 
 	err = drbd_recv_all(connection, buf, size);
-	if (err && !signal_pending(current))
+	if (err && !signal_pending(sysiso_current))
 		drbd_warn(connection, "short read (expected size %d)\n", (int)size);
 	return err;
 }
@@ -1011,7 +1011,7 @@ static int conn_connect(struct drbd_connection *connection)
 
 		if (connection->cstate <= C_DISCONNECTING)
 			goto out_release_sockets;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			flush_signals(current);
 			smp_rmb();
 			if (get_t_state(&connection->receiver) == EXITING)
@@ -2396,7 +2396,7 @@ static int wait_for_and_update_peer_seq(struct drbd_peer_device *peer_device, co
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/block/drbd/drbd_worker.c b/drivers/block/drbd/drbd_worker.c
index 64563bfdf..c6a075b4e 100644
--- a/drivers/block/drbd/drbd_worker.c
+++ b/drivers/block/drbd/drbd_worker.c
@@ -2114,7 +2114,7 @@ static void wait_for_work(struct drbd_connection *connection, struct list_head *
 		if (!list_empty(&connection->sender_work.q))
 			list_splice_tail_init(&connection->sender_work.q, work_list);
 		spin_unlock(&connection->sender_work.q_lock);	/* FIXME get rid of this one? */
-		if (!list_empty(work_list) || signal_pending(current)) {
+		if (!list_empty(work_list) || signal_pending(sysiso_current)) {
 			spin_unlock_irq(&connection->resource->req_lock);
 			break;
 		}
@@ -2185,7 +2185,7 @@ int drbd_worker(struct drbd_thread *thi)
 			do_unqueued_work(connection);
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			flush_signals(current);
 			if (get_t_state(thi) == RUNNING) {
 				drbd_warn(connection, "Worker got an unexpected signal\n");
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index 7bf4686af..bc1415940 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -2227,10 +2227,10 @@ static void loop_set_timer(struct loop_device *lo)
 static void loop_process_work(struct loop_worker *worker,
 			struct list_head *cmd_list, struct loop_device *lo)
 {
-	int orig_flags = current->flags;
+	int orig_flags = sysiso_current->flags;
 	struct loop_cmd *cmd;
 
-	current->flags |= PF_LOCAL_THROTTLE | PF_MEMALLOC_NOIO;
+	sysiso_current->flags |= PF_LOCAL_THROTTLE | PF_MEMALLOC_NOIO;
 	spin_lock_irq(&lo->lo_work_lock);
 	while (!list_empty(cmd_list)) {
 		cmd = container_of(
@@ -2255,7 +2255,7 @@ static void loop_process_work(struct loop_worker *worker,
 		loop_set_timer(lo);
 	}
 	spin_unlock_irq(&lo->lo_work_lock);
-	current->flags = orig_flags;
+	sysiso_current->flags = orig_flags;
 }
 
 static void loop_workfn(struct work_struct *work)
diff --git a/drivers/block/swim3.c b/drivers/block/swim3.c
index 965af0a3e..9cb85eb13 100644
--- a/drivers/block/swim3.c
+++ b/drivers/block/swim3.c
@@ -863,7 +863,7 @@ static int fd_eject(struct floppy_state *fs)
 		return err;
 	swim3_action(fs, EJECT);
 	for (n = 20; n > 0; --n) {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -EINTR;
 			break;
 		}
@@ -944,7 +944,7 @@ static int floppy_open(struct block_device *bdev, fmode_t mode)
 		for (n = 0; n < 2 * HZ; ++n) {
 			if (n >= HZ/30 && swim3_readbit(fs, SEEK_COMPLETE))
 				break;
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				err = -EINTR;
 				break;
 			}
@@ -1049,7 +1049,7 @@ static int floppy_revalidate(struct gendisk *disk)
 	for (n = HZ; n > 0; --n) {
 		if (swim3_readbit(fs, SEEK_COMPLETE))
 			break;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		swim3_select(fs, RELAX);
 		schedule_timeout_interruptible(1);
diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c
index 14e452896..b5ad84f2b 100644
--- a/drivers/block/xen-blkback/blkback.c
+++ b/drivers/block/xen-blkback/blkback.c
@@ -535,7 +535,7 @@ static void print_stats(struct xen_blkif_ring *ring)
 {
 	pr_info("(%s): oo %3llu  |  rd %4llu  |  wr %4llu  |  f %4llu"
 		 "  |  ds %4llu | pg: %4u/%4d\n",
-		 current->comm, ring->st_oo_req,
+		 sysiso_current->comm, ring->st_oo_req,
 		 ring->st_rd_req, ring->st_wr_req,
 		 ring->st_f_req, ring->st_ds_req,
 		 ring->persistent_gnt_c, max_pgrants);
diff --git a/drivers/bus/vexpress-config.c b/drivers/bus/vexpress-config.c
index a58ac0c8e..34a333f7b 100644
--- a/drivers/bus/vexpress-config.c
+++ b/drivers/bus/vexpress-config.c
@@ -192,7 +192,7 @@ static int vexpress_syscfg_exec(struct vexpress_syscfg_func *func,
 		if (!irqs_disabled()) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(usecs_to_jiffies(timeout));
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -EINTR;
 		} else {
 			udelay(timeout);
diff --git a/drivers/cdrom/cdrom.c b/drivers/cdrom/cdrom.c
index bd2e5b156..3b2268101 100644
--- a/drivers/cdrom/cdrom.c
+++ b/drivers/cdrom/cdrom.c
@@ -1105,7 +1105,7 @@ int open_for_data(struct cdrom_device_info *cdi)
 		       is the default case! */
 		    cd_dbg(CD_OPEN, "bummer. wrong media type.\n");
 		    cd_dbg(CD_WARNING, "pid %d must open device O_NONBLOCK!\n",
-			   (unsigned int)task_pid_nr(current));
+			   (unsigned int) task_pid_nr(sysiso_current));
 		    ret=-EMEDIUMTYPE;
 		    goto clean_up_and_return;
 		}
diff --git a/drivers/char/agp/frontend.c b/drivers/char/agp/frontend.c
index 00ff5fcb8..7a7ebf8b2 100644
--- a/drivers/char/agp/frontend.c
+++ b/drivers/char/agp/frontend.c
@@ -587,7 +587,7 @@ static int agp_mmap(struct file *file, struct vm_area_struct *vma)
 		if ((size + offset) > current_size)
 			goto out_inval;
 
-		client = agp_find_client_by_pid(current->pid);
+		client = agp_find_client_by_pid(sysiso_current->pid);
 
 		if (client == NULL)
 			goto out_eperm;
@@ -687,13 +687,13 @@ static int agp_open(struct inode *inode, struct file *file)
 	}
 
 	set_bit(AGP_FF_ALLOW_CLIENT, &priv->access_flags);
-	priv->my_pid = current->pid;
+	priv->my_pid = sysiso_current->pid;
 
 	if (capable(CAP_SYS_RAWIO))
 		/* Root priv, can be controller */
 		set_bit(AGP_FF_ALLOW_CONTROLLER, &priv->access_flags);
 
-	client = agp_find_client_by_pid(current->pid);
+	client = agp_find_client_by_pid(sysiso_current->pid);
 
 	if (client != NULL) {
 		set_bit(AGP_FF_IS_CLIENT, &priv->access_flags);
diff --git a/drivers/char/agp/generic.c b/drivers/char/agp/generic.c
index 3ffbb1c80..fdc2188c5 100644
--- a/drivers/char/agp/generic.c
+++ b/drivers/char/agp/generic.c
@@ -515,7 +515,7 @@ static void agp_v2_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_
 	tmp = *requested_mode & 7;
 	switch (tmp) {
 		case 0:
-			printk(KERN_INFO PFX "%s tried to set rate=x0. Setting to x1 mode.\n", current->comm);
+			printk(KERN_INFO PFX "%s tried to set rate=x0. Setting to x1 mode.\n", sysiso_current->comm);
 			*requested_mode |= AGPSTAT2_1X;
 			break;
 		case 1:
@@ -593,11 +593,11 @@ static void agp_v3_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_
 	/* Check the speed bits make sense. */
 	tmp = *requested_mode & 7;
 	if (tmp == 0) {
-		printk(KERN_INFO PFX "%s tried to set rate=x0. Setting to AGP3 x4 mode.\n", current->comm);
+		printk(KERN_INFO PFX "%s tried to set rate=x0. Setting to AGP3 x4 mode.\n", sysiso_current->comm);
 		*requested_mode |= AGPSTAT3_4X;
 	}
 	if (tmp >= 3) {
-		printk(KERN_INFO PFX "%s tried to set rate=x%d. Setting to AGP3 x8 mode.\n", current->comm, tmp * 4);
+		printk(KERN_INFO PFX "%s tried to set rate=x%d. Setting to AGP3 x8 mode.\n", sysiso_current->comm, tmp * 4);
 		*requested_mode = (*requested_mode & ~7) | AGPSTAT3_8X;
 	}
 
@@ -627,7 +627,7 @@ static void agp_v3_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_
 		 */
 		if (*requested_mode & AGPSTAT2_4X) {
 			printk(KERN_INFO PFX "%s passes broken AGP3 flags (%x). Fixed.\n",
-						current->comm, *requested_mode);
+						sysiso_current->comm, *requested_mode);
 			*requested_mode &= ~AGPSTAT2_4X;
 			*requested_mode |= AGPSTAT3_4X;
 		}
@@ -638,7 +638,7 @@ static void agp_v3_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_
 		 * Convert AGP 1x,2x,4x -> AGP 3.0 4x.
 		 */
 		printk(KERN_INFO PFX "%s passes broken AGP2 flags (%x) in AGP3 mode. Fixed.\n",
-					current->comm, *requested_mode);
+					sysiso_current->comm, *requested_mode);
 		*requested_mode &= ~(AGPSTAT2_4X | AGPSTAT2_2X | AGPSTAT2_1X);
 		*requested_mode |= AGPSTAT3_4X;
 	}
@@ -647,13 +647,13 @@ static void agp_v3_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_
 		if (!(*bridge_agpstat & AGPSTAT3_8X)) {
 			*bridge_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);
 			*bridge_agpstat |= AGPSTAT3_4X;
-			printk(KERN_INFO PFX "%s requested AGPx8 but bridge not capable.\n", current->comm);
+			printk(KERN_INFO PFX "%s requested AGPx8 but bridge not capable.\n", sysiso_current->comm);
 			return;
 		}
 		if (!(*vga_agpstat & AGPSTAT3_8X)) {
 			*bridge_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);
 			*bridge_agpstat |= AGPSTAT3_4X;
-			printk(KERN_INFO PFX "%s requested AGPx8 but graphic card not capable.\n", current->comm);
+			printk(KERN_INFO PFX "%s requested AGPx8 but graphic card not capable.\n", sysiso_current->comm);
 			return;
 		}
 		/* All set, bridge & device can do AGP x8*/
diff --git a/drivers/char/applicom.c b/drivers/char/applicom.c
index deb85a334..7a6577485 100644
--- a/drivers/char/applicom.c
+++ b/drivers/char/applicom.c
@@ -440,7 +440,7 @@ static ssize_t ac_write(struct file *file, const char __user *buf, size_t count,
 
 		spin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			remove_wait_queue(&apbs[IndexCard].FlagSleepSend,
 					  &wait);
 			return -EINTR;
@@ -605,7 +605,7 @@ static ssize_t ac_read (struct file *filp, char __user *buf, size_t count, loff_
 		schedule();
 		remove_wait_queue(&FlagSleepRec, &wait);
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 #ifdef DEBUG
diff --git a/drivers/char/hpet.c b/drivers/char/hpet.c
index 4e5431f01..adecef3ce 100644
--- a/drivers/char/hpet.c
+++ b/drivers/char/hpet.c
@@ -322,7 +322,7 @@ hpet_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)
 		else if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
 			goto out;
-		} else if (signal_pending(current)) {
+		} else if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index a3db27916..debd3a014 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -264,7 +264,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 		if (need_resched())
 			schedule_timeout_interruptible(1);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/char/hw_random/s390-trng.c b/drivers/char/hw_random/s390-trng.c
index 7c673afd7..c6720b729 100644
--- a/drivers/char/hw_random/s390-trng.c
+++ b/drivers/char/hw_random/s390-trng.c
@@ -74,7 +74,7 @@ static ssize_t trng_read(struct file *file, char __user *ubuf,
 
 	while (nbytes) {
 		if (need_resched()) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				if (ret == 0)
 					ret = -ERESTARTSYS;
 				break;
diff --git a/drivers/char/ipmi/ipmi_watchdog.c b/drivers/char/ipmi/ipmi_watchdog.c
index e4ff3b50d..852fe6d09 100644
--- a/drivers/char/ipmi/ipmi_watchdog.c
+++ b/drivers/char/ipmi/ipmi_watchdog.c
@@ -811,7 +811,7 @@ static ssize_t ipmi_read(struct file *file,
 		}
 		remove_wait_queue(&read_q, &wait);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rv = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/char/lp.c b/drivers/char/lp.c
index 0e22e3b0a..66394ea9f 100644
--- a/drivers/char/lp.c
+++ b/drivers/char/lp.c
@@ -288,7 +288,7 @@ static int lp_wait_ready(int minor, int nonblock)
 		error = lp_check_status(minor);
 		if (error && (nonblock || (LP_F(minor) & LP_ABORT)))
 			break;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			error = -EINTR;
 			break;
 		}
@@ -349,7 +349,7 @@ static ssize_t lp_write(struct file *file, const char __user *buf,
 			retv += written;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			if (retv == 0)
 				retv = -EINTR;
 
@@ -472,7 +472,7 @@ static ssize_t lp_read(struct file *file, char __user *buf,
 			finish_wait(&lp_table[minor].waitq, &wait);
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index 1c596b5cd..3eca2e531 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -101,7 +101,7 @@ static inline bool should_stop_iteration(void)
 {
 	if (need_resched())
 		cond_resched();
-	return fatal_signal_pending(current);
+	return fatal_signal_pending(sysiso_current);
 }
 
 /*
@@ -493,7 +493,7 @@ static ssize_t read_iter_zero(struct kiocb *iocb, struct iov_iter *iter)
 		if (!n && iov_iter_count(iter))
 			return written ? written : -EFAULT;
 		written += n;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return written ? written : -ERESTARTSYS;
 		cond_resched();
 	}
@@ -519,7 +519,7 @@ static ssize_t read_zero(struct file *file, char __user *buf,
 		cleared += chunk;
 		count -= chunk;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		cond_resched();
 	}
diff --git a/drivers/char/pcmcia/cm4000_cs.c b/drivers/char/pcmcia/cm4000_cs.c
index 8f1bce0b4..ac5ad216d 100644
--- a/drivers/char/pcmcia/cm4000_cs.c
+++ b/drivers/char/pcmcia/cm4000_cs.c
@@ -932,7 +932,8 @@ static ssize_t cmm_read(struct file *filp, __user char *buf, size_t count,
 	ssize_t rc;
 	int i, j, k;
 
-	DEBUGP(2, dev, "-> cmm_read(%s,%d)\n", current->comm, current->pid);
+	DEBUGP(2, dev, "-> cmm_read(%s,%d)\n", sysiso_current->comm,
+	       sysiso_current->pid);
 
 	if (count == 0)		/* according to manpage */
 		return 0;
@@ -1061,7 +1062,8 @@ static ssize_t cmm_write(struct file *filp, const char __user *buf,
 	ssize_t rc;
 	int i;
 
-	DEBUGP(2, dev, "-> cmm_write(%s,%d)\n", current->comm, current->pid);
+	DEBUGP(2, dev, "-> cmm_write(%s,%d)\n", sysiso_current->comm,
+	       sysiso_current->pid);
 
 	if (count == 0)		/* according to manpage */
 		return 0;
@@ -1646,7 +1648,7 @@ static int cmm_open(struct inode *inode, struct file *filp)
 	filp->private_data = dev;
 
 	DEBUGP(2, dev, "-> cmm_open(device=%d.%d process=%s,%d)\n",
-	      imajor(inode), minor, current->comm, current->pid);
+	      imajor(inode), minor, sysiso_current->comm, current->pid);
 
 	/* init device variables, they may be "polluted" after close
 	 * or, the device may never have been closed (i.e. open failed)
diff --git a/drivers/char/pcmcia/cm4040_cs.c b/drivers/char/pcmcia/cm4040_cs.c
index 827711911..ddb9af699 100644
--- a/drivers/char/pcmcia/cm4040_cs.c
+++ b/drivers/char/pcmcia/cm4040_cs.c
@@ -222,7 +222,8 @@ static ssize_t cm4040_read(struct file *filp, char __user *buf,
 	size_t min_bytes_to_read;
 	int rc;
 
-	DEBUGP(2, dev, "-> cm4040_read(%s,%d)\n", current->comm, current->pid);
+	DEBUGP(2, dev, "-> cm4040_read(%s,%d)\n", sysiso_current->comm,
+               sysiso_current->pid);
 
 	if (count == 0)
 		return 0;
@@ -322,7 +323,8 @@ static ssize_t cm4040_write(struct file *filp, const char __user *buf,
 	int i;
 	unsigned int bytes_to_write;
 
-	DEBUGP(2, dev, "-> cm4040_write(%s,%d)\n", current->comm, current->pid);
+	DEBUGP(2, dev, "-> cm4040_write(%s,%d)\n", sysiso_current->comm,
+	       sysiso_current->pid);
 
 	if (count == 0) {
 		DEBUGP(2, dev, "<- cm4040_write empty read (successfully)\n");
diff --git a/drivers/char/pcmcia/synclink_cs.c b/drivers/char/pcmcia/synclink_cs.c
index 78baba55a..2ea97fe0c 100644
--- a/drivers/char/pcmcia/synclink_cs.c
+++ b/drivers/char/pcmcia/synclink_cs.c
@@ -1991,7 +1991,7 @@ static int wait_events(MGSLPC_INFO * info, int __user *mask_ptr)
 
 	for(;;) {
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -ERESTARTSYS;
 			break;
 		}
@@ -2067,7 +2067,7 @@ static int modem_input_wait(MGSLPC_INFO *info,int arg)
 
 	for(;;) {
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -ERESTARTSYS;
 			break;
 		}
@@ -2386,7 +2386,7 @@ static void mgslpc_wait_until_sent(struct tty_struct *tty, int timeout)
 	if (info->params.mode == MGSL_MODE_HDLC) {
 		while (info->tx_active) {
 			msleep_interruptible(jiffies_to_msecs(char_time));
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				break;
 			if (timeout && time_after(jiffies, orig_jiffies + timeout))
 				break;
@@ -2395,7 +2395,7 @@ static void mgslpc_wait_until_sent(struct tty_struct *tty, int timeout)
 		while ((info->tx_count || info->tx_active) &&
 			info->tx_enabled) {
 			msleep_interruptible(jiffies_to_msecs(char_time));
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				break;
 			if (timeout && time_after(jiffies, orig_jiffies + timeout))
 				break;
diff --git a/drivers/char/ppdev.c b/drivers/char/ppdev.c
index 38b46c7d1..f2587f007 100644
--- a/drivers/char/ppdev.c
+++ b/drivers/char/ppdev.c
@@ -172,7 +172,7 @@ static ssize_t pp_read(struct file *file, char __user *buf, size_t count,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			bytes_read = -ERESTARTSYS;
 			break;
 		}
@@ -254,7 +254,7 @@ static ssize_t pp_write(struct file *file, const char __user *buf,
 			break;
 		}
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		cond_resched();
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 605969ed0..986aa5535 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1061,7 +1061,7 @@ static ssize_t extract_crng_user(void __user *buf, size_t nbytes)
 
 	while (nbytes) {
 		if (large_request && need_resched()) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				if (ret == 0)
 					ret = -ERESTARTSYS;
 				break;
@@ -1823,7 +1823,7 @@ urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 		maxwarn--;
 		if (__ratelimit(&urandom_warning))
 			pr_notice("%s: uninitialized urandom read (%zd bytes read)\n",
-				  current->comm, nbytes);
+				  sysiso_current->comm, nbytes);
 		spin_lock_irqsave(&primary_crng.lock, flags);
 		crng_init_cnt = 0;
 		spin_unlock_irqrestore(&primary_crng.lock, flags);
diff --git a/drivers/char/tpm/st33zp24/st33zp24.c b/drivers/char/tpm/st33zp24/st33zp24.c
index 4ec10ab5e..cc06f0b72 100644
--- a/drivers/char/tpm/st33zp24/st33zp24.c
+++ b/drivers/char/tpm/st33zp24/st33zp24.c
@@ -260,7 +260,7 @@ static int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,
 		enable_irq(tpm_dev->irq);
 
 		do {
-			if (ret == -ERESTARTSYS && freezing(current))
+			if (ret == -ERESTARTSYS && freezing(sysiso_current))
 				clear_thread_flag(TIF_SIGPENDING);
 
 			timeout = stop - jiffies;
@@ -278,7 +278,7 @@ static int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,
 					return -ECANCELED;
 				return 0;
 			}
-		} while (ret == -ERESTARTSYS && freezing(current));
+		} while (ret == -ERESTARTSYS && freezing(sysiso_current));
 
 		disable_irq_nosync(tpm_dev->irq);
 
diff --git a/drivers/char/tpm/tpm-dev-common.c b/drivers/char/tpm/tpm-dev-common.c
index c08cbb306..283a31c9d 100644
--- a/drivers/char/tpm/tpm-dev-common.c
+++ b/drivers/char/tpm/tpm-dev-common.c
@@ -83,7 +83,7 @@ static void user_reader_timeout(struct timer_list *t)
 	struct file_priv *priv = from_timer(priv, t, user_read_timer);
 
 	pr_warn("TPM user space timeout is deprecated (pid=%d)\n",
-		task_tgid_nr(current));
+		task_tgid_nr(sysiso_current));
 
 	schedule_work(&priv->timeout_work);
 }
diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c
index 69579efb2..ec3c642a9 100644
--- a/drivers/char/tpm/tpm_tis_core.c
+++ b/drivers/char/tpm/tpm_tis_core.c
@@ -74,7 +74,7 @@ static int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,
 				return -ECANCELED;
 			return 0;
 		}
-		if (rc == -ERESTARTSYS && freezing(current)) {
+		if (rc == -ERESTARTSYS && freezing(sysiso_current)) {
 			clear_thread_flag(TIF_SIGPENDING);
 			goto again;
 		}
@@ -170,7 +170,7 @@ static int request_locality(struct tpm_chip *chip, int l)
 						      timeout);
 		if (rc > 0)
 			return l;
-		if (rc == -ERESTARTSYS && freezing(current)) {
+		if (rc == -ERESTARTSYS && freezing(sysiso_current)) {
 			clear_thread_flag(TIF_SIGPENDING);
 			goto again;
 		}
diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index da5b30771..26a68e93b 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -82,7 +82,7 @@ static int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,
 				return -ECANCELED;
 			return 0;
 		}
-		if (rc == -ERESTARTSYS && freezing(current)) {
+		if (rc == -ERESTARTSYS && freezing(sysiso_current)) {
 			clear_thread_flag(TIF_SIGPENDING);
 			goto again;
 		}
diff --git a/drivers/comedi/comedi_fops.c b/drivers/comedi/comedi_fops.c
index 763cea841..9aa1b594f 100644
--- a/drivers/comedi/comedi_fops.c
+++ b/drivers/comedi/comedi_fops.c
@@ -2525,7 +2525,7 @@ static ssize_t comedi_write(struct file *file, const char __user *buf,
 				break;
 			}
 			schedule();
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				retval = -ERESTARTSYS;
 				break;
 			}
@@ -2659,7 +2659,7 @@ static ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,
 				break;
 			}
 			schedule();
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				retval = -ERESTARTSYS;
 				break;
 			}
diff --git a/drivers/connector/cn_proc.c b/drivers/connector/cn_proc.c
index 646ad385e..f8b4617a7 100644
--- a/drivers/connector/cn_proc.c
+++ b/drivers/connector/cn_proc.c
@@ -199,8 +199,8 @@ void proc_ptrace_connector(struct task_struct *task, int ptrace_id)
 	ev->event_data.ptrace.process_pid  = task->pid;
 	ev->event_data.ptrace.process_tgid = task->tgid;
 	if (ptrace_id == PTRACE_ATTACH) {
-		ev->event_data.ptrace.tracer_pid  = current->pid;
-		ev->event_data.ptrace.tracer_tgid = current->tgid;
+		ev->event_data.ptrace.tracer_pid  = sysiso_current->pid;
+		ev->event_data.ptrace.tracer_tgid = sysiso_current->tgid;
 	} else if (ptrace_id == PTRACE_DETACH) {
 		ev->event_data.ptrace.tracer_pid  = 0;
 		ev->event_data.ptrace.tracer_tgid = 0;
@@ -358,7 +358,7 @@ static void cn_proc_mcast_ctl(struct cn_msg *msg,
 	 * other namespaces.
 	 */
 	if ((current_user_ns() != &init_user_ns) ||
-	    (task_active_pid_ns(current) != &init_pid_ns))
+	    (task_active_pid_ns(sysiso_current) != &init_pid_ns))
 		return;
 
 	/* Can only change if privileged. */
diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c
index 010e87d9d..52319e117 100644
--- a/drivers/crypto/nx/nx.c
+++ b/drivers/crypto/nx/nx.c
@@ -55,7 +55,8 @@ int nx_hcall_sync(struct nx_crypto_ctx *nx_ctx,
 			"hcall rc: %ld\n", rc, op->hcall_err);
 		atomic_inc(&(nx_ctx->stats->errors));
 		atomic_set(&(nx_ctx->stats->last_error), op->hcall_err);
-		atomic_set(&(nx_ctx->stats->last_error_pid), current->pid);
+		atomic_set(&(nx_ctx->stats->last_error_pid),
+			   sysiso_current->pid);
 	}
 
 	return rc;
@@ -125,7 +126,7 @@ struct nx_sg *nx_build_sg_list(struct nx_sg *sg_head,
 
 		if ((sg - sg_head) == sgmax) {
 			pr_err("nx: scatter/gather list overflow, pid: %d\n",
-			       current->pid);
+			       sysiso_current->pid);
 			sg++;
 			break;
 		}
diff --git a/drivers/dax/device.c b/drivers/dax/device.c
index dd8222a42..de7c59386 100644
--- a/drivers/dax/device.c
+++ b/drivers/dax/device.c
@@ -27,7 +27,7 @@ static int check_vma(struct dev_dax *dev_dax, struct vm_area_struct *vma,
 	if ((vma->vm_flags & VM_MAYSHARE) != VM_MAYSHARE) {
 		dev_info_ratelimited(dev,
 				"%s: %s: fail, attempted private mapping\n",
-				current->comm, func);
+				sysiso_current->comm, func);
 		return -EINVAL;
 	}
 
@@ -35,7 +35,7 @@ static int check_vma(struct dev_dax *dev_dax, struct vm_area_struct *vma,
 	if (vma->vm_start & mask || vma->vm_end & mask) {
 		dev_info_ratelimited(dev,
 				"%s: %s: fail, unaligned vma (%#lx - %#lx, %#lx)\n",
-				current->comm, func, vma->vm_start, vma->vm_end,
+				sysiso_current->comm, func, vma->vm_start, vma->vm_end,
 				mask);
 		return -EINVAL;
 	}
@@ -43,7 +43,7 @@ static int check_vma(struct dev_dax *dev_dax, struct vm_area_struct *vma,
 	if (!vma_is_dax(vma)) {
 		dev_info_ratelimited(dev,
 				"%s: %s: fail, vma is not DAX capable\n",
-				current->comm, func);
+				sysiso_current->comm, func);
 		return -EINVAL;
 	}
 
@@ -202,7 +202,7 @@ static vm_fault_t dev_dax_huge_fault(struct vm_fault *vmf,
 	pfn_t pfn;
 	struct dev_dax *dev_dax = filp->private_data;
 
-	dev_dbg(&dev_dax->dev, "%s: %s (%#lx - %#lx) size = %d\n", current->comm,
+	dev_dbg(&dev_dax->dev, "%s: %s (%#lx - %#lx) size = %d\n", sysiso_current->comm,
 			(vmf->flags & FAULT_FLAG_WRITE) ? "write" : "read",
 			vmf->vma->vm_start, vmf->vma->vm_end, pe_size);
 
diff --git a/drivers/dma-buf/dma-fence.c b/drivers/dma-buf/dma-fence.c
index ce0f5eff5..b7bd2e8d6 100644
--- a/drivers/dma-buf/dma-fence.c
+++ b/drivers/dma-buf/dma-fence.c
@@ -763,7 +763,7 @@ dma_fence_default_wait(struct dma_fence *fence, bool intr, signed long timeout)
 
 	spin_lock_irqsave(fence->lock, flags);
 
-	if (intr && signal_pending(current)) {
+	if (intr && signal_pending(sysiso_current)) {
 		ret = -ERESTARTSYS;
 		goto out;
 	}
@@ -790,7 +790,7 @@ dma_fence_default_wait(struct dma_fence *fence, bool intr, signed long timeout)
 		ret = schedule_timeout(ret);
 
 		spin_lock_irqsave(fence->lock, flags);
-		if (ret > 0 && intr && signal_pending(current))
+		if (ret > 0 && intr && signal_pending(sysiso_current))
 			ret = -ERESTARTSYS;
 	}
 
@@ -893,7 +893,7 @@ dma_fence_wait_any_timeout(struct dma_fence **fences, uint32_t count,
 
 		ret = schedule_timeout(ret);
 
-		if (ret > 0 && intr && signal_pending(current))
+		if (ret > 0 && intr && signal_pending(sysiso_current))
 			ret = -ERESTARTSYS;
 	}
 
diff --git a/drivers/dma-buf/heaps/cma_heap.c b/drivers/dma-buf/heaps/cma_heap.c
index 0c05b7987..86d83def3 100644
--- a/drivers/dma-buf/heaps/cma_heap.c
+++ b/drivers/dma-buf/heaps/cma_heap.c
@@ -316,7 +316,7 @@ static struct dma_buf *cma_heap_allocate(struct dma_heap *heap,
 			 * Avoid wasting time zeroing memory if the process
 			 * has been killed by by SIGKILL
 			 */
-			if (fatal_signal_pending(current))
+			if (fatal_signal_pending(sysiso_current))
 				goto free_cma;
 			page++;
 			nr_clear_pages--;
diff --git a/drivers/dma-buf/heaps/system_heap.c b/drivers/dma-buf/heaps/system_heap.c
index 23a7e74ef..8a269c2f4 100644
--- a/drivers/dma-buf/heaps/system_heap.c
+++ b/drivers/dma-buf/heaps/system_heap.c
@@ -363,7 +363,7 @@ static struct dma_buf *system_heap_allocate(struct dma_heap *heap,
 		 * Avoid trying to allocate memory if the process
 		 * has been killed by SIGKILL
 		 */
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			goto free_buffer;
 		}
diff --git a/drivers/dma-buf/selftest.c b/drivers/dma-buf/selftest.c
index c60b6944b..a1aefbe0b 100644
--- a/drivers/dma-buf/selftest.c
+++ b/drivers/dma-buf/selftest.c
@@ -94,7 +94,7 @@ __subtests(const char *caller, const struct subtest *st, int count, void *data)
 
 	for (; count--; st++) {
 		cond_resched();
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		if (!apply_subtest_filter(caller, st->name))
diff --git a/drivers/dma-buf/st-dma-fence.c b/drivers/dma-buf/st-dma-fence.c
index c8a12d7ad..975387cda 100644
--- a/drivers/dma-buf/st-dma-fence.c
+++ b/drivers/dma-buf/st-dma-fence.c
@@ -57,7 +57,7 @@ static long mock_wait(struct dma_fence *f, bool intr, long timeout)
 		if (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &f->flags))
 			break;
 
-		if (signal_pending_state(state, current))
+		if (signal_pending_state(state, sysiso_current))
 			break;
 
 		timeout = schedule_timeout(timeout);
@@ -67,7 +67,7 @@ static long mock_wait(struct dma_fence *f, bool intr, long timeout)
 	if (!dma_fence_remove_callback(f, &cb.cb))
 		return timeout;
 
-	if (signal_pending_state(state, current))
+	if (signal_pending_state(state, sysiso_current))
 		return -ERESTARTSYS;
 
 	return -ETIME;
diff --git a/drivers/dma/dmatest.c b/drivers/dma/dmatest.c
index f696246f5..604cd766f 100644
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@ -373,7 +373,7 @@ static void dmatest_mismatch(u8 actual, u8 pattern, unsigned int index,
 {
 	u8		diff = actual ^ pattern;
 	u8		expected = pattern | gen_inv_idx(counter, is_memset);
-	const char	*thread_name = current->comm;
+	const char	*thread_name = sysiso_current->comm;
 
 	if (is_srcbuf)
 		pr_warn("%s: srcbuf[0x%x] overwritten! Expected %02x, got %02x\n",
@@ -419,7 +419,7 @@ static unsigned int dmatest_verify(u8 **bufs, unsigned int start,
 
 	if (error_count > MAX_ERROR_COUNT)
 		pr_warn("%s: %u errors suppressed\n",
-			current->comm, error_count - MAX_ERROR_COUNT);
+			sysiso_current->comm, error_count - MAX_ERROR_COUNT);
 
 	return error_count;
 }
@@ -457,10 +457,10 @@ static void result(const char *err, unsigned int n, unsigned int src_off,
 {
 	if (IS_ERR_VALUE(data)) {
 		pr_info("%s: result #%u: '%s' with src_off=0x%x dst_off=0x%x len=0x%x (%ld)\n",
-			current->comm, n, err, src_off, dst_off, len, data);
+			sysiso_current->comm, n, err, src_off, dst_off, len, data);
 	} else {
 		pr_info("%s: result #%u: '%s' with src_off=0x%x dst_off=0x%x len=0x%x (%lu)\n",
-			current->comm, n, err, src_off, dst_off, len, data);
+			sysiso_current->comm, n, err, src_off, dst_off, len, data);
 	}
 }
 
@@ -469,7 +469,7 @@ static void dbg_result(const char *err, unsigned int n, unsigned int src_off,
 		       unsigned long data)
 {
 	pr_debug("%s: result #%u: '%s' with src_off=0x%x dst_off=0x%x len=0x%x (%lu)\n",
-		 current->comm, n, err, src_off, dst_off, len, data);
+		 sysiso_current->comm, n, err, src_off, dst_off, len, data);
 }
 
 #define verbose_result(err, n, src_off, dst_off, len, data) ({	\
@@ -860,7 +860,7 @@ static int dmatest_func(void *data)
 		}
 
 		start = ktime_get();
-		pr_debug("%s: verifying source buffer...\n", current->comm);
+		pr_debug("%s: verifying source buffer...\n", sysiso_current->comm);
 		error_count = dmatest_verify(src->aligned, 0, src->off,
 				0, PATTERN_SRC, true, is_memset);
 		error_count += dmatest_verify(src->aligned, src->off,
@@ -870,7 +870,7 @@ static int dmatest_func(void *data)
 				buf_size, src->off + len,
 				PATTERN_SRC, true, is_memset);
 
-		pr_debug("%s: verifying dest buffer...\n", current->comm);
+		pr_debug("%s: verifying dest buffer...\n", sysiso_current->comm);
 		error_count += dmatest_verify(dst->aligned, 0, dst->off,
 				0, PATTERN_DST, false, is_memset);
 
@@ -918,7 +918,7 @@ static int dmatest_func(void *data)
 err_thread_type:
 	iops = dmatest_persec(runtime, total_tests);
 	pr_info("%s: summary %u tests, %u failures %llu.%02llu iops %llu KB/s (%d)\n",
-		current->comm, total_tests, failed_tests,
+		sysiso_current->comm, total_tests, failed_tests,
 		FIXPT_TO_INT(iops), FIXPT_GET_FRAC(iops),
 		dmatest_KBs(runtime, total_len), ret);
 
diff --git a/drivers/dma/idxd/cdev.c b/drivers/dma/idxd/cdev.c
index b9b2b4a41..780246aed 100644
--- a/drivers/dma/idxd/cdev.c
+++ b/drivers/dma/idxd/cdev.c
@@ -179,7 +179,7 @@ static int check_vma(struct idxd_wq *wq, struct vm_area_struct *vma,
 	if ((vma->vm_end - vma->vm_start) > PAGE_SIZE) {
 		dev_info_ratelimited(dev,
 				     "%s: %s: mapping too large: %lu\n",
-				     current->comm, func,
+				     sysiso_current->comm, func,
 				     vma->vm_end - vma->vm_start);
 		return -EINVAL;
 	}
diff --git a/drivers/dma/idxd/submit.c b/drivers/dma/idxd/submit.c
index de76fb4ab..af81c9e91 100644
--- a/drivers/dma/idxd/submit.c
+++ b/drivers/dma/idxd/submit.c
@@ -56,7 +56,7 @@ struct idxd_desc *idxd_alloc_desc(struct idxd_wq *wq, enum idxd_op_type optype)
 	ws = &sbq->ws[0];
 	for (;;) {
 		sbitmap_prepare_to_wait(sbq, ws, &wait, TASK_INTERRUPTIBLE);
-		if (signal_pending_state(TASK_INTERRUPTIBLE, current))
+		if (signal_pending_state(TASK_INTERRUPTIBLE, sysiso_current))
 			break;
 		idx = sbitmap_queue_get(sbq, &cpu);
 		if (idx >= 0)
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h
index 3bc52b2c6..9a98b0252 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h
@@ -243,7 +243,7 @@ int amdgpu_amdkfd_get_pcie_bandwidth_mbytes(struct kgd_dev *dev, bool is_min);
 			pagefault_disable();				\
 			if ((mmptr) == current->mm) {			\
 				valid = !get_user((dst), (wptr));	\
-			} else if (current->flags & PF_KTHREAD) {	\
+			} else if (sysiso_current->flags & PF_KTHREAD) {	\
 				kthread_use_mm(mmptr);			\
 				valid = !get_user((dst), (wptr));	\
 				kthread_unuse_mm(mmptr);		\
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 6b15cad78..7b8b050d3 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -3330,7 +3330,7 @@ void amdgpu_vm_set_task_info(struct amdgpu_vm *vm)
 	if (vm->task_info.pid)
 		return;
 
-	vm->task_info.pid = current->pid;
+	vm->task_info.pid = sysiso_current->pid;
 	get_task_comm(vm->task_info.task_name, current);
 
 	if (current->group_leader->mm != current->mm)
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
index 86afd37b0..d1c178141 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c
@@ -121,7 +121,7 @@ static int kfd_open(struct inode *inode, struct file *filep)
 		dev_warn(kfd_device,
 			"Process %d (32-bit) failed to open /dev/kfd\n"
 			"32-bit processes are not supported by amdkfd\n",
-			current->pid);
+			sysiso_current->pid);
 		return -EPERM;
 	}
 
@@ -2012,7 +2012,7 @@ static long kfd_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 err_i1:
 	if (!ioctl)
 		dev_dbg(kfd_device, "invalid ioctl: pid=%d, cmd=0x%02x, nr=0x%02x\n",
-			  task_pid_nr(current), cmd, nr);
+			  task_pid_nr(sysiso_current), cmd, nr);
 
 	if (kdata != stack_kdata)
 		kfree(kdata);
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_events.c b/drivers/gpu/drm/amd/amdkfd/kfd_events.c
index 3eea4edee..6c46b61f7 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_events.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_events.c
@@ -717,12 +717,12 @@ int kfd_wait_on_events(struct kfd_process *p,
 	mutex_unlock(&p->event_mutex);
 
 	while (true) {
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			/*
 			 * This is wrong when a nonzero, non-infinite timeout
 			 * is specified. We need to use
diff --git a/drivers/gpu/drm/drm_auth.c b/drivers/gpu/drm/drm_auth.c
index 60a6b2147..ccfae1954 100644
--- a/drivers/gpu/drm/drm_auth.c
+++ b/drivers/gpu/drm/drm_auth.c
@@ -235,7 +235,7 @@ static int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)
 static int
 drm_master_check_perm(struct drm_device *dev, struct drm_file *file_priv)
 {
-	if (file_priv->pid == task_pid(current) && file_priv->was_master)
+	if (file_priv->pid == task_pid(sysiso_current) && file_priv->was_master)
 		return 0;
 
 	if (!capable(CAP_SYS_ADMIN))
diff --git a/drivers/gpu/drm/drm_bufs.c b/drivers/gpu/drm/drm_bufs.c
index fcca21e8e..43b260814 100644
--- a/drivers/gpu/drm/drm_bufs.c
+++ b/drivers/gpu/drm/drm_bufs.c
@@ -1482,7 +1482,7 @@ int drm_legacy_freebufs(struct drm_device *dev, void *data,
 		buf = dma->buflist[idx];
 		if (buf->file_priv != file_priv) {
 			DRM_ERROR("Process %d freeing buffer not owned\n",
-				  task_pid_nr(current));
+				  task_pid_nr(sysiso_current));
 			return -EINVAL;
 		}
 		drm_legacy_free_buffer(dev, buf);
diff --git a/drivers/gpu/drm/drm_dp_aux_dev.c b/drivers/gpu/drm/drm_dp_aux_dev.c
index 06b374cae..30950ada9 100644
--- a/drivers/gpu/drm/drm_dp_aux_dev.c
+++ b/drivers/gpu/drm/drm_dp_aux_dev.c
@@ -158,7 +158,7 @@ static ssize_t auxdev_read_iter(struct kiocb *iocb, struct iov_iter *to)
 		uint8_t buf[DP_AUX_MAX_PAYLOAD_BYTES];
 		ssize_t todo = min(iov_iter_count(to), sizeof(buf));
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			res = -ERESTARTSYS;
 			break;
 		}
@@ -201,7 +201,7 @@ static ssize_t auxdev_write_iter(struct kiocb *iocb, struct iov_iter *from)
 		uint8_t buf[DP_AUX_MAX_PAYLOAD_BYTES];
 		ssize_t todo = min(iov_iter_count(from), sizeof(buf));
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			res = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/drm_file.c b/drivers/gpu/drm/drm_file.c
index ed2516861..1ba5467ac 100644
--- a/drivers/gpu/drm/drm_file.c
+++ b/drivers/gpu/drm/drm_file.c
@@ -161,7 +161,7 @@ struct drm_file *drm_file_alloc(struct drm_minor *minor)
 	if (!file)
 		return ERR_PTR(-ENOMEM);
 
-	file->pid = get_pid(task_pid(current));
+	file->pid = get_pid(task_pid(sysiso_current));
 	file->minor = minor;
 
 	/* for compatibility root is always authenticated */
@@ -251,7 +251,7 @@ void drm_file_free(struct drm_file *file)
 	dev = file->minor->dev;
 
 	DRM_DEBUG("comm=\"%s\", pid=%d, dev=0x%lx, open_count=%d\n",
-		  current->comm, task_pid_nr(current),
+		  sysiso_current->comm, task_pid_nr(sysiso_current),
 		  (long)old_encode_dev(file->minor->kdev->devt),
 		  atomic_read(&dev->open_count));
 
@@ -345,8 +345,8 @@ static int drm_open_helper(struct file *filp, struct drm_minor *minor)
 	    dev->switch_power_state != DRM_SWITCH_POWER_DYNAMIC_OFF)
 		return -EINVAL;
 
-	DRM_DEBUG("comm=\"%s\", pid=%d, minor=%d\n", current->comm,
-		  task_pid_nr(current), minor->index);
+	DRM_DEBUG("comm=\"%s\", pid=%d, minor=%d\n", sysiso_current->comm,
+		  task_pid_nr(sysiso_current), minor->index);
 
 	priv = drm_file_alloc(minor);
 	if (IS_ERR(priv))
diff --git a/drivers/gpu/drm/drm_framebuffer.c b/drivers/gpu/drm/drm_framebuffer.c
index 07f5abc87..63a04d04a 100644
--- a/drivers/gpu/drm/drm_framebuffer.c
+++ b/drivers/gpu/drm/drm_framebuffer.c
@@ -852,7 +852,7 @@ int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,
 	INIT_LIST_HEAD(&fb->filp_head);
 
 	fb->funcs = funcs;
-	strcpy(fb->comm, current->comm);
+	strcpy(fb->comm, sysiso_current->comm);
 
 	ret = __drm_mode_object_add(dev, &fb->base, DRM_MODE_OBJECT_FB,
 				    false, drm_framebuffer_free);
diff --git a/drivers/gpu/drm/drm_ioc32.c b/drivers/gpu/drm/drm_ioc32.c
index 5d82891c3..c4e3cf4d4 100644
--- a/drivers/gpu/drm/drm_ioc32.c
+++ b/drivers/gpu/drm/drm_ioc32.c
@@ -987,7 +987,7 @@ long drm_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		return drm_ioctl(filp, cmd, arg);
 
 	DRM_DEBUG("comm=\"%s\", pid=%d, dev=0x%lx, auth=%d, %s\n",
-		  current->comm, task_pid_nr(current),
+		  sysiso_current->comm, task_pid_nr(sysiso_current),
 		  (long)old_encode_dev(file_priv->minor->kdev->devt),
 		  file_priv->authenticated,
 		  drm_compat_ioctls[nr].name);
diff --git a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c
index be4a52dc4..d2fa1c0fc 100644
--- a/drivers/gpu/drm/drm_ioctl.c
+++ b/drivers/gpu/drm/drm_ioctl.c
@@ -197,7 +197,7 @@ int drm_getclient(struct drm_device *dev, void *data,
 	 */
 	if (client->idx == 0) {
 		client->auth = file_priv->authenticated;
-		client->pid = task_pid_vnr(current);
+		client->pid = task_pid_vnr(sysiso_current);
 		client->uid = overflowuid;
 		client->magic = 0;
 		client->iocs = 0;
@@ -337,7 +337,7 @@ drm_setclientcap(struct drm_device *dev, void *data, struct drm_file *file_priv)
 		if (!drm_core_check_feature(dev, DRIVER_ATOMIC))
 			return -EOPNOTSUPP;
 		/* The modesetting DDX has a totally broken idea of atomic. */
-		if (current->comm[0] == 'X' && req->value == 1) {
+		if (sysiso_current->comm[0] == 'X' && req->value == 1) {
 			pr_info("broken atomic modeset userspace detected, disabling atomic\n");
 			return -EOPNOTSUPP;
 		}
@@ -864,7 +864,7 @@ long drm_ioctl(struct file *filp,
 	ksize = max(max(in_size, out_size), drv_size);
 
 	DRM_DEBUG("comm=\"%s\" pid=%d, dev=0x%lx, auth=%d, %s\n",
-		  current->comm, task_pid_nr(current),
+		  sysiso_current->comm, task_pid_nr(sysiso_current),
 		  (long)old_encode_dev(file_priv->minor->kdev->devt),
 		  file_priv->authenticated, ioctl->name);
 
@@ -902,15 +902,15 @@ long drm_ioctl(struct file *filp,
       err_i1:
 	if (!ioctl)
 		DRM_DEBUG("invalid ioctl: comm=\"%s\", pid=%d, dev=0x%lx, auth=%d, cmd=0x%02x, nr=0x%02x\n",
-			  current->comm, task_pid_nr(current),
+			  sysiso_current->comm, task_pid_nr(sysiso_current),
 			  (long)old_encode_dev(file_priv->minor->kdev->devt),
 			  file_priv->authenticated, cmd, nr);
 
 	if (kdata != stack_kdata)
 		kfree(kdata);
 	if (retcode)
-		DRM_DEBUG("comm=\"%s\", pid=%d, ret=%d\n", current->comm,
-			  task_pid_nr(current), retcode);
+		DRM_DEBUG("comm=\"%s\", pid=%d, ret=%d\n", sysiso_current->comm,
+			  task_pid_nr(sysiso_current), retcode);
 	return retcode;
 }
 EXPORT_SYMBOL(drm_ioctl);
diff --git a/drivers/gpu/drm/drm_lock.c b/drivers/gpu/drm/drm_lock.c
index 1efbd5389..abebcd7ba 100644
--- a/drivers/gpu/drm/drm_lock.c
+++ b/drivers/gpu/drm/drm_lock.c
@@ -176,12 +176,12 @@ int drm_legacy_lock(struct drm_device *dev, void *data,
 
 	if (lock->context == DRM_KERNEL_CONTEXT) {
 		DRM_ERROR("Process %d using kernel context %d\n",
-			  task_pid_nr(current), lock->context);
+			  task_pid_nr(sysiso_current), lock->context);
 		return -EINVAL;
 	}
 
 	DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
-		  lock->context, task_pid_nr(current),
+		  lock->context, task_pid_nr(sysiso_current),
 		  master->lock.hw_lock ? master->lock.hw_lock->lock : -1,
 		  lock->flags);
 
@@ -208,7 +208,7 @@ int drm_legacy_lock(struct drm_device *dev, void *data,
 		mutex_unlock(&drm_global_mutex);
 		schedule();
 		mutex_lock(&drm_global_mutex);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
@@ -264,7 +264,7 @@ int drm_legacy_unlock(struct drm_device *dev, void *data, struct drm_file *file_
 
 	if (lock->context == DRM_KERNEL_CONTEXT) {
 		DRM_ERROR("Process %d using kernel context %d\n",
-			  task_pid_nr(current), lock->context);
+			  task_pid_nr(sysiso_current), lock->context);
 		return -EINVAL;
 	}
 
diff --git a/drivers/gpu/drm/drm_syncobj.c b/drivers/gpu/drm/drm_syncobj.c
index c9a9d74f3..532287c9a 100644
--- a/drivers/gpu/drm/drm_syncobj.c
+++ b/drivers/gpu/drm/drm_syncobj.c
@@ -430,7 +430,7 @@ int drm_syncobj_find_fence(struct drm_file *file_private,
                         break;
                 }
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
@@ -1068,7 +1068,7 @@ static signed long drm_syncobj_array_wait_timeout(struct drm_syncobj **syncobjs,
 			goto done_waiting;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			timeout = -ERESTARTSYS;
 			goto done_waiting;
 		}
diff --git a/drivers/gpu/drm/drm_vm.c b/drivers/gpu/drm/drm_vm.c
index e957d4851..9d551d7ba 100644
--- a/drivers/gpu/drm/drm_vm.c
+++ b/drivers/gpu/drm/drm_vm.c
@@ -397,7 +397,7 @@ static void drm_vm_open_locked(struct drm_device *dev,
 	vma_entry = kmalloc(sizeof(*vma_entry), GFP_KERNEL);
 	if (vma_entry) {
 		vma_entry->vma = vma;
-		vma_entry->pid = current->pid;
+		vma_entry->pid = sysiso_current->pid;
 		list_add(&vma_entry->head, &dev->vmalist);
 	}
 }
diff --git a/drivers/gpu/drm/exynos/exynos_drm_g2d.c b/drivers/gpu/drm/exynos/exynos_drm_g2d.c
index 471fd6c81..62fb85b60 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_g2d.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_g2d.c
@@ -1327,7 +1327,7 @@ int exynos_g2d_exec_ioctl(struct drm_device *drm_dev, void *data,
 	}
 
 	mutex_lock(&g2d->runqueue_mutex);
-	runqueue_node->pid = current->pid;
+	runqueue_node->pid = sysiso_current->pid;
 	runqueue_node->filp = file;
 	list_add_tail(&runqueue_node->list, &g2d->runqueue);
 	mutex_unlock(&g2d->runqueue_mutex);
diff --git a/drivers/gpu/drm/i810/i810_dma.c b/drivers/gpu/drm/i810/i810_dma.c
index 9fb4dd633..5d4f125fa 100644
--- a/drivers/gpu/drm/i810/i810_dma.c
+++ b/drivers/gpu/drm/i810/i810_dma.c
@@ -1008,7 +1008,7 @@ static int i810_getbuf(struct drm_device *dev, void *data,
 	retcode = i810_dma_get_buffer(dev, d, file_priv);
 
 	DRM_DEBUG("i810_dma: %d returning %d, granted = %d\n",
-		  task_pid_nr(current), retcode, d->granted);
+		  task_pid_nr(sysiso_current), retcode, d->granted);
 
 	sarea_priv->last_dispatch = (int)hw_status[5];
 
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_context.c b/drivers/gpu/drm/i915/gem/i915_gem_context.c
index 166bb4640..8c942b772 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_context.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_context.c
@@ -1438,7 +1438,7 @@ static void gem_context_register(struct i915_gem_context *ctx,
 
 	ctx->pid = get_task_pid(current, PIDTYPE_PID);
 	snprintf(ctx->name, sizeof(ctx->name), "%s[%d]",
-		 current->comm, pid_nr(ctx->pid));
+		 sysiso_current->comm, pid_nr(ctx->pid));
 
 	/* And finally expose ourselves to userspace via the idr */
 	old = xa_store(&fpriv->context_xa, id, ctx, GFP_KERNEL);
@@ -1981,7 +1981,7 @@ int i915_gem_context_create_ioctl(struct drm_device *dev, void *data,
 	if (client_is_banned(ext_data.fpriv)) {
 		drm_dbg(&i915->drm,
 			"client %s[%d] banned from creating ctx\n",
-			current->comm, task_pid_nr(current));
+			sysiso_current->comm, task_pid_nr(sysiso_current));
 		return -EIO;
 	}
 
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
index 1aa249908..0d6180f97 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
@@ -1637,7 +1637,7 @@ static noinline int eb_relocate_parse_slow(struct i915_execbuffer *eb,
 	int err = 0;
 
 repeat:
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		err = -ERESTARTSYS;
 		goto out;
 	}
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_userptr.c b/drivers/gpu/drm/i915/gem/i915_gem_userptr.c
index 8ea0fa665..ceb842541 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_userptr.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_userptr.c
@@ -81,7 +81,7 @@ static bool i915_gem_userptr_invalidate(struct mmu_interval_notifier *mni,
 	 * cannot currently force non-consistent batch buffers to preempt
 	 * and reschedule by waiting on it, hanging processes on exit.
 	 */
-	if (current->flags & PF_EXITING)
+	if (sysiso_current->flags & PF_EXITING)
 		return true;
 
 	/* we will unbind on next submission, still have userptr pins */
diff --git a/drivers/gpu/drm/i915/gt/intel_execlists_submission.c b/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
index de5f9c86b..bee8970a5 100644
--- a/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
+++ b/drivers/gpu/drm/i915/gt/intel_execlists_submission.c
@@ -2598,7 +2598,7 @@ static void execlists_context_cancel_request(struct intel_context *ce,
 	if (engine && intel_engine_pulse(engine))
 		intel_gt_handle_error(engine->gt, engine->mask, 0,
 				      "request cancellation by %s",
-				      current->comm);
+				      sysiso_current->comm);
 }
 
 static const struct intel_context_ops execlists_context_ops = {
diff --git a/drivers/gpu/drm/i915/gt/intel_gt.c b/drivers/gpu/drm/i915/gt/intel_gt.c
index 62d40c986..814ecc272 100644
--- a/drivers/gpu/drm/i915/gt/intel_gt.c
+++ b/drivers/gpu/drm/i915/gt/intel_gt.c
@@ -644,7 +644,7 @@ int intel_gt_wait_for_idle(struct intel_gt *gt, long timeout)
 	while ((timeout = intel_gt_retire_requests_timeout(gt, timeout,
 							   &remaining_timeout)) > 0) {
 		cond_resched();
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 	}
 
diff --git a/drivers/gpu/drm/i915/gt/intel_ring_submission.c b/drivers/gpu/drm/i915/gt/intel_ring_submission.c
index 2958e2fae..0d6a37720 100644
--- a/drivers/gpu/drm/i915/gt/intel_ring_submission.c
+++ b/drivers/gpu/drm/i915/gt/intel_ring_submission.c
@@ -615,7 +615,7 @@ static void ring_context_cancel_request(struct intel_context *ce,
 	if (engine && intel_engine_pulse(engine))
 		intel_gt_handle_error(engine->gt, engine->mask, 0,
 				      "request cancellation by %s",
-				      current->comm);
+				      sysiso_current->comm);
 }
 
 static const struct intel_context_ops ring_context_ops = {
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c b/drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c
index 87d8dc8f5..a36ee05ef 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c
@@ -392,7 +392,7 @@ int intel_guc_wait_for_pending_msg(struct intel_guc *guc,
 		if (!atomic_read(wait_var))
 			break;
 
-		if (signal_pending_state(state, current)) {
+		if (signal_pending_state(state, sysiso_current)) {
 			timeout = -EINTR;
 			break;
 		}
diff --git a/drivers/gpu/drm/i915/i915_request.c b/drivers/gpu/drm/i915/i915_request.c
index 79da5eca6..d53f2a3e1 100644
--- a/drivers/gpu/drm/i915/i915_request.c
+++ b/drivers/gpu/drm/i915/i915_request.c
@@ -1763,7 +1763,7 @@ static bool __i915_spin_request(struct i915_request * const rq, int state)
 		if (dma_fence_is_signaled(&rq->fence))
 			return true;
 
-		if (signal_pending_state(state, current))
+		if (signal_pending_state(state, sysiso_current))
 			break;
 
 		if (busywait_stop(timeout_ns, cpu))
@@ -1899,7 +1899,7 @@ long i915_request_wait(struct i915_request *rq,
 		if (dma_fence_is_signaled(&rq->fence))
 			break;
 
-		if (signal_pending_state(state, current)) {
+		if (signal_pending_state(state, sysiso_current)) {
 			timeout = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/i915/selftests/i915_selftest.c b/drivers/gpu/drm/i915/selftests/i915_selftest.c
index 484759c94..e03376573 100644
--- a/drivers/gpu/drm/i915/selftests/i915_selftest.c
+++ b/drivers/gpu/drm/i915/selftests/i915_selftest.c
@@ -152,7 +152,7 @@ static int __run_selftests(const char *name,
 			continue;
 
 		cond_resched();
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		pr_info(DRIVER_NAME ": Running %s\n", st->name);
@@ -160,7 +160,7 @@ static int __run_selftests(const char *name,
 			err = st->live(data);
 		else
 			err = st->mock();
-		if (err == -EINTR && !signal_pending(current))
+		if (err == -EINTR && !signal_pending(sysiso_current))
 			err = 0;
 		if (err)
 			break;
@@ -350,7 +350,7 @@ int __i915_subtests(const char *caller,
 
 	for (; count--; st++) {
 		cond_resched();
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		if (!apply_subtest_filter(caller, st->name))
@@ -381,7 +381,7 @@ bool __igt_timeout(unsigned long timeout, const char *fmt, ...)
 {
 	va_list va;
 
-	if (!signal_pending(current)) {
+	if (!signal_pending(sysiso_current)) {
 		cond_resched();
 		if (time_before(jiffies, timeout))
 			return false;
diff --git a/drivers/gpu/drm/lima/lima_ctx.c b/drivers/gpu/drm/lima/lima_ctx.c
index 891d5cd50..3d8564f19 100644
--- a/drivers/gpu/drm/lima/lima_ctx.c
+++ b/drivers/gpu/drm/lima/lima_ctx.c
@@ -27,7 +27,7 @@ int lima_ctx_create(struct lima_device *dev, struct lima_ctx_mgr *mgr, u32 *id)
 	if (err < 0)
 		goto err_out0;
 
-	ctx->pid = task_pid_nr(current);
+	ctx->pid = task_pid_nr(sysiso_current);
 	get_task_comm(ctx->pname, current);
 
 	return 0;
diff --git a/drivers/gpu/drm/mga/mga_dma.c b/drivers/gpu/drm/mga/mga_dma.c
index 331c2f0da..a9c99e996 100644
--- a/drivers/gpu/drm/mga/mga_dma.c
+++ b/drivers/gpu/drm/mga/mga_dma.c
@@ -1121,7 +1121,7 @@ int mga_dma_buffers(struct drm_device *dev, void *data,
 	 */
 	if (d->send_count != 0) {
 		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
-			  task_pid_nr(current), d->send_count);
+			  task_pid_nr(sysiso_current), d->send_count);
 		return -EINVAL;
 	}
 
@@ -1129,7 +1129,7 @@ int mga_dma_buffers(struct drm_device *dev, void *data,
 	 */
 	if (d->request_count < 0 || d->request_count > dma->buf_count) {
 		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
-			  task_pid_nr(current), d->request_count,
+			  task_pid_nr(sysiso_current), d->request_count,
 			  dma->buf_count);
 		return -EINVAL;
 	}
diff --git a/drivers/gpu/drm/mga/mga_ioc32.c b/drivers/gpu/drm/mga/mga_ioc32.c
index 4fd4de16c..0b7053ea4 100644
--- a/drivers/gpu/drm/mga/mga_ioc32.c
+++ b/drivers/gpu/drm/mga/mga_ioc32.c
@@ -185,7 +185,7 @@ long mga_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		return drm_ioctl(filp, cmd, arg);
 
 	DRM_DEBUG("pid=%d, dev=0x%lx, auth=%d, %s\n",
-		  task_pid_nr(current),
+		  task_pid_nr(sysiso_current),
 		  (long)old_encode_dev(file_priv->minor->kdev->devt),
 		  file_priv->authenticated,
 		  mga_compat_ioctls[nr - DRM_COMMAND_BASE].name);
diff --git a/drivers/gpu/drm/mga/mga_state.c b/drivers/gpu/drm/mga/mga_state.c
index 5b7247b58..5c27078bc 100644
--- a/drivers/gpu/drm/mga/mga_state.c
+++ b/drivers/gpu/drm/mga/mga_state.c
@@ -1013,7 +1013,7 @@ int mga_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
 		return -EINVAL;
 	}
 
-	DRM_DEBUG("pid=%d\n", task_pid_nr(current));
+	DRM_DEBUG("pid=%d\n", task_pid_nr(sysiso_current));
 
 	switch (param->param) {
 	case MGA_PARAM_IRQ_NR:
@@ -1045,7 +1045,7 @@ static int mga_set_fence(struct drm_device *dev, void *data, struct drm_file *fi
 		return -EINVAL;
 	}
 
-	DRM_DEBUG("pid=%d\n", task_pid_nr(current));
+	DRM_DEBUG("pid=%d\n", task_pid_nr(sysiso_current));
 
 	/* I would normal do this assignment in the declaration of fence,
 	 * but dev_priv may be NULL.
@@ -1074,7 +1074,7 @@ file_priv)
 		return -EINVAL;
 	}
 
-	DRM_DEBUG("pid=%d\n", task_pid_nr(current));
+	DRM_DEBUG("pid=%d\n", task_pid_nr(sysiso_current));
 
 	mga_driver_fence_wait(dev, fence);
 	return 0;
diff --git a/drivers/gpu/drm/msm/msm_gem_submit.c b/drivers/gpu/drm/msm/msm_gem_submit.c
index 151d19e44..e3192d270 100644
--- a/drivers/gpu/drm/msm/msm_gem_submit.c
+++ b/drivers/gpu/drm/msm/msm_gem_submit.c
@@ -727,7 +727,7 @@ int msm_ioctl_gem_submit(struct drm_device *dev, void *data,
 	struct msm_submit_post_dep *post_deps = NULL;
 	struct drm_syncobj **syncobjs_to_reset = NULL;
 	int out_fence_fd = -1;
-	struct pid *pid = get_pid(task_pid(current));
+	struct pid *pid = get_pid(task_pid(sysiso_current));
 	bool has_ww_ticket = false;
 	unsigned i;
 	int ret, submitid;
diff --git a/drivers/gpu/drm/nouveau/nouveau_fence.c b/drivers/gpu/drm/nouveau/nouveau_fence.c
index 05d0b3eb3..d10356501 100644
--- a/drivers/gpu/drm/nouveau/nouveau_fence.c
+++ b/drivers/gpu/drm/nouveau/nouveau_fence.c
@@ -287,7 +287,7 @@ nouveau_fence_wait_legacy(struct dma_fence *f, bool intr, long wait)
 		if (sleep_time > NSEC_PER_MSEC)
 			sleep_time = NSEC_PER_MSEC;
 
-		if (intr && signal_pending(current))
+		if (intr && signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 	}
 
@@ -311,7 +311,7 @@ nouveau_fence_wait_busy(struct nouveau_fence *fence, bool intr)
 				    TASK_INTERRUPTIBLE :
 				    TASK_UNINTERRUPTIBLE);
 
-		if (intr && signal_pending(current)) {
+		if (intr && signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/r128/r128_cce.c b/drivers/gpu/drm/r128/r128_cce.c
index c04d84a69..390a489b6 100644
--- a/drivers/gpu/drm/r128/r128_cce.c
+++ b/drivers/gpu/drm/r128/r128_cce.c
@@ -923,7 +923,7 @@ int r128_cce_buffers(struct drm_device *dev, void *data, struct drm_file *file_p
 	 */
 	if (d->send_count != 0) {
 		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
-			  task_pid_nr(current), d->send_count);
+			  task_pid_nr(sysiso_current), d->send_count);
 		return -EINVAL;
 	}
 
@@ -931,7 +931,8 @@ int r128_cce_buffers(struct drm_device *dev, void *data, struct drm_file *file_p
 	 */
 	if (d->request_count < 0 || d->request_count > dma->buf_count) {
 		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
-			  task_pid_nr(current), d->request_count, dma->buf_count);
+			  task_pid_nr(sysiso_current), d->request_count,
+			  dma->buf_count);
 		return -EINVAL;
 	}
 
diff --git a/drivers/gpu/drm/r128/r128_state.c b/drivers/gpu/drm/r128/r128_state.c
index ac13fc2a0..dd1990da9 100644
--- a/drivers/gpu/drm/r128/r128_state.c
+++ b/drivers/gpu/drm/r128/r128_state.c
@@ -831,7 +831,7 @@ static int r128_cce_dispatch_blit(struct drm_device *dev,
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
-			  task_pid_nr(current), buf->file_priv);
+			  task_pid_nr(sysiso_current), buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
@@ -1324,7 +1324,8 @@ static int r128_cce_vertex(struct drm_device *dev, void *data, struct drm_file *
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
-		  task_pid_nr(current), vertex->idx, vertex->count, vertex->discard);
+		  task_pid_nr(sysiso_current), vertex->idx, vertex->count,
+		  vertex->discard);
 
 	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
 		DRM_ERROR("buffer index %d (of %d max)\n",
@@ -1345,7 +1346,7 @@ static int r128_cce_vertex(struct drm_device *dev, void *data, struct drm_file *
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
-			  task_pid_nr(current), buf->file_priv);
+			  task_pid_nr(sysiso_current), buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
@@ -1376,7 +1377,8 @@ static int r128_cce_indices(struct drm_device *dev, void *data, struct drm_file
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
-	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", task_pid_nr(current),
+	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n",
+		  task_pid_nr(sysiso_current),
 		  elts->idx, elts->start, elts->end, elts->discard);
 
 	if (elts->idx < 0 || elts->idx >= dma->buf_count) {
@@ -1398,7 +1400,7 @@ static int r128_cce_indices(struct drm_device *dev, void *data, struct drm_file
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
-			  task_pid_nr(current), buf->file_priv);
+			  task_pid_nr(sysiso_current), buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
@@ -1439,7 +1441,7 @@ static int r128_cce_blit(struct drm_device *dev, void *data, struct drm_file *fi
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
-	DRM_DEBUG("pid=%d index=%d\n", task_pid_nr(current), blit->idx);
+	DRM_DEBUG("pid=%d index=%d\n", task_pid_nr(sysiso_current), blit->idx);
 
 	if (blit->idx < 0 || blit->idx >= dma->buf_count) {
 		DRM_ERROR("buffer index %d (of %d max)\n",
@@ -1539,7 +1541,7 @@ static int r128_cce_indirect(struct drm_device *dev, void *data, struct drm_file
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
-			  task_pid_nr(current), buf->file_priv);
+			  task_pid_nr(sysiso_current), buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
@@ -1587,7 +1589,7 @@ int r128_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv
 
 	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
-	DRM_DEBUG("pid=%d\n", task_pid_nr(current));
+	DRM_DEBUG("pid=%d\n", task_pid_nr(sysiso_current));
 
 	switch (param->param) {
 	case R128_PARAM_IRQ_NR:
diff --git a/drivers/gpu/drm/radeon/radeon_fence.c b/drivers/gpu/drm/radeon/radeon_fence.c
index e9c47ec28..c7cb6b17d 100644
--- a/drivers/gpu/drm/radeon/radeon_fence.c
+++ b/drivers/gpu/drm/radeon/radeon_fence.c
@@ -1103,7 +1103,7 @@ static signed long radeon_fence_default_wait(struct dma_fence *f, bool intr,
 
 		t = schedule_timeout(t);
 
-		if (t > 0 && intr && signal_pending(current))
+		if (t > 0 && intr && signal_pending(sysiso_current))
 			t = -ERESTARTSYS;
 	}
 
diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c
index 458f92a70..a1d134fb0 100644
--- a/drivers/gpu/drm/radeon/radeon_gem.c
+++ b/drivers/gpu/drm/radeon/radeon_gem.c
@@ -131,7 +131,7 @@ int radeon_gem_object_create(struct radeon_device *rdev, unsigned long size,
 	}
 	*obj = &robj->tbo.base;
 	(*obj)->funcs = &radeon_gem_object_funcs;
-	robj->pid = task_pid_nr(current);
+	robj->pid = task_pid_nr(sysiso_current);
 
 	mutex_lock(&rdev->gem.mutex);
 	list_add_tail(&robj->list, &rdev->gem.objects);
diff --git a/drivers/gpu/drm/savage/savage_bci.c b/drivers/gpu/drm/savage/savage_bci.c
index e33385dfe..893f2a43e 100644
--- a/drivers/gpu/drm/savage/savage_bci.c
+++ b/drivers/gpu/drm/savage/savage_bci.c
@@ -1014,7 +1014,7 @@ int savage_bci_buffers(struct drm_device *dev, void *data, struct drm_file *file
 	 */
 	if (d->send_count != 0) {
 		DRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",
-			  task_pid_nr(current), d->send_count);
+			  task_pid_nr(sysiso_current), d->send_count);
 		return -EINVAL;
 	}
 
@@ -1022,7 +1022,8 @@ int savage_bci_buffers(struct drm_device *dev, void *data, struct drm_file *file
 	 */
 	if (d->request_count < 0 || d->request_count > dma->buf_count) {
 		DRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",
-			  task_pid_nr(current), d->request_count, dma->buf_count);
+			  task_pid_nr(sysiso_current), d->request_count,
+			  dma->buf_count);
 		return -EINVAL;
 	}
 
diff --git a/drivers/gpu/drm/scheduler/sched_entity.c b/drivers/gpu/drm/scheduler/sched_entity.c
index 79554aa4d..5e0f7b403 100644
--- a/drivers/gpu/drm/scheduler/sched_entity.c
+++ b/drivers/gpu/drm/scheduler/sched_entity.c
@@ -167,7 +167,7 @@ long drm_sched_entity_flush(struct drm_sched_entity *entity, long timeout)
 	 * The client will not queue more IBs during this fini, consume existing
 	 * queued IBs or discard them on SIGKILL
 	 */
-	if (current->flags & PF_EXITING) {
+	if (sysiso_current->flags & PF_EXITING) {
 		if (timeout)
 			ret = wait_event_timeout(
 					sched->job_scheduled,
@@ -181,7 +181,7 @@ long drm_sched_entity_flush(struct drm_sched_entity *entity, long timeout)
 	/* For killed process disable any more IBs enqueue right now */
 	last_user = cmpxchg(&entity->last_user, current->group_leader, NULL);
 	if ((!last_user || last_user == current->group_leader) &&
-	    (current->flags & PF_EXITING) && (current->exit_code == SIGKILL)) {
+	    (sysiso_current->flags & PF_EXITING) && (current->exit_code == SIGKILL)) {
 		spin_lock(&entity->rq_lock);
 		entity->stopped = true;
 		drm_sched_rq_remove_entity(entity->rq, entity);
diff --git a/drivers/gpu/drm/tegra/submit.c b/drivers/gpu/drm/tegra/submit.c
index 776f825df..1f55dc891 100644
--- a/drivers/gpu/drm/tegra/submit.c
+++ b/drivers/gpu/drm/tegra/submit.c
@@ -26,7 +26,7 @@
 #define SUBMIT_ERR(context, fmt, ...) \
 	dev_err_ratelimited(context->client->base.dev, \
 		"%s: job submission failed: " fmt "\n", \
-		current->comm, ##__VA_ARGS__)
+		sysiso_current->comm, ##__VA_ARGS__)
 
 struct gather_bo {
 	struct host1x_bo base;
@@ -498,7 +498,7 @@ int tegra_drm_ioctl_channel_submit(struct drm_device *drm, void *data,
 	if (!context) {
 		mutex_unlock(&fpriv->lock);
 		pr_err_ratelimited("%s: %s: invalid channel context '%#x'", __func__,
-				   current->comm, args->context);
+				   sysiso_current->comm, args->context);
 		return -EINVAL;
 	}
 
diff --git a/drivers/gpu/drm/tegra/uapi.c b/drivers/gpu/drm/tegra/uapi.c
index 690a339c5..464d279b5 100644
--- a/drivers/gpu/drm/tegra/uapi.c
+++ b/drivers/gpu/drm/tegra/uapi.c
@@ -285,7 +285,7 @@ int tegra_drm_ioctl_syncpoint_allocate(struct drm_device *drm, void *data, struc
 	if (args->id)
 		return -EINVAL;
 
-	sp = host1x_syncpt_alloc(host1x, HOST1X_SYNCPT_CLIENT_MANAGED, current->comm);
+	sp = host1x_syncpt_alloc(host1x, HOST1X_SYNCPT_CLIENT_MANAGED, sysiso_current->comm);
 	if (!sp)
 		return -EBUSY;
 
diff --git a/drivers/gpu/drm/vc4/vc4_gem.c b/drivers/gpu/drm/vc4/vc4_gem.c
index 445d3bab8..559cb468b 100644
--- a/drivers/gpu/drm/vc4/vc4_gem.c
+++ b/drivers/gpu/drm/vc4/vc4_gem.c
@@ -400,7 +400,7 @@ vc4_wait_for_seqno(struct drm_device *dev, uint64_t seqno, uint64_t timeout_ns,
 				interruptible ? TASK_INTERRUPTIBLE :
 				TASK_UNINTERRUPTIBLE);
 
-		if (interruptible && signal_pending(current)) {
+		if (interruptible && signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/via/via_drv.h b/drivers/gpu/drm/via/via_drv.h
index d5ad1b05b..d8a4e59f0 100644
--- a/drivers/gpu/drm/via/via_drv.h
+++ b/drivers/gpu/drm/via/via_drv.h
@@ -174,7 +174,7 @@ do {								\
 			break;					\
 		}						\
 		schedule_timeout((HZ/100 > 1) ? HZ/100 : 1);	\
-		if (signal_pending(current)) {			\
+		if (signal_pending(sysiso_current)) {			\
 			ret = -EINTR;				\
 			break;					\
 		}						\
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_cmd.c b/drivers/gpu/drm/vmwgfx/vmwgfx_cmd.c
index 67db472d3..d64541b0e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_cmd.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_cmd.c
@@ -208,7 +208,7 @@ static int vmw_fifo_wait_noirq(struct vmw_private *dev_priv,
 			break;
 		}
 		schedule_timeout(1);
-		if (interruptible && signal_pending(current)) {
+		if (interruptible && signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
index 9fe12329a..b169add9f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
@@ -182,7 +182,7 @@ static long vmw_fence_wait(struct dma_fence *f, bool intr, signed long timeout)
 	if (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &f->flags))
 		goto out;
 
-	if (intr && signal_pending(current)) {
+	if (intr && signal_pending(sysiso_current)) {
 		ret = -ERESTARTSYS;
 		goto out;
 	}
@@ -210,7 +210,7 @@ static long vmw_fence_wait(struct dma_fence *f, bool intr, signed long timeout)
 			break;
 		}
 
-		if (intr && signal_pending(current)) {
+		if (intr && signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c b/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c
index c5191de36..293212b26 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c
@@ -212,7 +212,7 @@ int vmw_fallback_wait(struct vmw_private *dev_priv,
 					    TASK_INTERRUPTIBLE :
 					    TASK_UNINTERRUPTIBLE);
 		}
-		if (interruptible && signal_pending(current)) {
+		if (interruptible && signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_mksstat.h b/drivers/gpu/drm/vmwgfx/vmwgfx_mksstat.h
index 0509f55f0..7063998b6 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_mksstat.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_mksstat.h
@@ -111,10 +111,10 @@ struct mksstat_timer_t {
 #define MKS_STAT_TIME_POP(kern_cntr)                                                                                                           \
 	do {                                                                                                                                   \
 		if (_##kern_cntr.slot >= 0) {                                                                                                  \
-			const pid_t pid = atomic_cmpxchg(&dev_priv->mksstat_kern_pids[_##kern_cntr.slot], current->pid, MKSSTAT_PID_RESERVED); \
+			const pid_t pid = atomic_cmpxchg(&dev_priv->mksstat_kern_pids[_##kern_cntr.slot], sysiso_current->pid, MKSSTAT_PID_RESERVED); \
 			dev_priv->mksstat_kern_top_timer[_##kern_cntr.slot] = _##kern_cntr.old_top;                                            \
 			                                                                                                                       \
-			if (pid == current->pid) {                                                                                             \
+			if (pid == sysiso_current->pid) {                                                                                             \
 				const u64 dt = rdtsc() - _##kern_cntr.t0;                                                                      \
 				MKSGuestStatCounterTime *pstat;                                                                                \
 				                                                                                                               \
@@ -129,7 +129,7 @@ struct mksstat_timer_t {
 				if (_##kern_cntr.old_top != MKSSTAT_KERN_COUNT)                                                                \
 					atomic64_sub(dt, &pstat[_##kern_cntr.old_top].selfCycles);                                             \
 					                                                                                                       \
-				atomic_set(&dev_priv->mksstat_kern_pids[_##kern_cntr.slot], current->pid);                                     \
+				atomic_set(&dev_priv->mksstat_kern_pids[_##kern_cntr.slot], sysiso_current->pid);                                     \
 			}                                                                                                                      \
 		}                                                                                                                              \
 	} while (0)
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_msg.c b/drivers/gpu/drm/vmwgfx/vmwgfx_msg.c
index e50fb82a3..829b1491a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_msg.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_msg.c
@@ -799,7 +799,7 @@ static int mksstat_init_kern_id(struct page **ppage)
 	pdesc->infoLength = sizeof(*pinfo) * MKSSTAT_KERN_COUNT;
 	pdesc->strsLength = pstrs_acc - pstrs;
 	snprintf(pdesc->description, ARRAY_SIZE(pdesc->description) - 1, "%s pid=%d",
-		MKSSTAT_KERNEL_DESCRIPTION, current->pid);
+		MKSSTAT_KERNEL_DESCRIPTION, sysiso_current->pid);
 
 	pdesc->statPPNs[0] = page_to_pfn(virt_to_page(pstat));
 	reset_ppn_array(pdesc->statPPNs + 1, ARRAY_SIZE(pdesc->statPPNs) - 1);
@@ -1111,11 +1111,14 @@ int vmw_mksstat_add_ioctl(struct drm_device *dev, void *data,
 	hypervisor_ppn_add((PPN64)page_to_pfn(page));
 
 	dev_priv->mksstat_user_pages[slot] = page;
-	atomic_set(&dev_priv->mksstat_user_pids[slot], task_pgrp_vnr(current));
+	atomic_set(&dev_priv->mksstat_user_pids[slot],
+		   task_pgrp_vnr(sysiso_current));
 
 	arg->id = slot;
 
-	DRM_DEV_INFO(dev->dev, "pid=%d arg.description='%.*s' id=%zu\n", current->pid, (int)desc_len, pdesc->description, slot);
+	DRM_DEV_INFO(dev->dev, "pid=%d arg.description='%.*s' id=%zu\n",
+		     sysiso_current->pid, (int)desc_len, pdesc->description,
+		     slot);
 
 	return 0;
 
@@ -1163,9 +1166,10 @@ int vmw_mksstat_remove_ioctl(struct drm_device *dev, void *data,
 	if (slot >= ARRAY_SIZE(dev_priv->mksstat_user_pids))
 		return -EINVAL;
 
-	DRM_DEV_INFO(dev->dev, "pid=%d arg.id=%zu\n", current->pid, slot);
+	DRM_DEV_INFO(dev->dev, "pid=%d arg.id=%zu\n", sysiso_current->pid,
+		     slot);
 
-	pgid = task_pgrp_vnr(current);
+	pgid = task_pgrp_vnr(sysiso_current);
 	pid = atomic_cmpxchg(&dev_priv->mksstat_user_pids[slot], pgid, MKSSTAT_PID_RESERVED);
 
 	if (!pid)
diff --git a/drivers/gpu/host1x/syncpt.c b/drivers/gpu/host1x/syncpt.c
index d198a1084..fec99b825 100644
--- a/drivers/gpu/host1x/syncpt.c
+++ b/drivers/gpu/host1x/syncpt.c
@@ -298,7 +298,7 @@ int host1x_syncpt_wait(struct host1x_syncpt *sp, u32 thresh, long timeout,
 		if (timeout && check_count <= MAX_STUCK_CHECK_COUNT) {
 			dev_warn(sp->host->dev,
 				"%s: syncpoint id %u (%s) stuck waiting %d, timeout=%ld\n",
-				 current->comm, sp->id, sp->name,
+				 sysiso_current->comm, sp->id, sp->name,
 				 thresh, timeout);
 
 			host1x_debug_dump_syncpts(sp->host);
diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c
index 569930552..8066cfb54 100644
--- a/drivers/gpu/vga/vgaarb.c
+++ b/drivers/gpu/vga/vgaarb.c
@@ -481,7 +481,7 @@ int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
-		if (interruptible && signal_pending(current)) {
+		if (interruptible && signal_pending(sysiso_current)) {
 			__set_current_state(TASK_RUNNING);
 			remove_wait_queue(&vga_wait_queue, &wait);
 			rc = -ERESTARTSYS;
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index dbed2524f..758a25074 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -1374,7 +1374,7 @@ u32 hid_field_extract(const struct hid_device *hid, u8 *report,
 {
 	if (n > 32) {
 		hid_warn_once(hid, "%s() called with n (%d) > 32! (%s)\n",
-			      __func__, n, current->comm);
+			      __func__, n, sysiso_current->comm);
 		n = 32;
 	}
 
@@ -1420,7 +1420,7 @@ static void implement(const struct hid_device *hid, u8 *report,
 {
 	if (unlikely(n > 32)) {
 		hid_warn(hid, "%s() called with n (%d) > 32! (%s)\n",
-			 __func__, n, current->comm);
+			 __func__, n, sysiso_current->comm);
 		n = 32;
 	} else if (n < 32) {
 		u32 m = (1U << n) - 1;
@@ -1428,7 +1428,7 @@ static void implement(const struct hid_device *hid, u8 *report,
 		if (unlikely(value > m)) {
 			hid_warn(hid,
 				 "%s() called with too large value %d (n: %d)! (%s)\n",
-				 __func__, value, n, current->comm);
+				 __func__, value, n, sysiso_current->comm);
 			WARN_ON(1);
 			value &= m;
 		}
diff --git a/drivers/hid/hid-debug.c b/drivers/hid/hid-debug.c
index fa57d05ba..4e95e1df7 100644
--- a/drivers/hid/hid-debug.c
+++ b/drivers/hid/hid-debug.c
@@ -1116,7 +1116,7 @@ static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,
 		set_current_state(TASK_INTERRUPTIBLE);
 
 		while (kfifo_is_empty(&list->hid_debug_fifo)) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				ret = -ERESTARTSYS;
 				break;
 			}
diff --git a/drivers/hid/hid-roccat.c b/drivers/hid/hid-roccat.c
index 26373b82f..7241e1444 100644
--- a/drivers/hid/hid-roccat.c
+++ b/drivers/hid/hid-roccat.c
@@ -92,7 +92,7 @@ static ssize_t roccat_read(struct file *file, char __user *buffer,
 				retval = -EAGAIN;
 				break;
 			}
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				retval = -ERESTARTSYS;
 				break;
 			}
diff --git a/drivers/hid/hidraw.c b/drivers/hid/hidraw.c
index 79faac87a..2eb711cf5 100644
--- a/drivers/hid/hidraw.c
+++ b/drivers/hid/hidraw.c
@@ -50,7 +50,7 @@ static ssize_t hidraw_read(struct file *file, char __user *buffer, size_t count,
 			set_current_state(TASK_INTERRUPTIBLE);
 
 			while (list->head == list->tail) {
-				if (signal_pending(current)) {
+				if (signal_pending(sysiso_current)) {
 					ret = -ERESTARTSYS;
 					break;
 				}
@@ -118,14 +118,14 @@ static ssize_t hidraw_send_report(struct file *file, const char __user *buffer,
 
 	if (count > HID_MAX_BUFFER_SIZE) {
 		hid_warn(dev, "pid %d passed too large report\n",
-			 task_pid_nr(current));
+			 task_pid_nr(sysiso_current));
 		ret = -EINVAL;
 		goto out;
 	}
 
 	if (count < 2) {
 		hid_warn(dev, "pid %d passed too short report\n",
-			 task_pid_nr(current));
+			 task_pid_nr(sysiso_current));
 		ret = -EINVAL;
 		goto out;
 	}
@@ -198,14 +198,14 @@ static ssize_t hidraw_get_report(struct file *file, char __user *buffer, size_t
 
 	if (count > HID_MAX_BUFFER_SIZE) {
 		hid_warn(dev, "pid %d passed too large report\n",
-			task_pid_nr(current));
+			task_pid_nr(sysiso_current));
 		ret = -EINVAL;
 		goto out;
 	}
 
 	if (count < 2) {
 		hid_warn(dev, "pid %d passed too short report\n",
-			task_pid_nr(current));
+			task_pid_nr(sysiso_current));
 		ret = -EINVAL;
 		goto out;
 	}
diff --git a/drivers/hid/uhid.c b/drivers/hid/uhid.c
index 8fe3efcb8..e32b6a159 100644
--- a/drivers/hid/uhid.c
+++ b/drivers/hid/uhid.c
@@ -728,7 +728,8 @@ static ssize_t uhid_char_write(struct file *file, const char __user *buffer,
 		 */
 		if (file->f_cred != current_cred() || uaccess_kernel()) {
 			pr_err_once("UHID_CREATE from different security context by process %d (%s), this is not allowed.\n",
-				    task_tgid_vnr(current), current->comm);
+				    task_tgid_vnr(sysiso_current),
+				    sysiso_current->comm);
 			ret = -EACCES;
 			goto unlock;
 		}
diff --git a/drivers/hid/usbhid/hiddev.c b/drivers/hid/usbhid/hiddev.c
index 2fb2991db..9acdef3c6 100644
--- a/drivers/hid/usbhid/hiddev.c
+++ b/drivers/hid/usbhid/hiddev.c
@@ -339,7 +339,7 @@ static ssize_t hiddev_read(struct file * file, char __user * buffer, size_t coun
 			prepare_to_wait(&list->hiddev->wait, &wait, TASK_INTERRUPTIBLE);
 
 			while (list->head == list->tail) {
-				if (signal_pending(current)) {
+				if (signal_pending(sysiso_current)) {
 					retval = -ERESTARTSYS;
 					break;
 				}
diff --git a/drivers/hsi/clients/cmt_speech.c b/drivers/hsi/clients/cmt_speech.c
index 89869c66f..ff5263a7c 100644
--- a/drivers/hsi/clients/cmt_speech.c
+++ b/drivers/hsi/clients/cmt_speech.c
@@ -846,7 +846,7 @@ static int cs_hsi_data_sync(struct cs_hsi_iface *hi)
 		DEFINE_WAIT(wait);
 		if (!cs_state_xfer_active(hi->data_state))
 			goto out;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			r = -ERESTARTSYS;
 			goto out;
 		}
@@ -1155,7 +1155,7 @@ static ssize_t cs_char_read(struct file *file, char __user *buf, size_t count,
 		if (file->f_flags & O_NONBLOCK) {
 			retval = -EAGAIN;
 			goto out;
-		} else if (signal_pending(current)) {
+		} else if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/hwtracing/coresight/coresight-etm3x-sysfs.c b/drivers/hwtracing/coresight/coresight-etm3x-sysfs.c
index e8c7649f1..ff0b5585d 100644
--- a/drivers/hwtracing/coresight/coresight-etm3x-sysfs.c
+++ b/drivers/hwtracing/coresight/coresight-etm3x-sysfs.c
@@ -1030,7 +1030,7 @@ static ssize_t ctxid_pid_show(struct device *dev,
 	 * Don't use contextID tracing if coming from a PID namespace.  See
 	 * comment in ctxid_pid_store().
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	spin_lock(&drvdata->spinlock);
@@ -1058,7 +1058,7 @@ static ssize_t ctxid_pid_store(struct device *dev,
 	 * As such refuse to use the feature if @current is not in the initial
 	 * PID namespace.
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	ret = kstrtoul(buf, 16, &pid);
@@ -1084,7 +1084,7 @@ static ssize_t ctxid_mask_show(struct device *dev,
 	 * Don't use contextID tracing if coming from a PID namespace.  See
 	 * comment in ctxid_pid_store().
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	val = config->ctxid_mask;
@@ -1104,7 +1104,7 @@ static ssize_t ctxid_mask_store(struct device *dev,
 	 * Don't use contextID tracing if coming from a PID namespace.  See
 	 * comment in ctxid_pid_store().
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	ret = kstrtoul(buf, 16, &val);
diff --git a/drivers/hwtracing/coresight/coresight-etm4x-sysfs.c b/drivers/hwtracing/coresight/coresight-etm4x-sysfs.c
index a0640fa5c..326564e44 100644
--- a/drivers/hwtracing/coresight/coresight-etm4x-sysfs.c
+++ b/drivers/hwtracing/coresight/coresight-etm4x-sysfs.c
@@ -1890,7 +1890,7 @@ static ssize_t ctxid_pid_show(struct device *dev,
 	 * Don't use contextID tracing if coming from a PID namespace.  See
 	 * comment in ctxid_pid_store().
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	spin_lock(&drvdata->spinlock);
@@ -1918,7 +1918,7 @@ static ssize_t ctxid_pid_store(struct device *dev,
 	 * As such refuse to use the feature if @current is not in the initial
 	 * PID namespace.
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	/*
@@ -1951,7 +1951,7 @@ static ssize_t ctxid_masks_show(struct device *dev,
 	 * Don't use contextID tracing if coming from a PID namespace.  See
 	 * comment in ctxid_pid_store().
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	spin_lock(&drvdata->spinlock);
@@ -1975,7 +1975,7 @@ static ssize_t ctxid_masks_store(struct device *dev,
 	 * Don't use contextID tracing if coming from a PID namespace.  See
 	 * comment in ctxid_pid_store().
 	 */
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	/*
diff --git a/drivers/hwtracing/stm/core.c b/drivers/hwtracing/stm/core.c
index 2712e699b..51c3a9938 100644
--- a/drivers/hwtracing/stm/core.c
+++ b/drivers/hwtracing/stm/core.c
@@ -631,7 +631,7 @@ static ssize_t stm_char_write(struct file *file, const char __user *buf,
 	 * point, try to use the task name and "default" policy entries.
 	 */
 	if (!stmf->output.nr_chans) {
-		char comm[sizeof(current->comm)];
+		char comm[sizeof(sysiso_current->comm)];
 		char *ids[] = { comm, "default", NULL };
 
 		get_task_comm(comm, current);
diff --git a/drivers/i2c/busses/i2c-ibm_iic.c b/drivers/i2c/busses/i2c-ibm_iic.c
index 9f71daf6d..2c07881b4 100644
--- a/drivers/i2c/busses/i2c-ibm_iic.c
+++ b/drivers/i2c/busses/i2c-ibm_iic.c
@@ -432,7 +432,7 @@ static int iic_wait_for_tc(struct ibm_iic_private* dev){
 				break;
 			}
 
-			if (signal_pending(current)){
+			if (signal_pending(sysiso_current)){
 				DBG("%d: poll interrupted\n", dev->idx);
 				ret = -ERESTARTSYS;
 				break;
diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c
index a95cc2da5..b1c89719f 100644
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@ -142,7 +142,7 @@ static ssize_t iio_buffer_read(struct file *filp, char __user *buf,
 		}
 
 		if (!iio_buffer_ready(indio_dev, rb, to_wait, n / datum_size)) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				ret = -ERESTARTSYS;
 				break;
 			}
diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c
index 704ce5955..e703d1e58 100644
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@ -890,7 +890,8 @@ struct rdma_cm_id *rdma_create_user_id(rdma_cm_event_handler event_handler,
 {
 	struct rdma_id_private *ret;
 
-	ret = __rdma_create_id(current->nsproxy->net_ns, event_handler, context,
+	ret = __rdma_create_id(sysiso_current->nsproxy->net_ns, event_handler,
+			       context,
 			       ps, qp_type, NULL);
 	if (IS_ERR(ret))
 		return ERR_CAST(ret);
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index f4814bb7f..b5de36ca2 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -1705,7 +1705,7 @@ int ib_device_set_netns_put(struct sk_buff *skb,
 
 	get_device(&dev->dev);
 	ib_device_put(dev);
-	ret = rdma_dev_change_netns(dev, current->nsproxy->net_ns, net);
+	ret = rdma_dev_change_netns(dev, sysiso_current->nsproxy->net_ns, net);
 	put_device(&dev->dev);
 
 	put_net(net);
diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c
index 2b72c4fa9..a1a6ec60f 100644
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -1709,7 +1709,8 @@ static ssize_t ucma_write(struct file *filp, const char __user *buf,
 
 	if (!ib_safe_file_access(filp)) {
 		pr_err_once("%s: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\n",
-			    __func__, task_tgid_vnr(current), current->comm);
+			    __func__, task_tgid_vnr(sysiso_current),
+			    sysiso_current->comm);
 		return -EACCES;
 	}
 
diff --git a/drivers/infiniband/core/user_mad.c b/drivers/infiniband/core/user_mad.c
index 98cb594cd..861452aa4 100644
--- a/drivers/infiniband/core/user_mad.c
+++ b/drivers/infiniband/core/user_mad.c
@@ -757,7 +757,7 @@ static int ib_umad_reg_agent(struct ib_umad_file *file, void __user *arg,
 		if (!file->use_pkey_index) {
 			dev_warn(&file->port->dev,
 				"process %s did not enable P_Key index support.\n",
-				current->comm);
+				sysiso_current->comm);
 			dev_warn(&file->port->dev,
 				"   Documentation/infiniband/user_mad.rst has info on the new ABI.\n");
 		}
@@ -995,7 +995,7 @@ static int ib_umad_open(struct inode *inode, struct file *filp)
 		goto out;
 	}
 
-	if (!rdma_dev_access_netns(port->ib_dev, current->nsproxy->net_ns)) {
+	if (!rdma_dev_access_netns(port->ib_dev, sysiso_current->nsproxy->net_ns)) {
 		ret = -EPERM;
 		goto out;
 	}
@@ -1093,7 +1093,7 @@ static int ib_umad_sm_open(struct inode *inode, struct file *filp)
 		}
 	}
 
-	if (!rdma_dev_access_netns(port->ib_dev, current->nsproxy->net_ns)) {
+	if (!rdma_dev_access_netns(port->ib_dev, sysiso_current->nsproxy->net_ns)) {
 		ret = -EPERM;
 		goto err_up_sem;
 	}
diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c
index d54434088..8dbd94ad4 100644
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@ -572,7 +572,7 @@ static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,
 
 	if (!ib_safe_file_access(filp)) {
 		pr_err_once("uverbs_write: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\n",
-			    task_tgid_vnr(current), current->comm);
+			    task_tgid_vnr(sysiso_current), sysiso_current->comm);
 		return -EACCES;
 	}
 
@@ -904,7 +904,7 @@ static int ib_uverbs_open(struct inode *inode, struct file *filp)
 		goto err;
 	}
 
-	if (!rdma_dev_access_netns(ib_dev, current->nsproxy->net_ns)) {
+	if (!rdma_dev_access_netns(ib_dev, sysiso_current->nsproxy->net_ns)) {
 		ret = -EPERM;
 		goto err;
 	}
diff --git a/drivers/infiniband/hw/hfi1/affinity.c b/drivers/infiniband/hw/hfi1/affinity.c
index 98c813ba4..3ed07985f 100644
--- a/drivers/infiniband/hw/hfi1/affinity.c
+++ b/drivers/infiniband/hw/hfi1/affinity.c
@@ -1008,7 +1008,7 @@ int hfi1_get_proc_affinity(int node)
 	 */
 	if (current->nr_cpus_allowed == 1) {
 		hfi1_cdbg(PROC, "PID %u %s affinity set to CPU %*pbl",
-			  current->pid, current->comm,
+			  sysiso_current->pid, sysiso_current->comm,
 			  cpumask_pr_args(proc_mask));
 		/*
 		 * Mark the pre-set CPU as used. This is atomic so we don't
@@ -1019,7 +1019,7 @@ int hfi1_get_proc_affinity(int node)
 		goto done;
 	} else if (current->nr_cpus_allowed < cpumask_weight(&set->mask)) {
 		hfi1_cdbg(PROC, "PID %u %s affinity set to CPU set(s) %*pbl",
-			  current->pid, current->comm,
+			  sysiso_current->pid, sysiso_current->comm,
 			  cpumask_pr_args(proc_mask));
 		goto done;
 	}
diff --git a/drivers/infiniband/hw/hfi1/file_ops.c b/drivers/infiniband/hw/hfi1/file_ops.c
index 1783a6ea5..8d67355d1 100644
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@ -931,7 +931,8 @@ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
 		return ret;
 	}
 	hfi1_cdbg(PROC, "[%u:%u] pid %u assigned to CPU %d (NUMA %u)",
-		  uctxt->ctxt, fd->subctxt, current->pid, fd->rec_cpu_num,
+		  uctxt->ctxt, fd->subctxt, sysiso_current->pid,
+		  fd->rec_cpu_num,
 		  uctxt->numa_id);
 
 	/*
@@ -963,7 +964,7 @@ static int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,
 	uctxt->userversion = uinfo->userversion;
 	uctxt->flags = hfi1_cap_mask; /* save current flag state */
 	init_waitqueue_head(&uctxt->wait);
-	strlcpy(uctxt->comm, current->comm, sizeof(uctxt->comm));
+	strlcpy(uctxt->comm, sysiso_current->comm, sizeof(uctxt->comm));
 	memcpy(uctxt->uuid, uinfo->uuid, sizeof(uctxt->uuid));
 	uctxt->jkey = generate_jkey(current_uid());
 	hfi1_stats.sps_ctxts++;
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index bf20a388e..bf91786fe 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -28,15 +28,15 @@
 
 #define mlx5_ib_dbg(_dev, format, arg...)                                      \
 	dev_dbg(&(_dev)->ib_dev.dev, "%s:%d:(pid %d): " format, __func__,      \
-		__LINE__, current->pid, ##arg)
+		__LINE__, sysiso_current->pid, ##arg)
 
 #define mlx5_ib_err(_dev, format, arg...)                                      \
 	dev_err(&(_dev)->ib_dev.dev, "%s:%d:(pid %d): " format, __func__,      \
-		__LINE__, current->pid, ##arg)
+		__LINE__, sysiso_current->pid, ##arg)
 
 #define mlx5_ib_warn(_dev, format, arg...)                                     \
 	dev_warn(&(_dev)->ib_dev.dev, "%s:%d:(pid %d): " format, __func__,     \
-		 __LINE__, current->pid, ##arg)
+		 __LINE__, sysiso_current->pid, ##arg)
 
 #define MLX5_IB_DEFAULT_UIDX 0xffffff
 #define MLX5_USER_ASSIGNED_UIDX_MASK __mlx5_mask(qpc, user_index)
diff --git a/drivers/infiniband/hw/mlx5/qpc.c b/drivers/infiniband/hw/mlx5/qpc.c
index 8844eacf2..818b7000b 100644
--- a/drivers/infiniband/hw/mlx5/qpc.c
+++ b/drivers/infiniband/hw/mlx5/qpc.c
@@ -167,7 +167,7 @@ static int create_resource_common(struct mlx5_ib_dev *dev,
 
 	refcount_set(&qp->common.refcount, 1);
 	init_completion(&qp->common.free);
-	qp->pid = current->pid;
+	qp->pid = sysiso_current->pid;
 
 	return 0;
 }
diff --git a/drivers/infiniband/hw/mthca/mthca_provider.c b/drivers/infiniband/hw/mthca/mthca_provider.c
index ceee23ebc..0d0e7b026 100644
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@ -848,7 +848,7 @@ static struct ib_mr *mthca_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,
 	if (udata->inlen < sizeof ucmd) {
 		if (!context->reg_mr_warned) {
 			mthca_warn(dev, "Process '%s' did not pass in MR attrs.\n",
-				   current->comm);
+				   sysiso_current->comm);
 			mthca_warn(dev, "  Update libmthca to fix this.\n");
 		}
 		++context->reg_mr_warned;
diff --git a/drivers/infiniband/hw/qib/qib_diag.c b/drivers/infiniband/hw/qib/qib_diag.c
index 11da796dd..b1b397a50 100644
--- a/drivers/infiniband/hw/qib/qib_diag.c
+++ b/drivers/infiniband/hw/qib/qib_diag.c
@@ -90,7 +90,7 @@ static struct qib_diag_client *get_client(struct qib_devdata *dd)
 	if (dc) {
 		dc->next = NULL;
 		dc->dd = dd;
-		dc->pid = current->pid;
+		dc->pid = sysiso_current->pid;
 		dc->state = OPENED;
 	}
 	return dc;
@@ -763,7 +763,7 @@ static ssize_t qib_diag_read(struct file *fp, char __user *data,
 	struct qib_devdata *dd = dc->dd;
 	ssize_t ret;
 
-	if (dc->pid != current->pid) {
+	if (dc->pid != sysiso_current->pid) {
 		ret = -EPERM;
 		goto bail;
 	}
@@ -837,7 +837,7 @@ static ssize_t qib_diag_write(struct file *fp, const char __user *data,
 	struct qib_devdata *dd = dc->dd;
 	ssize_t ret;
 
-	if (dc->pid != current->pid) {
+	if (dc->pid != sysiso_current->pid) {
 		ret = -EPERM;
 		goto bail;
 	}
diff --git a/drivers/infiniband/hw/qib/qib_file_ops.c b/drivers/infiniband/hw/qib/qib_file_ops.c
index 63854f4b6..68312b3f2 100644
--- a/drivers/infiniband/hw/qib/qib_file_ops.c
+++ b/drivers/infiniband/hw/qib/qib_file_ops.c
@@ -1175,7 +1175,7 @@ static void assign_ctxt_affinity(struct file *fp, struct qib_devdata *dd)
 		if (cpu == qib_cpulist_count)
 			qib_dev_err(dd,
 			"no cpus avail for affinity PID %u\n",
-			current->pid);
+			sysiso_current->pid);
 		else {
 			__set_bit(cpu, qib_cpulist);
 			fd->rec_cpu_num = cpu;
@@ -1319,9 +1319,9 @@ static int setup_ctxt(struct qib_pportdata *ppd, int ctxt,
 	if (ret)
 		goto bailerr;
 	rcd->tid_pg_list = ptmp;
-	rcd->pid = current->pid;
+	rcd->pid = sysiso_current->pid;
 	init_waitqueue_head(&dd->rcd[ctxt]->wait);
-	strlcpy(rcd->comm, current->comm, sizeof(rcd->comm));
+	strlcpy(rcd->comm, sysiso_current->comm, sizeof(rcd->comm));
 	ctxt_fp(fp) = rcd;
 	qib_stats.sps_ctxts++;
 	dd->freectxts--;
@@ -1504,7 +1504,7 @@ static int find_shared_ctxt(struct file *fp,
 			}
 			ctxt_fp(fp) = rcd;
 			subctxt_fp(fp) = rcd->cnt++;
-			rcd->subpid[subctxt_fp(fp)] = current->pid;
+			rcd->subpid[subctxt_fp(fp)] = sysiso_current->pid;
 			tidcursor_fp(fp) = 0;
 			rcd->active_slaves |= 1 << subctxt_fp(fp);
 			ret = 1;
@@ -2044,7 +2044,7 @@ static ssize_t qib_write(struct file *fp, const char __user *data,
 
 	if (!ib_safe_file_access(fp)) {
 		pr_err_once("qib_write: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\n",
-			    task_tgid_vnr(current), current->comm);
+			    task_tgid_vnr(current), sysiso_current->comm);
 		return -EACCES;
 	}
 
diff --git a/drivers/infiniband/hw/qib/qib_user_sdma.c b/drivers/infiniband/hw/qib/qib_user_sdma.c
index ac11943a5..89e299d73 100644
--- a/drivers/infiniband/hw/qib/qib_user_sdma.c
+++ b/drivers/infiniband/hw/qib/qib_user_sdma.c
@@ -221,7 +221,7 @@ qib_user_sdma_queue_create(struct device *dev, int unit, int ctxt, int sctxt)
 	pq->dma_pages_root = RB_ROOT;
 
 	sdma_rb_node = qib_user_sdma_rb_search(&qib_user_sdma_rb_root,
-					current->pid);
+					sysiso_current->pid);
 	if (sdma_rb_node) {
 		sdma_rb_node->refcount++;
 	} else {
@@ -231,7 +231,7 @@ qib_user_sdma_queue_create(struct device *dev, int unit, int ctxt, int sctxt)
 			goto err_rb;
 
 		sdma_rb_node->refcount = 1;
-		sdma_rb_node->pid = current->pid;
+		sdma_rb_node->pid = sysiso_current->pid;
 
 		qib_user_sdma_rb_insert(&qib_user_sdma_rb_root, sdma_rb_node);
 	}
diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index 3b60fa9cb..2c660b88f 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -701,7 +701,7 @@ int usnic_ib_qp_grp_create(struct usnic_ib_qp_grp *qp_grp,
 	spin_lock_init(&qp_grp->lock);
 	qp_grp->ufdev = ufdev;
 	qp_grp->state = IB_QPS_RESET;
-	qp_grp->owner_pid = current->pid;
+	qp_grp->owner_pid = sysiso_current->pid;
 
 	qp_flow = create_and_add_flow(qp_grp, transport_spec);
 	if (IS_ERR_OR_NULL(qp_flow)) {
diff --git a/drivers/infiniband/sw/rdmavt/qp.c b/drivers/infiniband/sw/rdmavt/qp.c
index 3305f2744..125dc27aa 100644
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@ -1217,7 +1217,7 @@ int rvt_create_qp(struct ib_qp *ibqp, struct ib_qp_init_attr *init_attr,
 			if (ret)
 				goto bail_ip;
 		}
-		qp->pid = current->pid;
+		qp->pid = sysiso_current->pid;
 	}
 
 	spin_lock(&rdi->n_qps_lock);
diff --git a/drivers/infiniband/sw/siw/siw_cm.c b/drivers/infiniband/sw/siw/siw_cm.c
index 7a5ed86ff..3bd80893e 100644
--- a/drivers/infiniband/sw/siw/siw_cm.c
+++ b/drivers/infiniband/sw/siw/siw_cm.c
@@ -226,7 +226,7 @@ static void siw_cep_set_inuse(struct siw_cep *cep)
 	if (cep->in_use) {
 		spin_unlock_irqrestore(&cep->lock, flags);
 		wait_event_interruptible(cep->waitq, !cep->in_use);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			flush_signals(current);
 		goto retry;
 	} else {
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 0aa8629fd..5dea80342 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -2453,7 +2453,7 @@ static ssize_t dev_id_show(struct device *dev,
 	if (ndev->dev_port && ndev->dev_id == ndev->dev_port)
 		netdev_info_once(ndev,
 			"\"%s\" wants to know my dev_id. Should it look at dev_port instead? See Documentation/ABI/testing/sysfs-class-net for more info.\n",
-			current->comm);
+			sysiso_current->comm);
 
 	return sysfs_emit(buf, "%#x\n", ndev->dev_id);
 }
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 636d59076..acb3a8166 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -538,8 +538,8 @@ isert_release_kref(struct kref *kref)
 	struct isert_conn *isert_conn = container_of(kref,
 				struct isert_conn, kref);
 
-	isert_info("conn %p final kref %s/%d\n", isert_conn, current->comm,
-		   current->pid);
+	isert_info("conn %p final kref %s/%d\n", isert_conn, sysiso_current->comm,
+		   sysiso_current->pid);
 
 	isert_connect_release(isert_conn);
 }
diff --git a/drivers/irqchip/irq-gic-v4.c b/drivers/irqchip/irq-gic-v4.c
index 4ea71b28f..642300286 100644
--- a/drivers/irqchip/irq-gic-v4.c
+++ b/drivers/irqchip/irq-gic-v4.c
@@ -123,7 +123,8 @@ static int its_alloc_vcpu_sgis(struct its_vpe *vpe, int idx)
 	if (!has_v4_1_sgi())
 		return 0;
 
-	name = kasprintf(GFP_KERNEL, "GICv4-sgi-%d", task_pid_nr(current));
+	name = kasprintf(GFP_KERNEL, "GICv4-sgi-%d",
+			 task_pid_nr(sysiso_current));
 	if (!name)
 		goto err;
 
@@ -161,7 +162,7 @@ int its_alloc_vcpu_irqs(struct its_vm *vm)
 	int vpe_base_irq, i;
 
 	vm->fwnode = irq_domain_alloc_named_id_fwnode("GICv4-vpe",
-						      task_pid_nr(current));
+						      task_pid_nr(sysiso_current));
 	if (!vm->fwnode)
 		goto err;
 
diff --git a/drivers/isdn/mISDN/l1oip_core.c b/drivers/isdn/mISDN/l1oip_core.c
index 2c4041246..5b9187429 100644
--- a/drivers/isdn/mISDN/l1oip_core.c
+++ b/drivers/isdn/mISDN/l1oip_core.c
@@ -703,7 +703,7 @@ l1oip_socket_thread(void *data)
 	if (debug & DEBUG_L1OIP_SOCKET)
 		printk(KERN_DEBUG "%s: socket created and open\n",
 		       __func__);
-	while (!signal_pending(current)) {
+	while (!signal_pending(sysiso_current)) {
 		iov_iter_kvec(&msg.msg_iter, READ, &iov, 1, recvbuf_size);
 		recvlen = sock_recvmsg(socket, &msg, 0);
 		if (recvlen > 0) {
diff --git a/drivers/isdn/mISDN/stack.c b/drivers/isdn/mISDN/stack.c
index c2f76f398..3afe8f2cf 100644
--- a/drivers/isdn/mISDN/stack.c
+++ b/drivers/isdn/mISDN/stack.c
@@ -199,7 +199,7 @@ mISDNStackd(void *data)
 #endif
 	int err = 0;
 
-	sigfillset(&current->blocked);
+	sigfillset(&sysiso_current->blocked);
 	if (*debug & DEBUG_MSG_THREAD)
 		printk(KERN_DEBUG "mISDNStackd %s started\n",
 		       dev_name(&st->dev->dev));
diff --git a/drivers/isdn/mISDN/timerdev.c b/drivers/isdn/mISDN/timerdev.c
index abdf36ac3..851c367fb 100644
--- a/drivers/isdn/mISDN/timerdev.c
+++ b/drivers/isdn/mISDN/timerdev.c
@@ -111,7 +111,7 @@ mISDN_read(struct file *filep, char __user *buf, size_t count, loff_t *off)
 			return -EAGAIN;
 		wait_event_interruptible(dev->wait, (dev->work ||
 						     !list_empty(list)));
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&dev->lock);
 	}
diff --git a/drivers/macintosh/adb.c b/drivers/macintosh/adb.c
index 73b396189..500bfe671 100644
--- a/drivers/macintosh/adb.c
+++ b/drivers/macintosh/adb.c
@@ -743,7 +743,7 @@ static ssize_t adb_read(struct file *file, char __user *buf,
 			ret = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/macintosh/smu.c b/drivers/macintosh/smu.c
index fe63d5ee2..35b90877d 100644
--- a/drivers/macintosh/smu.c
+++ b/drivers/macintosh/smu.c
@@ -1194,7 +1194,7 @@ static ssize_t smu_read_command(struct file *file, struct smu_private *pp,
 			if (pp->cmd.status != 1)
 				break;
 			rc = -ERESTARTSYS;
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				break;
 			spin_unlock_irqrestore(&pp->lock, flags);
 			schedule();
diff --git a/drivers/macintosh/via-pmu.c b/drivers/macintosh/via-pmu.c
index 4b98bc26a..d72cdd6a6 100644
--- a/drivers/macintosh/via-pmu.c
+++ b/drivers/macintosh/via-pmu.c
@@ -2210,7 +2210,7 @@ pmu_read(struct file *file, char __user *buf,
 		if (file->f_flags & O_NONBLOCK)
 			break;
 		ret = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		spin_unlock_irqrestore(&pp->lock, flags);
 		schedule();
diff --git a/drivers/mailbox/mailbox-test.c b/drivers/mailbox/mailbox-test.c
index 4555d678f..abe643542 100644
--- a/drivers/mailbox/mailbox-test.c
+++ b/drivers/mailbox/mailbox-test.c
@@ -194,7 +194,7 @@ static ssize_t mbox_test_message_read(struct file *filp, char __user *userbuf,
 			goto waitq_err;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			goto waitq_err;
 		}
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index 76d9da49f..4232c4b2a 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -428,7 +428,7 @@ static int dm_prepare_ioctl(struct mapped_device *md, int *srcu_idx,
 		return -EAGAIN;
 
 	r = tgt->type->prepare_ioctl(tgt, bdev);
-	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
+	if (r == -ENOTCONN && !fatal_signal_pending(sysiso_current)) {
 		dm_put_live_table(md, *srcu_idx);
 		msleep(10);
 		goto retry;
@@ -460,7 +460,7 @@ static int dm_blk_ioctl(struct block_device *bdev, fmode_t mode,
 		if (!capable(CAP_SYS_RAWIO)) {
 			DMDEBUG_LIMIT(
 	"%s: sending ioctl %x to DM device without required privilege.",
-				current->comm, cmd);
+				sysiso_current->comm, cmd);
 			r = -ENOIOCTLCMD;
 			goto out;
 		}
@@ -2244,7 +2244,7 @@ static int dm_wait_for_bios_completion(struct mapped_device *md, unsigned int ta
 		if (!md_in_flight_bios(md))
 			break;
 
-		if (signal_pending_state(task_state, current)) {
+		if (signal_pending_state(task_state, sysiso_current)) {
 			r = -EINTR;
 			break;
 		}
@@ -2267,7 +2267,7 @@ static int dm_wait_for_completion(struct mapped_device *md, unsigned int task_st
 		if (!blk_mq_queue_inflight(md->queue))
 			break;
 
-		if (signal_pending_state(task_state, current)) {
+		if (signal_pending_state(task_state, sysiso_current)) {
 			r = -EINTR;
 			break;
 		}
diff --git a/drivers/md/md.c b/drivers/md/md.c
index 6c0c3d0d9..a98344819 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -7886,7 +7886,7 @@ static int md_thread(void *arg)
 		 * That means we need to be sure no signals are
 		 * pending
 		 */
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			flush_signals(current);
 
 		wait_event_interruptible_timeout
@@ -8763,7 +8763,7 @@ void md_do_sync(struct md_thread *thread)
 							mdname(mddev2));
 					}
 					mddev_put(mddev2);
-					if (signal_pending(current))
+					if (signal_pending(sysiso_current))
 						flush_signals(current);
 					schedule();
 					finish_wait(&resync_wait, &wq);
@@ -9233,7 +9233,7 @@ void md_check_recovery(struct mddev *mddev)
 	if (mddev->bitmap)
 		md_bitmap_daemon_work(mddev);
 
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		if (mddev->pers->sync_request && !mddev->external) {
 			pr_debug("md: %s in immediate safe mode\n",
 				 mdname(mddev));
diff --git a/drivers/media/common/saa7146/saa7146_vbi.c b/drivers/media/common/saa7146/saa7146_vbi.c
index bd442b984..6ada68a91 100644
--- a/drivers/media/common/saa7146/saa7146_vbi.c
+++ b/drivers/media/common/saa7146/saa7146_vbi.c
@@ -115,7 +115,7 @@ static int vbi_workaround(struct saa7146_dev *dev)
 		/* stop video-dma3 */
 		saa7146_write(dev, MC1, MASK_20);
 
-		if(signal_pending(current)) {
+		if(signal_pending(sysiso_current)) {
 
 			DEB_VBI("aborted (rps:0x%08x)\n",
 				saa7146_read(dev, RPS_ADDR1));
diff --git a/drivers/media/dvb-core/dvb_ca_en50221.c b/drivers/media/dvb-core/dvb_ca_en50221.c
index 15a08d8c6..806a5f2ff 100644
--- a/drivers/media/dvb-core/dvb_ca_en50221.c
+++ b/drivers/media/dvb-core/dvb_ca_en50221.c
@@ -1892,7 +1892,7 @@ int dvb_ca_en50221_init(struct dvb_adapter *dvb_adapter,
 
 	mutex_init(&ca->ioctl_mutex);
 
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		ret = -EINTR;
 		goto unregister_device;
 	}
diff --git a/drivers/media/dvb-core/dvb_demux.c b/drivers/media/dvb-core/dvb_demux.c
index 5fde1d38b..58765de2a 100644
--- a/drivers/media/dvb-core/dvb_demux.c
+++ b/drivers/media/dvb-core/dvb_demux.c
@@ -1165,7 +1165,7 @@ static int dvbdmx_write(struct dmx_demux *demux, const char __user *buf, size_t
 	kfree(p);
 	mutex_unlock(&dvbdemux->mutex);
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 	return count;
 }
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index 258637d76..a63b8d565 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -675,7 +675,7 @@ static int dvb_frontend_thread(void *data)
 		wait_event_interruptible_timeout(fepriv->wait_queue,
 						 dvb_frontend_should_wakeup(fe) ||
 						 kthread_should_stop() ||
-						 freezing(current),
+						 freezing(sysiso_current),
 			fepriv->delay);
 
 		if (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {
@@ -865,7 +865,7 @@ static int dvb_frontend_start(struct dvb_frontend *fe)
 			dvb_frontend_stop(fe);
 	}
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 	if (down_interruptible(&fepriv->sem))
 		return -EINTR;
@@ -2776,7 +2776,7 @@ static int dvb_frontend_open(struct inode *inode, struct file *file)
 			while (mferetry-- && (mfedev->users != -1 ||
 					      mfepriv->thread)) {
 				if (msleep_interruptible(500)) {
-					if (signal_pending(current))
+					if (signal_pending(sysiso_current))
 						return -EINTR;
 				}
 			}
diff --git a/drivers/media/pci/cx18/cx18-driver.c b/drivers/media/pci/cx18/cx18-driver.c
index f2440eb38..b79cfb77b 100644
--- a/drivers/media/pci/cx18/cx18-driver.c
+++ b/drivers/media/pci/cx18/cx18-driver.c
@@ -273,7 +273,7 @@ int cx18_msleep_timeout(unsigned int msecs, int intr)
 	do {
 		set_current_state(intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);
 		timeout = schedule_timeout(timeout);
-		sig = intr ? signal_pending(current) : 0;
+		sig = intr ? signal_pending(sysiso_current) : 0;
 	} while (!sig && timeout);
 	return sig;
 }
diff --git a/drivers/media/pci/cx18/cx18-fileops.c b/drivers/media/pci/cx18/cx18-fileops.c
index 4cf5b9ca9..eb0de4fc1 100644
--- a/drivers/media/pci/cx18/cx18-fileops.c
+++ b/drivers/media/pci/cx18/cx18-fileops.c
@@ -232,7 +232,7 @@ static struct cx18_mdl *cx18_get_mdl(struct cx18_stream *s, int non_block,
 		if (!atomic_read(&s->q_full.depth))
 			schedule();
 		finish_wait(&s->waitq, &wait);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			/* return if a signal was received */
 			CX18_DEBUG_INFO("User stopped %s\n", s->name);
 			*err = -EINTR;
diff --git a/drivers/media/pci/ivtv/ivtv-driver.c b/drivers/media/pci/ivtv/ivtv-driver.c
index 8ebc97ebf..a3dfdf7e5 100644
--- a/drivers/media/pci/ivtv/ivtv-driver.c
+++ b/drivers/media/pci/ivtv/ivtv-driver.c
@@ -350,7 +350,7 @@ int ivtv_waitq(wait_queue_head_t *waitq)
 	prepare_to_wait(waitq, &wait, TASK_INTERRUPTIBLE);
 	schedule();
 	finish_wait(waitq, &wait);
-	return signal_pending(current) ? -EINTR : 0;
+	return signal_pending(sysiso_current) ? -EINTR : 0;
 }
 
 /* Generic utility functions */
@@ -362,7 +362,7 @@ int ivtv_msleep_timeout(unsigned int msecs, int intr)
 		set_current_state(intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);
 		timeout = schedule_timeout(timeout);
 		if (intr) {
-			int ret = signal_pending(current);
+			int ret = signal_pending(sysiso_current);
 
 			if (ret)
 				return ret;
diff --git a/drivers/media/pci/ivtv/ivtv-fileops.c b/drivers/media/pci/ivtv/ivtv-fileops.c
index 4202c3a47..ef233b3b1 100644
--- a/drivers/media/pci/ivtv/ivtv-fileops.c
+++ b/drivers/media/pci/ivtv/ivtv-fileops.c
@@ -265,7 +265,7 @@ static struct ivtv_buffer *ivtv_get_buffer(struct ivtv_stream *s, int non_block,
 			schedule();
 		finish_wait(&s->waitq, &wait);
 		mutex_lock(&itv->serialize_lock);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			/* return if a signal was received */
 			IVTV_DEBUG_INFO("User stopped %s\n", s->name);
 			*err = -EINTR;
@@ -625,7 +625,7 @@ static ssize_t ivtv_write(struct file *filp, const char __user *user_buf, size_t
 			schedule();
 		finish_wait(&s->waitq, &wait);
 		mutex_lock(&itv->serialize_lock);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			IVTV_DEBUG_INFO("User stopped %s\n", s->name);
 			return -EINTR;
 		}
@@ -681,7 +681,7 @@ static ssize_t ivtv_write(struct file *filp, const char __user *user_buf, size_t
 
 			mutex_unlock(&itv->serialize_lock);
 			prepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);
-			while (!(got_sig = signal_pending(current)) &&
+			while (!(got_sig = signal_pending(sysiso_current)) &&
 					test_bit(IVTV_F_S_DMA_PENDING, &s->s_flags)) {
 				schedule();
 			}
diff --git a/drivers/media/pci/ivtv/ivtv-ioctl.c b/drivers/media/pci/ivtv/ivtv-ioctl.c
index da19b2e95..d99dc22cd 100644
--- a/drivers/media/pci/ivtv/ivtv-ioctl.c
+++ b/drivers/media/pci/ivtv/ivtv-ioctl.c
@@ -165,7 +165,7 @@ int ivtv_set_speed(struct ivtv *itv, int speed)
 		mutex_unlock(&itv->serialize_lock);
 		prepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);
 		while (test_bit(IVTV_F_I_DMA, &itv->i_flags)) {
-			got_sig = signal_pending(current);
+			got_sig = signal_pending(sysiso_current);
 			if (got_sig)
 				break;
 			got_sig = 0;
diff --git a/drivers/media/pci/ivtv/ivtv-yuv.c b/drivers/media/pci/ivtv/ivtv-yuv.c
index 5f7dc9771..6572a4647 100644
--- a/drivers/media/pci/ivtv/ivtv-yuv.c
+++ b/drivers/media/pci/ivtv/ivtv-yuv.c
@@ -1077,7 +1077,7 @@ static int ivtv_yuv_udma_frame(struct ivtv *itv, struct ivtv_dma_frame *args)
 	       test_bit(IVTV_F_I_UDMA, &itv->i_flags)) {
 		/* don't interrupt if the DMA is in progress but break off
 		   a still pending DMA. */
-		got_sig = signal_pending(current);
+		got_sig = signal_pending(sysiso_current);
 		if (got_sig && test_and_clear_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags))
 			break;
 		got_sig = 0;
diff --git a/drivers/media/pci/ivtv/ivtvfb.c b/drivers/media/pci/ivtv/ivtvfb.c
index e2d56dca5..50987f337 100644
--- a/drivers/media/pci/ivtv/ivtvfb.c
+++ b/drivers/media/pci/ivtv/ivtvfb.c
@@ -299,7 +299,7 @@ static int ivtvfb_prep_dec_dma_to_device(struct ivtv *itv,
 	       test_bit(IVTV_F_I_UDMA, &itv->i_flags)) {
 		/* don't interrupt if the DMA is in progress but break off
 		   a still pending DMA. */
-		got_sig = signal_pending(current);
+		got_sig = signal_pending(sysiso_current);
 		if (got_sig && test_and_clear_bit(IVTV_F_I_UDMA_PENDING, &itv->i_flags))
 			break;
 		got_sig = 0;
diff --git a/drivers/media/pci/pt1/pt1.c b/drivers/media/pci/pt1/pt1.c
index f2aa36814..0b2caf717 100644
--- a/drivers/media/pci/pt1/pt1.c
+++ b/drivers/media/pci/pt1/pt1.c
@@ -1112,7 +1112,7 @@ static int pt1_i2c_end(struct pt1 *pt1, int addr)
 
 	pt1_write_reg(pt1, 0, 0x00000004);
 	do {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 		usleep_range(1000, 2000);
 	} while (pt1_read_reg(pt1, 0) & 0x00000080);
diff --git a/drivers/media/pci/pt3/pt3.c b/drivers/media/pci/pt3/pt3.c
index c0bc86793..8d37c34ad 100644
--- a/drivers/media/pci/pt3/pt3.c
+++ b/drivers/media/pci/pt3/pt3.c
@@ -496,7 +496,7 @@ static int pt3_start_feed(struct dvb_demux_feed *feed)
 {
 	struct pt3_adapter *adap;
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	adap = container_of(feed->demux, struct pt3_adapter, demux);
diff --git a/drivers/media/pci/solo6x10/solo6x10-i2c.c b/drivers/media/pci/solo6x10/solo6x10-i2c.c
index 7db785e9c..f6398e403 100644
--- a/drivers/media/pci/solo6x10/solo6x10-i2c.c
+++ b/drivers/media/pci/solo6x10/solo6x10-i2c.c
@@ -243,7 +243,7 @@ static int solo_i2c_master_xfer(struct i2c_adapter *adap,
 		if (!timeout)
 			break;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 
diff --git a/drivers/media/platform/exynos-gsc/gsc-m2m.c b/drivers/media/platform/exynos-gsc/gsc-m2m.c
index f1cf847d1..bdd6f5ae7 100644
--- a/drivers/media/platform/exynos-gsc/gsc-m2m.c
+++ b/drivers/media/platform/exynos-gsc/gsc-m2m.c
@@ -614,7 +614,8 @@ static int gsc_m2m_open(struct file *file)
 	struct gsc_ctx *ctx = NULL;
 	int ret;
 
-	pr_debug("pid: %d, state: 0x%lx", task_pid_nr(current), gsc->state);
+	pr_debug("pid: %d, state: 0x%lx", task_pid_nr(sysiso_current),
+		 gsc->state);
 
 	if (mutex_lock_interruptible(&gsc->lock))
 		return -ERESTARTSYS;
@@ -677,7 +678,7 @@ static int gsc_m2m_release(struct file *file)
 	struct gsc_dev *gsc = ctx->gsc_dev;
 
 	pr_debug("pid: %d, state: 0x%lx, refcnt= %d",
-		task_pid_nr(current), gsc->state, gsc->m2m.refcnt);
+		task_pid_nr(sysiso_current), gsc->state, gsc->m2m.refcnt);
 
 	mutex_lock(&gsc->lock);
 
diff --git a/drivers/media/platform/exynos4-is/fimc-capture.c b/drivers/media/platform/exynos4-is/fimc-capture.c
index 7ff402400..c06545211 100644
--- a/drivers/media/platform/exynos4-is/fimc-capture.c
+++ b/drivers/media/platform/exynos4-is/fimc-capture.c
@@ -470,7 +470,7 @@ static int fimc_capture_open(struct file *file)
 	struct exynos_video_entity *ve = &vc->ve;
 	int ret = -EBUSY;
 
-	dbg("pid: %d, state: 0x%lx", task_pid_nr(current), fimc->state);
+	dbg("pid: %d, state: 0x%lx", task_pid_nr(sysiso_current), fimc->state);
 
 	mutex_lock(&fimc->lock);
 
@@ -519,7 +519,7 @@ static int fimc_capture_release(struct file *file)
 	bool close = v4l2_fh_is_singular_file(file);
 	int ret;
 
-	dbg("pid: %d, state: 0x%lx", task_pid_nr(current), fimc->state);
+	dbg("pid: %d, state: 0x%lx", task_pid_nr(sysiso_current), fimc->state);
 
 	mutex_lock(&fimc->lock);
 
diff --git a/drivers/media/platform/exynos4-is/fimc-m2m.c b/drivers/media/platform/exynos4-is/fimc-m2m.c
index df8e2aa45..d8436929e 100644
--- a/drivers/media/platform/exynos4-is/fimc-m2m.c
+++ b/drivers/media/platform/exynos4-is/fimc-m2m.c
@@ -606,7 +606,8 @@ static int fimc_m2m_open(struct file *file)
 	struct fimc_ctx *ctx;
 	int ret = -EBUSY;
 
-	pr_debug("pid: %d, state: %#lx\n", task_pid_nr(current), fimc->state);
+	pr_debug("pid: %d, state: %#lx\n", task_pid_nr(sysiso_current),
+		 fimc->state);
 
 	if (mutex_lock_interruptible(&fimc->lock))
 		return -ERESTARTSYS;
@@ -680,7 +681,7 @@ static int fimc_m2m_release(struct file *file)
 	struct fimc_dev *fimc = ctx->fimc_dev;
 
 	dbg("pid: %d, state: 0x%lx, refcnt= %d",
-		task_pid_nr(current), fimc->state, fimc->m2m.refcnt);
+		task_pid_nr(sysiso_current), fimc->state, fimc->m2m.refcnt);
 
 	mutex_lock(&fimc->lock);
 
diff --git a/drivers/media/platform/s3c-camif/camif-capture.c b/drivers/media/platform/s3c-camif/camif-capture.c
index 140854ab4..94b612c63 100644
--- a/drivers/media/platform/s3c-camif/camif-capture.c
+++ b/drivers/media/platform/s3c-camif/camif-capture.c
@@ -538,7 +538,7 @@ static int s3c_camif_open(struct file *file)
 	int ret;
 
 	pr_debug("[vp%d] state: %#x,  owner: %p, pid: %d\n", vp->id,
-		 vp->state, vp->owner, task_pid_nr(current));
+		 vp->state, vp->owner, task_pid_nr(sysiso_current));
 
 	if (mutex_lock_interruptible(&camif->lock))
 		return -ERESTARTSYS;
@@ -570,7 +570,7 @@ static int s3c_camif_close(struct file *file)
 	int ret;
 
 	pr_debug("[vp%d] state: %#x, owner: %p, pid: %d\n", vp->id,
-		 vp->state, vp->owner, task_pid_nr(current));
+		 vp->state, vp->owner, task_pid_nr(sysiso_current));
 
 	mutex_lock(&camif->lock);
 
diff --git a/drivers/media/test-drivers/vivid/vivid-radio-rx.c b/drivers/media/test-drivers/vivid/vivid-radio-rx.c
index 232cab508..894bcbcab 100644
--- a/drivers/media/test-drivers/vivid/vivid-radio-rx.c
+++ b/drivers/media/test-drivers/vivid/vivid-radio-rx.c
@@ -77,7 +77,7 @@ ssize_t vivid_radio_rx_read(struct file *file, char __user *buf,
 		mutex_unlock(&dev->mutex);
 		if (file->f_flags & O_NONBLOCK)
 			return -EWOULDBLOCK;
-		if (msleep_interruptible(20) && signal_pending(current))
+		if (msleep_interruptible(20) && signal_pending(sysiso_current))
 			return -EINTR;
 		if (mutex_lock_interruptible(&dev->mutex))
 			return -ERESTARTSYS;
diff --git a/drivers/media/test-drivers/vivid/vivid-radio-tx.c b/drivers/media/test-drivers/vivid/vivid-radio-tx.c
index 049d40b94..75b9261f2 100644
--- a/drivers/media/test-drivers/vivid/vivid-radio-tx.c
+++ b/drivers/media/test-drivers/vivid/vivid-radio-tx.c
@@ -62,7 +62,7 @@ ssize_t vivid_radio_tx_write(struct file *file, const char __user *buf,
 		mutex_unlock(&dev->mutex);
 		if (file->f_flags & O_NONBLOCK)
 			return -EWOULDBLOCK;
-		if (msleep_interruptible(20) && signal_pending(current))
+		if (msleep_interruptible(20) && signal_pending(sysiso_current))
 			return -EINTR;
 		if (mutex_lock_interruptible(&dev->mutex))
 			return -ERESTARTSYS;
diff --git a/drivers/media/usb/cpia2/cpia2_core.c b/drivers/media/usb/cpia2/cpia2_core.c
index b5a2d06fb..152fa6853 100644
--- a/drivers/media/usb/cpia2/cpia2_core.c
+++ b/drivers/media/usb/cpia2/cpia2_core.c
@@ -2349,7 +2349,7 @@ long cpia2_read(struct camera_data *cam,
 			       !video_is_registered(&cam->vdev) ||
 			       (frame = cam->curbuff)->status == FRAME_READY);
 		mutex_lock(&cam->v4l2_lock);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		if (!video_is_registered(&cam->vdev))
 			return 0;
diff --git a/drivers/media/usb/cpia2/cpia2_v4l.c b/drivers/media/usb/cpia2/cpia2_v4l.c
index 926ecfc9b..d5998da2c 100644
--- a/drivers/media/usb/cpia2/cpia2_v4l.c
+++ b/drivers/media/usb/cpia2/cpia2_v4l.c
@@ -188,7 +188,7 @@ static int sync(struct camera_data *cam, int frame_nr)
 					 !cam->streaming ||
 					 frame->status == FRAME_READY);
 		mutex_lock(&cam->v4l2_lock);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		if (!video_is_registered(&cam->vdev))
 			return -ENOTTY;
@@ -892,7 +892,7 @@ static int cpia2_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
 					 !video_is_registered(&cam->vdev) ||
 					 (cb = cam->curbuff)->status == FRAME_READY);
 		mutex_lock(&cam->v4l2_lock);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		if (!video_is_registered(&cam->vdev))
 			return -ENOTTY;
diff --git a/drivers/media/usb/gspca/cpia1.c b/drivers/media/usb/gspca/cpia1.c
index 46ed95483..3d44336a9 100644
--- a/drivers/media/usb/gspca/cpia1.c
+++ b/drivers/media/usb/gspca/cpia1.c
@@ -740,7 +740,7 @@ static int goto_high_power(struct gspca_dev *gspca_dev)
 
 	msleep_interruptible(40);	/* windows driver does it too */
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	ret = do_command(gspca_dev, CPIA_COMMAND_GetCameraStatus, 0, 0, 0, 0);
diff --git a/drivers/misc/bcm-vk/bcm_vk_dev.c b/drivers/misc/bcm-vk/bcm_vk_dev.c
index ad639ee85..adc6f76d3 100644
--- a/drivers/misc/bcm-vk/bcm_vk_dev.c
+++ b/drivers/misc/bcm-vk/bcm_vk_dev.c
@@ -1168,7 +1168,7 @@ static long bcm_vk_reset(struct bcm_vk *vk, struct vk_reset __user *arg)
 
 	spin_lock(&vk->ctx_lock);
 	if (!vk->reset_pid) {
-		vk->reset_pid = task_pid_nr(current);
+		vk->reset_pid = task_pid_nr(sysiso_current);
 	} else {
 		dev_err(dev, "Reset already launched by process pid %d\n",
 			vk->reset_pid);
diff --git a/drivers/misc/bcm-vk/bcm_vk_msg.c b/drivers/misc/bcm-vk/bcm_vk_msg.c
index 066b9ef7f..b444efb42 100644
--- a/drivers/misc/bcm-vk/bcm_vk_msg.c
+++ b/drivers/misc/bcm-vk/bcm_vk_msg.c
@@ -978,7 +978,7 @@ int bcm_vk_open(struct inode *inode, struct file *p_file)
 	int rc = 0;
 
 	/* get a context and set it up for file */
-	ctx = bcm_vk_get_ctx(vk, task_tgid_nr(current));
+	ctx = bcm_vk_get_ctx(vk, task_tgid_nr(sysiso_current));
 	if (!ctx) {
 		dev_err(dev, "Error allocating context\n");
 		rc = -ENOMEM;
diff --git a/drivers/misc/bcm-vk/bcm_vk_tty.c b/drivers/misc/bcm-vk/bcm_vk_tty.c
index 6669625ba..76012227d 100644
--- a/drivers/misc/bcm-vk/bcm_vk_tty.c
+++ b/drivers/misc/bcm-vk/bcm_vk_tty.c
@@ -141,7 +141,7 @@ static int bcm_vk_tty_open(struct tty_struct *tty, struct file *file)
 
 	vktty = &vk->tty[index];
 
-	vktty->pid = task_pid_nr(current);
+	vktty->pid = task_pid_nr(sysiso_current);
 	vktty->to_offset = TO_TTYK_BASE(index);
 	vktty->from_offset = FROM_TTYK_BASE(index);
 
diff --git a/drivers/misc/cxl/file.c b/drivers/misc/cxl/file.c
index 3dbdce96f..4acc687d0 100644
--- a/drivers/misc/cxl/file.c
+++ b/drivers/misc/cxl/file.c
@@ -454,7 +454,7 @@ ssize_t afu_read(struct file *file, char __user *buf, size_t count,
 			goto out;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/misc/cxl/guest.c b/drivers/misc/cxl/guest.c
index 186308f1f..7b09d2c5a 100644
--- a/drivers/misc/cxl/guest.c
+++ b/drivers/misc/cxl/guest.c
@@ -535,7 +535,7 @@ static int attach_afu_directed(struct cxl_context *ctx, u64 wed, u64 amr)
 		if (mfmsr() & MSR_SF)
 			flags |= CXL_PE_64_BIT;
 	} else {
-		pid = current->pid;
+		pid = sysiso_current->pid;
 		flags |= CXL_PE_PROBLEM_STATE;
 		flags |= CXL_PE_TRANSLATION_ENABLED;
 		if (!test_tsk_thread_flag(current, TIF_32BIT))
diff --git a/drivers/misc/cxl/native.c b/drivers/misc/cxl/native.c
index 1a7f22836..fbcdf6f2f 100644
--- a/drivers/misc/cxl/native.c
+++ b/drivers/misc/cxl/native.c
@@ -745,7 +745,7 @@ int cxl_attach_afu_directed_psl8(struct cxl_context *ctx, u64 wed, u64 amr)
 	ctx->elem->haurp = 0; /* disable */
 	ctx->elem->u.sdr = cpu_to_be64(mfspr(SPRN_SDR1));
 
-	pid = current->pid;
+	pid = sysiso_current->pid;
 	if (ctx->kernel)
 		pid = 0;
 	ctx->elem->common.tid = 0;
@@ -935,7 +935,7 @@ int cxl_attach_dedicated_process_psl8(struct cxl_context *ctx, u64 wed, u64 amr)
 	u64 pid;
 	int rc;
 
-	pid = (u64)current->pid << 32;
+	pid = (u64) sysiso_current->pid << 32;
 	if (ctx->kernel)
 		pid = 0;
 	cxl_p2n_write(afu, CXL_PSL_PID_TID_An, pid);
diff --git a/drivers/misc/fastrpc.c b/drivers/misc/fastrpc.c
index ad6ced454..ef0b508b2 100644
--- a/drivers/misc/fastrpc.c
+++ b/drivers/misc/fastrpc.c
@@ -479,7 +479,7 @@ static struct fastrpc_invoke_ctx *fastrpc_context_alloc(
 
 	ctx->sc = sc;
 	ctx->retval = -1;
-	ctx->pid = current->pid;
+	ctx->pid = sysiso_current->pid;
 	ctx->tgid = user->tgid;
 	ctx->cctx = cctx;
 	init_completion(&ctx->work);
@@ -918,7 +918,7 @@ static int fastrpc_invoke_send(struct fastrpc_session_ctx *sctx,
 
 	cctx = fl->cctx;
 	msg->pid = fl->tgid;
-	msg->tid = current->pid;
+	msg->tid = sysiso_current->pid;
 
 	if (kernel)
 		msg->pid = 0;
@@ -1047,7 +1047,7 @@ static int fastrpc_init_create_process(struct fastrpc_user *fl,
 	}
 
 	inbuf.pgid = fl->tgid;
-	inbuf.namelen = strlen(current->comm) + 1;
+	inbuf.namelen = strlen(sysiso_current->comm) + 1;
 	inbuf.filelen = init.filelen;
 	inbuf.pageslen = 1;
 	inbuf.attrs = init.attrs;
@@ -1072,7 +1072,7 @@ static int fastrpc_init_create_process(struct fastrpc_user *fl,
 	args[0].length = sizeof(inbuf);
 	args[0].fd = -1;
 
-	args[1].ptr = (u64)(uintptr_t)current->comm;
+	args[1].ptr = (u64)(uintptr_t)sysiso_current->comm;
 	args[1].length = inbuf.namelen;
 	args[1].fd = -1;
 
@@ -1234,7 +1234,7 @@ static int fastrpc_device_open(struct inode *inode, struct file *filp)
 	INIT_LIST_HEAD(&fl->maps);
 	INIT_LIST_HEAD(&fl->mmaps);
 	INIT_LIST_HEAD(&fl->user);
-	fl->tgid = current->tgid;
+	fl->tgid = sysiso_current->tgid;
 	fl->cctx = cctx;
 
 	fl->sctx = fastrpc_session_alloc(cctx);
diff --git a/drivers/misc/habanalabs/common/habanalabs_drv.c b/drivers/misc/habanalabs/common/habanalabs_drv.c
index a75e4fceb..ec01f533f 100644
--- a/drivers/misc/habanalabs/common/habanalabs_drv.c
+++ b/drivers/misc/habanalabs/common/habanalabs_drv.c
@@ -244,7 +244,7 @@ int hl_device_open_ctrl(struct inode *inode, struct file *filp)
 	hpriv->is_control = true;
 	nonseekable_open(inode, filp);
 
-	hpriv->taskpid = find_get_pid(current->pid);
+	hpriv->taskpid = find_get_pid(sysiso_current->pid);
 
 	return 0;
 
diff --git a/drivers/misc/habanalabs/common/habanalabs_ioctl.c b/drivers/misc/habanalabs/common/habanalabs_ioctl.c
index 86c3257d9..df2cef110 100644
--- a/drivers/misc/habanalabs/common/habanalabs_ioctl.c
+++ b/drivers/misc/habanalabs/common/habanalabs_ioctl.c
@@ -709,7 +709,7 @@ static long _hl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg,
 out_err:
 	if (retcode)
 		dev_dbg(dev, "error in ioctl: pid=%d, cmd=0x%02x, nr=0x%02x\n",
-			  task_pid_nr(current), cmd, nr);
+			  task_pid_nr(sysiso_current), cmd, nr);
 
 	if (kdata != stack_kdata)
 		kfree(kdata);
@@ -733,7 +733,7 @@ long hl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 		ioctl = &hl_ioctls[nr];
 	} else {
 		dev_err(hdev->dev, "invalid ioctl: pid=%d, nr=0x%02x\n",
-			task_pid_nr(current), nr);
+			task_pid_nr(sysiso_current), nr);
 		return -ENOTTY;
 	}
 
@@ -756,7 +756,7 @@ long hl_ioctl_control(struct file *filep, unsigned int cmd, unsigned long arg)
 		ioctl = &hl_ioctls_control[nr];
 	} else {
 		dev_err(hdev->dev_ctrl, "invalid ioctl: pid=%d, nr=0x%02x\n",
-			task_pid_nr(current), nr);
+			task_pid_nr(sysiso_current), nr);
 		return -ENOTTY;
 	}
 
diff --git a/drivers/misc/habanalabs/common/memory.c b/drivers/misc/habanalabs/common/memory.c
index 33986933a..511095bc9 100644
--- a/drivers/misc/habanalabs/common/memory.c
+++ b/drivers/misc/habanalabs/common/memory.c
@@ -1745,7 +1745,7 @@ int hl_pin_host_memory(struct hl_device *hdev, u64 addr, u64 size,
 		return -EINVAL;
 	}
 
-	userptr->pid = current->pid;
+	userptr->pid = sysiso_current->pid;
 	userptr->sgt = kzalloc(sizeof(*userptr->sgt), GFP_KERNEL);
 	if (!userptr->sgt)
 		return -ENOMEM;
diff --git a/drivers/misc/ibmasm/r_heartbeat.c b/drivers/misc/ibmasm/r_heartbeat.c
index 21c9b6a6f..05837efa7 100644
--- a/drivers/misc/ibmasm/r_heartbeat.c
+++ b/drivers/misc/ibmasm/r_heartbeat.c
@@ -68,7 +68,7 @@ int ibmasm_start_reverse_heartbeat(struct service_processor *sp, struct reverse_
 			rhb->stopped,
 			REVERSE_HEARTBEAT_TIMEOUT * HZ);
 
-		if (signal_pending(current) || rhb->stopped) {
+		if (signal_pending(sysiso_current) || rhb->stopped) {
 			result = -EINTR;
 			break;
 		}
diff --git a/drivers/misc/ibmvmc.c b/drivers/misc/ibmvmc.c
index c0fe3295c..826cf975c 100644
--- a/drivers/misc/ibmvmc.c
+++ b/drivers/misc/ibmvmc.c
@@ -964,7 +964,7 @@ static ssize_t ibmvmc_read(struct file *file, char *buf, size_t nbytes,
 
 		schedule();
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/misc/lis3lv02d/lis3lv02d.c b/drivers/misc/lis3lv02d/lis3lv02d.c
index 70c5bb1e6..e04fab639 100644
--- a/drivers/misc/lis3lv02d/lis3lv02d.c
+++ b/drivers/misc/lis3lv02d/lis3lv02d.c
@@ -622,7 +622,7 @@ static ssize_t lis3lv02d_misc_read(struct file *file, char __user *buf,
 			goto out;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/drivers/misc/lkdtm/bugs.c b/drivers/misc/lkdtm/bugs.c
index 4282b6252..7e017ecab 100644
--- a/drivers/misc/lkdtm/bugs.c
+++ b/drivers/misc/lkdtm/bugs.c
@@ -140,7 +140,7 @@ static unsigned long stack_addr;
 void lkdtm_REPORT_STACK(void)
 {
 	volatile uintptr_t magic;
-	pid_t pid = task_pid_nr(current);
+	pid_t pid = task_pid_nr(sysiso_current);
 
 	if (pid != stack_pid) {
 		pr_info("Starting stack offset tracking for pid %d\n", pid);
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 44bac4ad6..4ec8d7cdb 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -80,7 +80,7 @@ ssize_t __mei_cl_send(struct mei_cl *cl, const u8 *buf, size_t length, u8 vtag,
 				(!mei_cl_is_connected(cl)));
 		mutex_lock(&bus->device_lock);
 		if (rets) {
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				rets = -EINTR;
 			goto out;
 		}
@@ -170,7 +170,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length, u8 *vtag,
 			if (rets == 0)
 				return -ETIME;
 			if (rets < 0) {
-				if (signal_pending(current))
+				if (signal_pending(sysiso_current))
 					return -EINTR;
 				return -ERESTARTSYS;
 			}
@@ -179,7 +179,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length, u8 *vtag,
 					(cl->rx_wait,
 					mei_cl_read_cb(cl, NULL) ||
 					(!mei_cl_is_connected(cl)))) {
-				if (signal_pending(current))
+				if (signal_pending(sysiso_current))
 					return -EINTR;
 				return -ERESTARTSYS;
 			}
diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index 96f4e59c3..ddc5cab02 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -2059,7 +2059,7 @@ ssize_t mei_cl_write(struct mei_cl *cl, struct mei_cl_cb *cb)
 		mutex_lock(&dev->device_lock);
 		/* wait_event_interruptible returns -ERESTARTSYS */
 		if (rets) {
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				rets = -EINTR;
 			goto err;
 		}
diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c
index 786f7c8f7..547af01a8 100644
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@ -217,7 +217,7 @@ static ssize_t mei_read(struct file *file, char __user *ubuf,
 	if (wait_event_interruptible(cl->rx_wait,
 				     mei_cl_read_cb(cl, file) ||
 				     !mei_cl_is_connected(cl))) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 		return -ERESTARTSYS;
 	}
@@ -358,7 +358,7 @@ static ssize_t mei_write(struct file *file, const char __user *ubuf,
 				(!mei_cl_is_connected(cl)));
 		mutex_lock(&dev->device_lock);
 		if (rets) {
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				rets = -EINTR;
 			goto out;
 		}
@@ -883,7 +883,7 @@ static int mei_fsync(struct file *fp, loff_t start, loff_t end, int datasync)
 				!mei_cl_is_connected(cl));
 		mutex_lock(&dev->device_lock);
 		if (rets) {
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				rets = -EINTR;
 			goto out;
 		}
diff --git a/drivers/misc/ocxl/file.c b/drivers/misc/ocxl/file.c
index e70525eed..2ae0a690c 100644
--- a/drivers/misc/ocxl/file.c
+++ b/drivers/misc/ocxl/file.c
@@ -426,7 +426,7 @@ static ssize_t afu_read(struct file *file, char __user *buf, size_t count,
 			return -EAGAIN;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			finish_wait(&ctx->events_wq, &event_wait);
 			return -ERESTARTSYS;
 		}
diff --git a/drivers/misc/ocxl/link.c b/drivers/misc/ocxl/link.c
index ab039c115..8d245068e 100644
--- a/drivers/misc/ocxl/link.c
+++ b/drivers/misc/ocxl/link.c
@@ -620,7 +620,8 @@ int ocxl_link_add_pe(void *link_handle, int pasid, u32 pidr, u32 tidr,
 	 */
 	if (mm)
 		mmgrab(mm);
-	trace_ocxl_context_add(current->pid, spa->spa_mem, pasid, pidr, tidr);
+	trace_ocxl_context_add(sysiso_current->pid, spa->spa_mem, pasid, pidr,
+			       tidr);
 unlock:
 	mutex_unlock(&spa->spa_lock);
 	return rc;
@@ -702,8 +703,8 @@ int ocxl_link_remove_pe(void *link_handle, int pasid)
 		goto unlock;
 	}
 
-	trace_ocxl_context_remove(current->pid, spa->spa_mem, pasid,
-				be32_to_cpu(pe->pid), be32_to_cpu(pe->tid));
+	trace_ocxl_context_remove(sysiso_current->pid, spa->spa_mem, pasid,
+				  be32_to_cpu(pe->pid), be32_to_cpu(pe->tid));
 
 	memset(pe, 0, sizeof(struct ocxl_process_element));
 	/*
diff --git a/drivers/misc/sgi-gru/grufault.c b/drivers/misc/sgi-gru/grufault.c
index d7ef61e60..08d6d6738 100644
--- a/drivers/misc/sgi-gru/grufault.c
+++ b/drivers/misc/sgi-gru/grufault.c
@@ -879,7 +879,7 @@ int gru_set_context_option(unsigned long arg)
 		break;
 	case sco_gseg_owner:
  		/* Register the current task as the GSEG owner */
-		gts->ts_tgid_owner = current->tgid;
+		gts->ts_tgid_owner = sysiso_current->tgid;
 		break;
 	case sco_cch_req_slice:
  		/* Set the CCH slice option */
diff --git a/drivers/misc/sgi-gru/grumain.c b/drivers/misc/sgi-gru/grumain.c
index 9afda47ef..44bfa7ccd 100644
--- a/drivers/misc/sgi-gru/grumain.c
+++ b/drivers/misc/sgi-gru/grumain.c
@@ -726,7 +726,7 @@ void gru_check_context_placement(struct gru_thread_state *gts)
 	 * references. Pthread apps use non-owner references to the CBRs.
 	 */
 	gru = gts->ts_gru;
-	if (!gru || gts->ts_tgid_owner != current->tgid)
+	if (!gru || gts->ts_tgid_owner != sysiso_current->tgid)
 		return;
 
 	if (!gru_check_chiplet_assignment(gru, gts)) {
diff --git a/drivers/mmc/host/tmio_mmc_core.c b/drivers/mmc/host/tmio_mmc_core.c
index e2affa52e..42c3ddb04 100644
--- a/drivers/mmc/host/tmio_mmc_core.c
+++ b/drivers/mmc/host/tmio_mmc_core.c
@@ -936,13 +936,13 @@ static void tmio_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		if (IS_ERR(host->mrq)) {
 			dev_dbg(dev,
 				"%s.%d: concurrent .set_ios(), clk %u, mode %u\n",
-				current->comm, task_pid_nr(current),
+				sysiso_current->comm, task_pid_nr(sysiso_current),
 				ios->clock, ios->power_mode);
 			host->mrq = ERR_PTR(-EINTR);
 		} else {
 			dev_dbg(dev,
 				"%s.%d: CMD%u active since %lu, now %lu!\n",
-				current->comm, task_pid_nr(current),
+				sysiso_current->comm, task_pid_nr(sysiso_current),
 				host->mrq->cmd->opcode, host->last_req_ts,
 				jiffies);
 		}
@@ -990,7 +990,7 @@ static void tmio_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	if (PTR_ERR(host->mrq) == -EINTR)
 		dev_dbg(&host->pdev->dev,
 			"%s.%d: IOS interrupted: clk %u, mode %u",
-			current->comm, task_pid_nr(current),
+			sysiso_current->comm, task_pid_nr(sysiso_current),
 			ios->clock, ios->power_mode);
 	host->mrq = NULL;
 
diff --git a/drivers/mtd/tests/mtd_test.h b/drivers/mtd/tests/mtd_test.h
index 5a6e3bbe0..d495f065f 100644
--- a/drivers/mtd/tests/mtd_test.h
+++ b/drivers/mtd/tests/mtd_test.h
@@ -5,7 +5,7 @@
 static inline int mtdtest_relax(void)
 {
 	cond_resched();
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		pr_info("aborting test due to pending signal!\n");
 		return -EINTR;
 	}
diff --git a/drivers/mtd/ubi/gluebi.c b/drivers/mtd/ubi/gluebi.c
index 1b980d15d..e01e5f753 100644
--- a/drivers/mtd/ubi/gluebi.c
+++ b/drivers/mtd/ubi/gluebi.c
@@ -29,7 +29,7 @@
 
 #define err_msg(fmt, ...)                                   \
 	pr_err("gluebi (pid %d): %s: " fmt "\n",            \
-	       current->pid, __func__, ##__VA_ARGS__)
+	       sysiso_current->pid, __func__, ##__VA_ARGS__)
 
 /**
  * struct gluebi_device - a gluebi device description data structure.
diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c
index 8455f1d47..50a8543e4 100644
--- a/drivers/mtd/ubi/wl.c
+++ b/drivers/mtd/ubi/wl.c
@@ -1621,7 +1621,7 @@ int ubi_thread(void *u)
 	struct ubi_device *ubi = u;
 
 	ubi_msg(ubi, "background thread \"%s\" started, PID %d",
-		ubi->bgt_name, task_pid_nr(current));
+		ubi->bgt_name, task_pid_nr(sysiso_current));
 
 	set_freezable();
 	for (;;) {
diff --git a/drivers/net/can/softing/softing_fw.c b/drivers/net/can/softing/softing_fw.c
index 7e1536877..ac550c5ae 100644
--- a/drivers/net/can/softing/softing_fw.c
+++ b/drivers/net/can/softing/softing_fw.c
@@ -84,7 +84,7 @@ int softing_bootloader_command(struct softing *card, int16_t cmd,
 			break;
 		/* process context => relax */
 		usleep_range(500, 10000);
-	} while (!signal_pending(current));
+	} while (!signal_pending(sysiso_current));
 
 	ret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;
 	dev_alert(&card->pdev->dev, "bootloader %s failed (%i)\n", msg, ret);
@@ -327,7 +327,7 @@ static int softing_reset_chip(struct softing *card)
 		ret = softing_fct_cmd(card, 0, "reset_can");
 		if (!ret)
 			break;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			/* don't wait any longer */
 			break;
 	} while (1);
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 5e0e0e70d..f7b48bd2c 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -12045,7 +12045,7 @@ static int tg3_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,
 		}
 		memcpy(pd + i, &val, 4);
 		if (need_resched()) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				eeprom->len += i;
 				ret = -EINTR;
 				goto eeprom_done;
diff --git a/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_cm.c b/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_cm.c
index bcad69c48..c41a1f860 100644
--- a/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_cm.c
+++ b/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_cm.c
@@ -425,7 +425,7 @@ static int wait_for_states(struct sock *sk, unsigned int states)
 			err = -EBUSY;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(current_timeo);
 			break;
 		}
diff --git a/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_io.c b/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_io.c
index c320cc8ca..7b804dcd3 100644
--- a/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_io.c
+++ b/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_io.c
@@ -934,7 +934,7 @@ static int csk_wait_memory(struct chtls_dev *cdev,
 				set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 			goto do_nonblock;
 		}
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto do_interrupted;
 		sk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);
 		if (csk_mem_free(cdev, sk) && !vm_wait)
@@ -1455,7 +1455,7 @@ static int chtls_pt_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 			     tp->urg_seq == tp->copied_seq)) {
 			if (copied)
 				break;
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = timeo ? sock_intr_errno(timeo) :
 					-EAGAIN;
 				break;
@@ -1476,7 +1476,7 @@ static int chtls_pt_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 		if (copied) {
 			if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
 			    (sk->sk_shutdown & RCV_SHUTDOWN) ||
-			    signal_pending(current))
+			    signal_pending(sysiso_current))
 				break;
 
 			if (!timeo)
@@ -1498,7 +1498,7 @@ static int chtls_pt_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 				copied = -EAGAIN;
 				break;
 			}
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = sock_intr_errno(timeo);
 				break;
 			}
@@ -1633,7 +1633,7 @@ static int peekmsg(struct sock *sk, struct msghdr *msg,
 		if (unlikely(tp->urg_data && tp->urg_seq == peek_seq)) {
 			if (copied)
 				break;
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = timeo ? sock_intr_errno(timeo) :
 				-EAGAIN;
 				break;
@@ -1665,7 +1665,7 @@ static int peekmsg(struct sock *sk, struct msghdr *msg,
 			copied = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			copied = sock_intr_errno(timeo);
 			break;
 		}
@@ -1681,7 +1681,7 @@ static int peekmsg(struct sock *sk, struct msghdr *msg,
 		if (unlikely(peek_seq != tp->copied_seq)) {
 			if (net_ratelimit())
 				pr_info("TCP(%s:%d), race in MSG_PEEK.\n",
-					current->comm, current->pid);
+					sysiso_current->comm, sysiso_current->pid);
 			peek_seq = tp->copied_seq;
 		}
 		continue;
@@ -1781,7 +1781,7 @@ int chtls_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 		if (unlikely(tp->urg_data && tp->urg_seq == tp->copied_seq)) {
 			if (copied)
 				break;
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = timeo ? sock_intr_errno(timeo) :
 					-EAGAIN;
 				break;
@@ -1804,7 +1804,7 @@ int chtls_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 		if (copied) {
 			if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
 			    (sk->sk_shutdown & RCV_SHUTDOWN) ||
-			    signal_pending(current))
+			    signal_pending(sysiso_current))
 				break;
 		} else {
 			if (sock_flag(sk, SOCK_DONE))
@@ -1823,7 +1823,7 @@ int chtls_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 				copied = -EAGAIN;
 				break;
 			}
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = sock_intr_errno(timeo);
 				break;
 			}
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cq.c b/drivers/net/ethernet/mellanox/mlx5/core/cq.c
index 02e77ffe5..a22f3dcef 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cq.c
@@ -128,7 +128,7 @@ int mlx5_core_create_cq(struct mlx5_core_dev *dev, struct mlx5_core_cq *cq,
 	if (err)
 		goto err_cq_add;
 
-	cq->pid = current->pid;
+	cq->pid = sysiso_current->pid;
 	err = mlx5_debug_cq_add(dev, cq);
 	if (err)
 		mlx5_core_dbg(dev, "failed adding CP 0x%x to debug file system\n",
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/rss.c b/drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
index 625cd49ef..defbc11dc 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rss.c
@@ -5,7 +5,7 @@
 
 #define mlx5e_rss_warn(__dev, format, ...)			\
 	dev_warn((__dev)->device, "%s:%d:(pid %d): " format,	\
-		 __func__, __LINE__, current->pid,		\
+		 __func__, __LINE__, sysiso_current->pid,		\
 		 ##__VA_ARGS__)
 
 static const struct mlx5e_rss_params_traffic_type rss_default_config[MLX5E_NUM_INDIR_TIRS] = {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 230eab7e3..625ed3863 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -46,13 +46,13 @@ extern uint mlx5_core_debug_mask;
 
 #define mlx5_core_dbg(__dev, format, ...)				\
 	dev_dbg((__dev)->device, "%s:%d:(pid %d): " format,		\
-		 __func__, __LINE__, current->pid,			\
+		 __func__, __LINE__, sysiso_current->pid,			\
 		 ##__VA_ARGS__)
 
 #define mlx5_core_dbg_once(__dev, format, ...)		\
 	dev_dbg_once((__dev)->device,		\
 		     "%s:%d:(pid %d): " format,		\
-		     __func__, __LINE__, current->pid,	\
+		     __func__, __LINE__, sysiso_current->pid,	\
 		     ##__VA_ARGS__)
 
 #define mlx5_core_dbg_mask(__dev, mask, format, ...)		\
@@ -63,29 +63,29 @@ do {								\
 
 #define mlx5_core_err(__dev, format, ...)			\
 	dev_err((__dev)->device, "%s:%d:(pid %d): " format,	\
-		__func__, __LINE__, current->pid,		\
+		__func__, __LINE__, sysiso_current->pid,		\
 	       ##__VA_ARGS__)
 
 #define mlx5_core_err_rl(__dev, format, ...)			\
 	dev_err_ratelimited((__dev)->device,			\
 			    "%s:%d:(pid %d): " format,		\
-			    __func__, __LINE__, current->pid,	\
+			    __func__, __LINE__, sysiso_current->pid,	\
 			    ##__VA_ARGS__)
 
 #define mlx5_core_warn(__dev, format, ...)			\
 	dev_warn((__dev)->device, "%s:%d:(pid %d): " format,	\
-		 __func__, __LINE__, current->pid,		\
+		 __func__, __LINE__, sysiso_current->pid,		\
 		 ##__VA_ARGS__)
 
 #define mlx5_core_warn_once(__dev, format, ...)				\
 	dev_warn_once((__dev)->device, "%s:%d:(pid %d): " format,	\
-		      __func__, __LINE__, current->pid,			\
+		      __func__, __LINE__, sysiso_current->pid,			\
 		      ##__VA_ARGS__)
 
 #define mlx5_core_warn_rl(__dev, format, ...)			\
 	dev_warn_ratelimited((__dev)->device,			\
 			     "%s:%d:(pid %d): " format,		\
-			     __func__, __LINE__, current->pid,	\
+			     __func__, __LINE__, sysiso_current->pid,	\
 			     ##__VA_ARGS__)
 
 #define mlx5_core_info(__dev, format, ...)		\
@@ -94,7 +94,7 @@ do {								\
 #define mlx5_core_info_rl(__dev, format, ...)			\
 	dev_info_ratelimited((__dev)->device,			\
 			     "%s:%d:(pid %d): " format,		\
-			     __func__, __LINE__, current->pid,	\
+			     __func__, __LINE__, sysiso_current->pid,	\
 			     ##__VA_ARGS__)
 
 static inline struct device *mlx5_core_dma_dev(struct mlx5_core_dev *dev)
diff --git a/drivers/net/ethernet/realtek/8139too.c b/drivers/net/ethernet/realtek/8139too.c
index 2e6923cc6..4b3b1bd47 100644
--- a/drivers/net/ethernet/realtek/8139too.c
+++ b/drivers/net/ethernet/realtek/8139too.c
@@ -76,7 +76,7 @@
 		Tobias Ringstrm - Rx interrupt status checking suggestion
 
 		Andrew Morton - Clear blocked signals, avoid
-		buffer overrun setting current->comm.
+		buffer overrun setting sysiso_current->comm.
 
 		Kalle Olavi Niemitalo - Wake-on-LAN ioctls
 
diff --git a/drivers/net/ethernet/sfc/falcon/falcon.c b/drivers/net/ethernet/sfc/falcon/falcon.c
index 3324a6219..f1727ab08 100644
--- a/drivers/net/ethernet/sfc/falcon/falcon.c
+++ b/drivers/net/ethernet/sfc/falcon/falcon.c
@@ -632,7 +632,7 @@ falcon_spi_read(struct ef4_nic *efx, const struct falcon_spi_device *spi,
 
 		/* Avoid locking up the system */
 		cond_resched();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -EINTR;
 			break;
 		}
@@ -725,7 +725,7 @@ falcon_spi_write(struct ef4_nic *efx, const struct falcon_spi_device *spi,
 
 		/* Avoid locking up the system */
 		cond_resched();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -EINTR;
 			break;
 		}
@@ -755,7 +755,7 @@ falcon_spi_slow_wait(struct falcon_mtd_partition *part, bool uninterruptible)
 			return rc;
 		if (!(status & SPI_STATUS_NRDY))
 			return 0;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 	}
 	pr_err("%s: timed out waiting for %s\n",
@@ -841,7 +841,7 @@ falcon_spi_erase(struct falcon_mtd_partition *part, loff_t start, size_t len)
 
 		/* Avoid locking up the system */
 		cond_resched();
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 	}
 
diff --git a/drivers/net/netdevsim/bus.c b/drivers/net/netdevsim/bus.c
index 29f5627d1..b4cfe7f01 100644
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@ -417,7 +417,7 @@ nsim_bus_dev_new(unsigned int id, unsigned int port_count, unsigned int num_queu
 	nsim_bus_dev->dev.type = &nsim_bus_dev_type;
 	nsim_bus_dev->port_count = port_count;
 	nsim_bus_dev->num_queues = num_queues;
-	nsim_bus_dev->initial_net = current->nsproxy->net_ns;
+	nsim_bus_dev->initial_net = sysiso_current->nsproxy->net_ns;
 	nsim_bus_dev->max_vfs = NSIM_BUS_DEV_MAX_VFS;
 	mutex_init(&nsim_bus_dev->nsim_bus_reload_lock);
 	mutex_init(&nsim_bus_dev->vfs_lock);
diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
index fb52cd175..f8cfcb378 100644
--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -461,7 +461,7 @@ static ssize_t ppp_read(struct file *file, char __user *buf,
 		if (file->f_flags & O_NONBLOCK)
 			break;
 		ret = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		schedule();
 	}
@@ -707,7 +707,7 @@ static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 	pf = file->private_data;
 	if (!pf) {
-		err = ppp_unattached_ioctl(current->nsproxy->net_ns,
+		err = ppp_unattached_ioctl(sysiso_current->nsproxy->net_ns,
 					   pf, file, cmd, arg);
 		goto out;
 	}
@@ -719,7 +719,7 @@ static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		 * ppp-2.4.2 (released November 2003).
 		 */
 		pr_warn_once("%s (%d) used obsolete PPPIOCDETACH ioctl\n",
-			     current->comm, current->pid);
+			     sysiso_current->comm, sysiso_current->pid);
 		err = -EINVAL;
 		goto out;
 	}
@@ -746,7 +746,7 @@ static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			if (get_user(unit, p))
 				break;
 			err = -ENXIO;
-			pn = ppp_pernet(current->nsproxy->net_ns);
+			pn = ppp_pernet(sysiso_current->nsproxy->net_ns);
 			spin_lock_bh(&pn->all_channels_lock);
 			pchb = ppp_find_channel(pn, unit);
 			/* Hold a reference to prevent pchb being freed while
@@ -2862,7 +2862,7 @@ ppp_mp_reconstruct(struct ppp *ppp)
 /* Create a new, unattached ppp channel. */
 int ppp_register_channel(struct ppp_channel *chan)
 {
-	return ppp_register_net_channel(current->nsproxy->net_ns, chan);
+	return ppp_register_net_channel(sysiso_current->nsproxy->net_ns, chan);
 }
 
 /* Create a new, unattached ppp channel for specified net. */
diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index 5435b5689..e61e01919 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -820,7 +820,7 @@ static int slip_open(struct tty_struct *tty)
 
 	sl->tty = tty;
 	tty->disc_data = sl;
-	sl->pid = current->pid;
+	sl->pid = sysiso_current->pid;
 
 	if (!test_bit(SLF_INUSE, &sl->flags)) {
 		/* Perform the low-level SLIP initialization. */
@@ -1247,8 +1247,8 @@ static int sl_siocdevprivate(struct net_device *dev, struct ifreq *rq,
 		/* Resolve race condition, when ioctl'ing hanged up
 		   and opened by another process device.
 		 */
-		if (sl->tty != current->signal->tty &&
-						sl->pid != current->pid) {
+		if (sl->tty != sysiso_current->signal->tty &&
+						sl->pid != sysiso_current->pid) {
 			spin_unlock_bh(&sl->lock);
 			return -EPERM;
 		}
diff --git a/drivers/net/tap.c b/drivers/net/tap.c
index 8e3a28ba6..d2ef4a709 100644
--- a/drivers/net/tap.c
+++ b/drivers/net/tap.c
@@ -498,7 +498,7 @@ static void tap_sock_destruct(struct sock *sk)
 
 static int tap_open(struct inode *inode, struct file *file)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct tap_dev *tap;
 	struct tap_queue *q;
 	int err = -ENODEV;
@@ -845,7 +845,7 @@ static ssize_t tap_do_read(struct tap_queue *q,
 			ret = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index fecc9a1d2..49d8f7c2c 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -2082,7 +2082,7 @@ static void *tun_ring_recv(struct tun_file *tfile, int noblock, int *err)
 		ptr = ptr_ring_consume(&tfile->tx_ring);
 		if (ptr)
 			break;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			error = -ERESTARTSYS;
 			break;
 		}
@@ -3344,7 +3344,7 @@ static int tun_chr_fasync(int fd, struct file *file, int on)
 		goto out;
 
 	if (on) {
-		__f_setown(file, task_pid(current), PIDTYPE_TGID, 0);
+		__f_setown(file, task_pid(sysiso_current), PIDTYPE_TGID, 0);
 		tfile->flags |= TUN_FASYNC;
 	} else
 		tfile->flags &= ~TUN_FASYNC;
@@ -3355,7 +3355,7 @@ static int tun_chr_fasync(int fd, struct file *file, int on)
 
 static int tun_chr_open(struct inode *inode, struct file * file)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct tun_file *tfile;
 
 	tfile = (struct tun_file *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,
diff --git a/drivers/net/usb/hso.c b/drivers/net/usb/hso.c
index f97813a4e..dd9da7cd1 100644
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@ -1567,7 +1567,7 @@ hso_wait_modem_status(struct hso_serial *serial, unsigned long arg)
 		}
 		schedule();
 		/* see if a signal did it */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/net/wan/cosa.c b/drivers/net/wan/cosa.c
index 23d2954d9..0fcb9d2f3 100644
--- a/drivers/net/wan/cosa.c
+++ b/drivers/net/wan/cosa.c
@@ -792,7 +792,7 @@ static ssize_t cosa_read(struct file *file,
 		spin_unlock_irqrestore(&cosa->lock, flags);
 		schedule();
 		spin_lock_irqsave(&cosa->lock, flags);
-		if (signal_pending(current) && chan->rx_status == 0) {
+		if (signal_pending(sysiso_current) && chan->rx_status == 0) {
 			chan->rx_status = 1;
 			remove_wait_queue(&chan->rxwaitq, &wait);
 			__set_current_state(TASK_RUNNING);
@@ -875,7 +875,7 @@ static ssize_t cosa_write(struct file *file,
 		spin_unlock_irqrestore(&cosa->lock, flags);
 		schedule();
 		spin_lock_irqsave(&cosa->lock, flags);
-		if (signal_pending(current) && chan->tx_status == 0) {
+		if (signal_pending(sysiso_current) && chan->tx_status == 0) {
 			chan->tx_status = 1;
 			remove_wait_queue(&chan->txwaitq, &wait);
 			__set_current_state(TASK_RUNNING);
diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index fefdc6753..3d86988cc 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -497,7 +497,7 @@ static int ath6kl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		wait_event_interruptible_timeout(ar->event_wq,
 						 ath6kl_is_tx_pending(ar),
 						 WMI_TIMEOUT);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ath6kl_err("cmd queue drain timeout\n");
 			up(&ar->sem);
 			return -EINTR;
@@ -1464,7 +1464,7 @@ static int ath6kl_cfg80211_get_txpower(struct wiphy *wiphy,
 		wait_event_interruptible_timeout(ar->event_wq, ar->tx_pwr != 255,
 						 5 * HZ);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ath6kl_err("target did not respond\n");
 			return -EINTR;
 		}
diff --git a/drivers/net/wireless/broadcom/b43legacy/main.c b/drivers/net/wireless/broadcom/b43legacy/main.c
index eec3af9c3..e4d5c84dd 100644
--- a/drivers/net/wireless/broadcom/b43legacy/main.c
+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
@@ -1726,7 +1726,7 @@ static int b43legacy_upload_microcode(struct b43legacy_wldev *dev)
 			goto error;
 		}
 		msleep_interruptible(50);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -EINTR;
 			goto error;
 		}
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
index db5f8535f..dd7f66afb 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
@@ -908,7 +908,7 @@ struct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,
 		memcpy(ifp->mac_addr, mac_addr, ETH_ALEN);
 
 	brcmf_dbg(TRACE, " ==== pid:%x, if:%s (%pM) created ===\n",
-		  current->pid, name, ifp->mac_addr);
+		  sysiso_current->pid, name, ifp->mac_addr);
 
 	return ifp;
 }
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
index 8effeb7a7..e0e18c25a 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
@@ -1734,10 +1734,10 @@ static int brcmf_sdio_dcmd_resp_wait(struct brcmf_sdio *bus, uint *condition,
 	add_wait_queue(&bus->dcmd_resp_wait, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
 
-	while (!(*condition) && (!signal_pending(current) && timeout))
+	while (!(*condition) && (!signal_pending(sysiso_current) && timeout))
 		timeout = schedule_timeout(timeout);
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		*pending = true;
 
 	set_current_state(TASK_RUNNING);
diff --git a/drivers/net/wireless/cisco/airo.c b/drivers/net/wireless/cisco/airo.c
index 65dd8cff1..0335bc08b 100644
--- a/drivers/net/wireless/cisco/airo.c
+++ b/drivers/net/wireless/cisco/airo.c
@@ -3108,7 +3108,7 @@ static int airo_thread(void *data)
 						break;
 					}
 					if (!kthread_should_stop() &&
-					    !freezing(current)) {
+					    !freezing(sysiso_current)) {
 						unsigned long wake_at;
 						if (!ai->expires || !ai->scan_timeout) {
 							wake_at = max(ai->expires,
@@ -3121,7 +3121,7 @@ static int airo_thread(void *data)
 						continue;
 					}
 				} else if (!kthread_should_stop() &&
-					   !freezing(current)) {
+					   !freezing(sysiso_current)) {
 					schedule();
 					continue;
 				}
diff --git a/drivers/net/wireless/intersil/hostap/hostap_hw.c b/drivers/net/wireless/intersil/hostap/hostap_hw.c
index 9a1904621..11eded73c 100644
--- a/drivers/net/wireless/intersil/hostap/hostap_hw.c
+++ b/drivers/net/wireless/intersil/hostap/hostap_hw.c
@@ -326,7 +326,7 @@ static int hfa384x_cmd(struct net_device *dev, u16 cmd, u16 param0,
 		return -1;
 	}
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
@@ -358,7 +358,7 @@ static int hfa384x_cmd(struct net_device *dev, u16 cmd, u16 param0,
 	if (!issue)
 		goto wait_completion;
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		err = -EINTR;
 
 	if (!err) {
@@ -375,7 +375,7 @@ static int hfa384x_cmd(struct net_device *dev, u16 cmd, u16 param0,
 	} else
 		res = -1;
 
-	if (!err && signal_pending(current))
+	if (!err && signal_pending(sysiso_current))
 		err = -EINTR;
 
 	if (err && issued) {
diff --git a/drivers/net/wireless/intersil/hostap/hostap_ioctl.c b/drivers/net/wireless/intersil/hostap/hostap_ioctl.c
index 0a376f112..d4b883a22 100644
--- a/drivers/net/wireless/intersil/hostap/hostap_ioctl.c
+++ b/drivers/net/wireless/intersil/hostap/hostap_ioctl.c
@@ -2538,7 +2538,7 @@ static int prism2_ioctl_priv_prism2_param(struct net_device *dev,
 			add_wait_queue(&local->hostscan_wq, &__wait);
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				ret = -EINTR;
 			set_current_state(TASK_RUNNING);
 			remove_wait_queue(&local->hostscan_wq, &__wait);
@@ -2892,7 +2892,7 @@ static int prism2_ioctl_priv_monitor(struct net_device *dev, int *i)
 
 	printk(KERN_DEBUG "%s: process %d (%s) used deprecated iwpriv monitor "
 	       "- update software to use iwconfig mode monitor\n",
-	       dev->name, task_pid_nr(current), current->comm);
+	       dev->name, task_pid_nr(sysiso_current), sysiso_current->comm);
 
 	/* Backward compatibility code - this can be removed at some point */
 
diff --git a/drivers/net/wireless/realtek/rtlwifi/debug.c b/drivers/net/wireless/realtek/rtlwifi/debug.c
index 901cdfe37..ac50a7ac5 100644
--- a/drivers/net/wireless/realtek/rtlwifi/debug.c
+++ b/drivers/net/wireless/realtek/rtlwifi/debug.c
@@ -35,7 +35,7 @@ void _rtl_dbg_print_data(struct rtl_priv *rtlpriv, u64 comp, int level,
 	if (unlikely(((comp) & rtlpriv->cfg->mod_params->debug_mask) &&
 		     ((level) <= rtlpriv->cfg->mod_params->debug_level))) {
 		pr_info("In process \"%s\" (pid %i): %s\n",
-			current->comm, current->pid, titlestring);
+			sysiso_current->comm, sysiso_current->pid, titlestring);
 		print_hex_dump_bytes("", DUMP_PREFIX_NONE,
 				     hexdata, hexdatalen);
 	}
diff --git a/drivers/nvdimm/region_devs.c b/drivers/nvdimm/region_devs.c
index 9ccf3d608..3ed28f4d6 100644
--- a/drivers/nvdimm/region_devs.c
+++ b/drivers/nvdimm/region_devs.c
@@ -1210,7 +1210,8 @@ int generic_nvdimm_flush(struct nd_region *nd_region)
 	 * across cpus assuming a limited number of flush hints.
 	 */
 	idx = this_cpu_read(flush_idx);
-	idx = this_cpu_add_return(flush_idx, hash_32(current->pid + idx, 8));
+	idx = this_cpu_add_return(flush_idx,
+				  hash_32(sysiso_current->pid + idx, 8));
 
 	/*
 	 * The pmem_wmb() is needed to 'sfence' all
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index f8dd664b2..2b78e75d8 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -2116,7 +2116,7 @@ static int nvme_wait_ready(struct nvme_ctrl *ctrl, u64 cap, bool enabled)
 			break;
 
 		usleep_range(1000, 2000);
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return -EINTR;
 		if (time_after(jiffies, timeout)) {
 			dev_err(ctrl->device,
@@ -2206,7 +2206,7 @@ int nvme_shutdown_ctrl(struct nvme_ctrl *ctrl)
 			break;
 
 		msleep(100);
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return -EINTR;
 		if (time_after(jiffies, timeout)) {
 			dev_err(ctrl->device,
diff --git a/drivers/nvme/host/ioctl.c b/drivers/nvme/host/ioctl.c
index 223149628..0fe76405d 100644
--- a/drivers/nvme/host/ioctl.c
+++ b/drivers/nvme/host/ioctl.c
@@ -180,7 +180,7 @@ static bool nvme_validate_passthru_nsid(struct nvme_ctrl *ctrl,
 		dev_err(ctrl->device,
 			"%s: nsid (%u) in cmd does not match nsid (%u)"
 			"of namespace\n",
-			current->comm, nsid, ns->head->ns_id);
+			sysiso_current->comm, nsid, ns->head->ns_id);
 		return false;
 	}
 
diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 6d78ec3a7..84cbd9602 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -145,7 +145,7 @@ int parport_daisy_init(struct parport *port)
 			/* Clone the port. */
 			struct parport *extra = clone_parport(port, i);
 			if (!extra) {
-				if (signal_pending(current))
+				if (signal_pending(sysiso_current))
 					break;
 
 				schedule();
diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 4547ac44c..8c006290b 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -117,7 +117,7 @@ int parport_poll_peripheral(struct parport *port,
 		status = parport_read_status (port);
 		if ((status & mask) == result)
 			return 0;
-		if (signal_pending (current))
+		if (signal_pending (sysiso_current))
 			return -EINTR;
 		if (need_resched())
 			break;
@@ -186,7 +186,7 @@ int parport_wait_peripheral(struct parport *port,
 	/* 40ms of slow polling. */
 	deadline = jiffies + msecs_to_jiffies(40);
 	while (time_before (jiffies, deadline)) {
-		if (signal_pending (current))
+		if (signal_pending (sysiso_current))
 			return -EINTR;
 
 		/* Wait for 10ms (or until an interrupt occurs if
diff --git a/drivers/parport/ieee1284_ops.c b/drivers/parport/ieee1284_ops.c
index 17061f1df..fb8fcdcc1 100644
--- a/drivers/parport/ieee1284_ops.c
+++ b/drivers/parport/ieee1284_ops.c
@@ -99,14 +99,14 @@ size_t parport_ieee1284_write_compat (struct parport *port,
 				parport_wait_event (port, wait);
 
 			/* Is there a signal pending? */
-			if (signal_pending (current))
+			if (signal_pending (sysiso_current))
 				break;
 
 			/* Wait longer next time. */
 			wait *= 2;
 		} while (time_before (jiffies, expire));
 
-		if (signal_pending (current))
+		if (signal_pending (sysiso_current))
 			break;
 
 		pr_debug("%s: Timed out\n", port->name);
@@ -425,7 +425,7 @@ size_t parport_ieee1284_ecp_write_data (struct parport *port,
 						      PARPORT_STATUS_BUSY, 0))
 				goto success;
 
-			if (signal_pending (current)) {
+			if (signal_pending (sysiso_current)) {
 				parport_frob_control (port,
 						      PARPORT_CONTROL_STROBE,
 						      0);
@@ -528,7 +528,7 @@ size_t parport_ieee1284_ecp_read_data (struct parport *port,
 				parport_wait_event (port, msecs_to_jiffies(40));
 
 			/* Is there a signal pending? */
-			if (signal_pending (current))
+			if (signal_pending (sysiso_current))
 				goto out;
 		}
 
@@ -656,7 +656,7 @@ size_t parport_ieee1284_ecp_write_addr (struct parport *port,
 						      PARPORT_STATUS_BUSY, 0))
 				goto success;
 
-			if (signal_pending (current)) {
+			if (signal_pending (sysiso_current)) {
 				parport_frob_control (port,
 						      PARPORT_CONTROL_STROBE,
 						      0);
diff --git a/drivers/parport/parport_ip32.c b/drivers/parport/parport_ip32.c
index 0919ed99b..bba378251 100644
--- a/drivers/parport/parport_ip32.c
+++ b/drivers/parport/parport_ip32.c
@@ -1243,7 +1243,7 @@ static unsigned int parport_ip32_fifo_wait_break(struct parport *p,
 		pr_debug1(PPIP32 "%s: FIFO write timed out\n", p->name);
 		return 1;
 	}
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		pr_debug1(PPIP32 "%s: Signal pending\n", p->name);
 		return 1;
 	}
@@ -1501,7 +1501,7 @@ static unsigned int parport_ip32_drain_fifo(struct parport *p,
 			break;
 		if (time_after(jiffies, expire))
 			break;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		udelay(5);
 	}
@@ -1512,7 +1512,7 @@ static unsigned int parport_ip32_drain_fifo(struct parport *p,
 		if (time_after_eq(jiffies, expire))
 			break;
 		msleep_interruptible(polling_interval);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		if (polling_interval < 128)
 			polling_interval *= 2;
diff --git a/drivers/parport/parport_pc.c b/drivers/parport/parport_pc.c
index eda4ded4d..95b388f6c 100644
--- a/drivers/parport/parport_pc.c
+++ b/drivers/parport/parport_pc.c
@@ -160,7 +160,7 @@ static int change_mode(struct parport *p, int m)
 			for (counter = 0; counter < 40; counter++) {
 				if (inb(ECONTROL(p)) & 0x01)
 					break;
-				if (signal_pending(current))
+				if (signal_pending(sysiso_current))
 					break;
 				udelay(5);
 			}
@@ -172,7 +172,7 @@ static int change_mode(struct parport *p, int m)
 					return -EBUSY;
 				schedule_timeout_interruptible(
 							msecs_to_jiffies(10));
-				if (signal_pending(current))
+				if (signal_pending(sysiso_current))
 					break;
 			}
 		}
@@ -529,7 +529,7 @@ static size_t parport_pc_fifo_write_block_pio(struct parport *port,
 		expire = jiffies + port->cad->timeout;
 
 poll:
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		if (ecrval & 0x01) {
diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 62f840792..7e04dbb44 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -1121,7 +1121,7 @@ int parport_claim_or_block(struct pardevice *dev)
 		if (dev->waiting) {
 			wait_event_interruptible(dev->wait_q,
 						 !dev->waiting);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -EINTR;
 			r = 1;
 		} else {
diff --git a/drivers/pci/hotplug/cpci_hotplug_core.c b/drivers/pci/hotplug/cpci_hotplug_core.c
index d0559d2fa..390134c33 100644
--- a/drivers/pci/hotplug/cpci_hotplug_core.c
+++ b/drivers/pci/hotplug/cpci_hotplug_core.c
@@ -469,7 +469,7 @@ poll_thread(void *data)
 	int rc;
 
 	while (1) {
-		if (kthread_should_stop() || signal_pending(current))
+		if (kthread_should_stop() || signal_pending(sysiso_current))
 			break;
 		if (controller->ops->query_enum()) {
 			do {
diff --git a/drivers/pci/hotplug/cpqphp.h b/drivers/pci/hotplug/cpqphp.h
index 77e4e0142..5647d615f 100644
--- a/drivers/pci/hotplug/cpqphp.h
+++ b/drivers/pci/hotplug/cpqphp.h
@@ -711,7 +711,7 @@ static inline int wait_for_ctrl_irq(struct controller *ctrl)
 	/* Sleep for up to 1 second to wait for the LED to change. */
 	msleep_interruptible(1000);
 	remove_wait_queue(&ctrl->queue, &wait);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		retval =  -EINTR;
 
 	dbg("%s - end\n", __func__);
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 4537d1ea1..f00167f15 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -36,7 +36,8 @@ static ktime_t fixup_debug_start(struct pci_dev *dev,
 				 void (*fn)(struct pci_dev *dev))
 {
 	if (initcall_debug)
-		pci_info(dev, "calling  %pS @ %i\n", fn, task_pid_nr(current));
+		pci_info(dev, "calling  %pS @ %i\n", fn,
+			 task_pid_nr(sysiso_current));
 
 	return ktime_get();
 }
diff --git a/drivers/pci/vpd.c b/drivers/pci/vpd.c
index 4be248901..286ea9e26 100644
--- a/drivers/pci/vpd.c
+++ b/drivers/pci/vpd.c
@@ -184,7 +184,7 @@ static ssize_t pci_vpd_read(struct pci_dev *dev, loff_t pos, size_t count,
 		u32 val;
 		unsigned int i, skip;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
diff --git a/drivers/platform/x86/intel/speed_select_if/isst_if_common.c b/drivers/platform/x86/intel/speed_select_if/isst_if_common.c
index c9a85eb2e..5e8ae3065 100644
--- a/drivers/platform/x86/intel/speed_select_if/isst_if_common.c
+++ b/drivers/platform/x86/intel/speed_select_if/isst_if_common.c
@@ -528,7 +528,7 @@ static long isst_if_exec_multi_cmd(void __user *argp, struct isst_if_cmd_cb *cb)
 	for (i = 0; i < cmd_count; ++i) {
 		int wr_only;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
diff --git a/drivers/rapidio/devices/rio_mport_cdev.c b/drivers/rapidio/devices/rio_mport_cdev.c
index 94331d999..55e0edcab 100644
--- a/drivers/rapidio/devices/rio_mport_cdev.c
+++ b/drivers/rapidio/devices/rio_mport_cdev.c
@@ -709,7 +709,7 @@ static int do_dma_request(struct mport_dma_req *req,
 	dir = (req->dir == DMA_FROM_DEVICE) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;
 
 	rmcd_debug(DMA, "%s(%d) uses %s for DMA_%s",
-		   current->comm, task_pid_nr(current),
+		   sysiso_current->comm, task_pid_nr(sysiso_current),
 		   dev_name(&chan->dev->device),
 		   (dir == DMA_DEV_TO_MEM)?"READ":"WRITE");
 
@@ -740,7 +740,8 @@ static int do_dma_request(struct mport_dma_req *req,
 	cookie = dmaengine_submit(tx);
 	req->cookie = cookie;
 
-	rmcd_debug(DMA, "pid=%d DMA_%s tx_cookie = %d", task_pid_nr(current),
+	rmcd_debug(DMA, "pid=%d DMA_%s tx_cookie = %d",
+		   task_pid_nr(sysiso_current),
 		   (dir == DMA_DEV_TO_MEM)?"READ":"WRITE", cookie);
 
 	if (dma_submit_error(cookie)) {
@@ -766,7 +767,7 @@ static int do_dma_request(struct mport_dma_req *req,
 	if (wret == 0) {
 		/* Timeout on wait occurred */
 		rmcd_error("%s(%d) timed out waiting for DMA_%s %d",
-		       current->comm, task_pid_nr(current),
+		       sysiso_current->comm, task_pid_nr(sysiso_current),
 		       (dir == DMA_DEV_TO_MEM)?"READ":"WRITE", cookie);
 		return -ETIMEDOUT;
 	} else if (wret == -ERESTARTSYS) {
@@ -774,7 +775,7 @@ static int do_dma_request(struct mport_dma_req *req,
 		 * be in progress
 		 */
 		rmcd_error("%s(%d) wait for DMA_%s %d was interrupted",
-			current->comm, task_pid_nr(current),
+			sysiso_current->comm, task_pid_nr(sysiso_current),
 			(dir == DMA_DEV_TO_MEM)?"READ":"WRITE", cookie);
 		return -EINTR;
 	}
@@ -782,7 +783,7 @@ static int do_dma_request(struct mport_dma_req *req,
 	if (req->status != DMA_COMPLETE) {
 		/* DMA transaction completion was signaled with error */
 		rmcd_error("%s(%d) DMA_%s %d completed with status %d (ret=%d)",
-			current->comm, task_pid_nr(current),
+			sysiso_current->comm, task_pid_nr(sysiso_current),
 			(dir == DMA_DEV_TO_MEM)?"READ":"WRITE",
 			cookie, req->status, ret);
 		ret = -EIO;
@@ -1044,7 +1045,7 @@ static int rio_mport_wait_for_async_dma(struct file *filp, void __user *arg)
 	if (wret == 0) {
 		/* Timeout on wait occurred */
 		rmcd_error("%s(%d) timed out waiting for ASYNC DMA_%s",
-		       current->comm, task_pid_nr(current),
+		       sysiso_current->comm, task_pid_nr(sysiso_current),
 		       (req->dir == DMA_FROM_DEVICE)?"READ":"WRITE");
 		ret = -ETIMEDOUT;
 		goto err_tmo;
@@ -1053,7 +1054,7 @@ static int rio_mport_wait_for_async_dma(struct file *filp, void __user *arg)
 		 * be still in progress
 		 */
 		rmcd_error("%s(%d) wait for ASYNC DMA_%s was interrupted",
-			current->comm, task_pid_nr(current),
+			sysiso_current->comm, task_pid_nr(sysiso_current),
 			(req->dir == DMA_FROM_DEVICE)?"READ":"WRITE");
 		ret = -EINTR;
 		goto err_tmo;
@@ -1062,7 +1063,7 @@ static int rio_mport_wait_for_async_dma(struct file *filp, void __user *arg)
 	if (req->status != DMA_COMPLETE) {
 		/* DMA transaction completion signaled with transfer error */
 		rmcd_error("%s(%d) ASYNC DMA_%s completion with status %d",
-			current->comm, task_pid_nr(current),
+			sysiso_current->comm, task_pid_nr(sysiso_current),
 			(req->dir == DMA_FROM_DEVICE)?"READ":"WRITE",
 			req->status);
 		ret = -EIO;
@@ -1949,7 +1950,7 @@ static void mport_cdev_release_dma(struct file *filp)
 	LIST_HEAD(list);
 
 	rmcd_debug(EXIT, "from filp=%p %s(%d)",
-		   filp, current->comm, task_pid_nr(current));
+		   filp, sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	if (!priv->dmach) {
 		rmcd_debug(EXIT, "No DMA channel for filp=%p", filp);
@@ -1961,7 +1962,7 @@ static void mport_cdev_release_dma(struct file *filp)
 	spin_lock(&priv->req_lock);
 	if (!list_empty(&priv->async_list)) {
 		rmcd_debug(EXIT, "async list not empty filp=%p %s(%d)",
-			   filp, current->comm, task_pid_nr(current));
+			   filp, sysiso_current->comm, task_pid_nr(sysiso_current));
 		list_splice_init(&priv->async_list, &list);
 	}
 	spin_unlock(&priv->req_lock);
@@ -1982,12 +1983,12 @@ static void mport_cdev_release_dma(struct file *filp)
 
 	if (wret <= 0) {
 		rmcd_error("%s(%d) failed waiting for DMA release err=%ld",
-			current->comm, task_pid_nr(current), wret);
+			sysiso_current->comm, task_pid_nr(sysiso_current), wret);
 	}
 
 	if (priv->dmach != priv->md->dma_chan) {
 		rmcd_debug(EXIT, "Release DMA channel for filp=%p %s(%d)",
-			   filp, current->comm, task_pid_nr(current));
+			   filp, sysiso_current->comm, task_pid_nr(sysiso_current));
 		rio_release_dma(priv->dmach);
 	} else {
 		rmcd_debug(EXIT, "Adjust default DMA channel refcount");
diff --git a/drivers/rapidio/devices/tsi721_dma.c b/drivers/rapidio/devices/tsi721_dma.c
index d375c0205..72f42f316 100644
--- a/drivers/rapidio/devices/tsi721_dma.c
+++ b/drivers/rapidio/devices/tsi721_dma.c
@@ -312,13 +312,13 @@ static void tsi721_start_dma(struct tsi721_bdma_chan *bdma_chan)
 	if (bdma_chan->wr_count == bdma_chan->wr_count_next) {
 		tsi_err(&bdma_chan->dchan.dev->device,
 			"DMAC%d Attempt to start DMA with no BDs ready %d",
-			bdma_chan->id, task_pid_nr(current));
+			bdma_chan->id, task_pid_nr(sysiso_current));
 		return;
 	}
 
 	tsi_debug(DMA, &bdma_chan->dchan.dev->device, "DMAC%d (wrc=%d) %d",
 		  bdma_chan->id, bdma_chan->wr_count_next,
-		  task_pid_nr(current));
+		  task_pid_nr(sysiso_current));
 
 	iowrite32(bdma_chan->wr_count_next,
 		bdma_chan->regs + TSI721_DMAC_DWRCNT);
diff --git a/drivers/rapidio/rio_cm.c b/drivers/rapidio/rio_cm.c
index db4c26528..80ebf56fa 100644
--- a/drivers/rapidio/rio_cm.c
+++ b/drivers/rapidio/rio_cm.c
@@ -789,8 +789,8 @@ static int riocm_ch_send(u16 ch_id, void *buf, int len)
 
 	ch = riocm_get_channel(ch_id);
 	if (!ch) {
-		riocm_error("%s(%d) ch_%d not found", current->comm,
-			    task_pid_nr(current), ch_id);
+		riocm_error("%s(%d) ch_%d not found", sysiso_current->comm,
+			    task_pid_nr(sysiso_current), ch_id);
 		return -ENODEV;
 	}
 
@@ -1439,7 +1439,7 @@ static int riocm_ch_close(struct rio_channel *ch)
 	int ret = 0;
 
 	riocm_debug(CHOP, "ch_%d by %s(%d)",
-		    ch->id, current->comm, task_pid_nr(current));
+		    ch->id, sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	state = riocm_exch(ch, RIO_CM_DESTROYING);
 	if (state == RIO_CM_CONNECTED)
@@ -1455,12 +1455,12 @@ static int riocm_ch_close(struct rio_channel *ch)
 	if (wret == 0) {
 		/* Timeout on wait occurred */
 		riocm_debug(CHOP, "%s(%d) timed out waiting for ch %d",
-		       current->comm, task_pid_nr(current), ch->id);
+		       sysiso_current->comm, task_pid_nr(sysiso_current), ch->id);
 		ret = -ETIMEDOUT;
 	} else if (wret == -ERESTARTSYS) {
 		/* Wait_for_completion was interrupted by a signal */
 		riocm_debug(CHOP, "%s(%d) wait for ch %d was interrupted",
-			current->comm, task_pid_nr(current), ch->id);
+			sysiso_current->comm, task_pid_nr(sysiso_current), ch->id);
 		ret = -EINTR;
 	}
 
@@ -1480,7 +1480,7 @@ static int riocm_ch_close(struct rio_channel *ch)
 static int riocm_cdev_open(struct inode *inode, struct file *filp)
 {
 	riocm_debug(INIT, "by %s(%d) filp=%p ",
-		    current->comm, task_pid_nr(current), filp);
+		    sysiso_current->comm, task_pid_nr(sysiso_current), filp);
 
 	if (list_empty(&cm_dev_list))
 		return -ENODEV;
@@ -1498,15 +1498,15 @@ static int riocm_cdev_release(struct inode *inode, struct file *filp)
 	LIST_HEAD(list);
 
 	riocm_debug(EXIT, "by %s(%d) filp=%p",
-		    current->comm, task_pid_nr(current), filp);
+		    sysiso_current->comm, task_pid_nr(sysiso_current), filp);
 
 	/* Check if there are channels associated with this file descriptor */
 	spin_lock_bh(&idr_lock);
 	idr_for_each_entry(&ch_idr, ch, i) {
 		if (ch && ch->filp == filp) {
 			riocm_debug(EXIT, "ch_%d not released by %s(%d)",
-				    ch->id, current->comm,
-				    task_pid_nr(current));
+				    ch->id, sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 			idr_remove(&ch_idr, ch->id);
 			list_add(&ch->ch_node, &list);
 		}
@@ -1663,14 +1663,14 @@ static int cm_chan_create(struct file *filp, void __user *arg)
 		return -EFAULT;
 
 	riocm_debug(CHOP, "ch_%d requested by %s(%d)",
-		    ch_num, current->comm, task_pid_nr(current));
+		    ch_num, sysiso_current->comm, task_pid_nr(sysiso_current));
 	ch = riocm_ch_create(&ch_num);
 	if (IS_ERR(ch))
 		return PTR_ERR(ch);
 
 	ch->filp = filp;
 	riocm_debug(CHOP, "ch_%d created by %s(%d)",
-		    ch_num, current->comm, task_pid_nr(current));
+		    ch_num, sysiso_current->comm, task_pid_nr(sysiso_current));
 	return put_user(ch_num, p);
 }
 
@@ -1689,7 +1689,7 @@ static int cm_chan_close(struct file *filp, void __user *arg)
 		return -EFAULT;
 
 	riocm_debug(CHOP, "ch_%d by %s(%d)",
-		    ch_num, current->comm, task_pid_nr(current));
+		    ch_num, sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	spin_lock_bh(&idr_lock);
 	ch = idr_find(&ch_idr, ch_num);
@@ -1753,7 +1753,7 @@ static int cm_chan_accept(struct file *filp, void __user *arg)
 		return -EFAULT;
 
 	riocm_debug(CHOP, "on ch_%d by %s(%d)",
-		    param.ch_num, current->comm, task_pid_nr(current));
+		    param.ch_num, sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	accept_to = param.wait_to ?
 			msecs_to_jiffies(param.wait_to) : 0;
@@ -1764,7 +1764,7 @@ static int cm_chan_accept(struct file *filp, void __user *arg)
 	ch->filp = filp;
 
 	riocm_debug(CHOP, "new ch_%d for %s(%d)",
-		    ch->id, current->comm, task_pid_nr(current));
+		    ch->id, sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	if (copy_to_user(arg, &param, sizeof(param)))
 		return -EFAULT;
diff --git a/drivers/rtc/dev.c b/drivers/rtc/dev.c
index 5b8ebe861..d5d9c7c35 100644
--- a/drivers/rtc/dev.c
+++ b/drivers/rtc/dev.c
@@ -167,7 +167,7 @@ rtc_dev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 			ret = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/s390/char/fs3270.c b/drivers/s390/char/fs3270.c
index 4c4683d87..03aec1e2c 100644
--- a/drivers/s390/char/fs3270.c
+++ b/drivers/s390/char/fs3270.c
@@ -462,7 +462,7 @@ fs3270_open(struct inode *inode, struct file *filp)
 	}
 
 	init_waitqueue_head(&fp->wait);
-	fp->fs_pid = get_pid(task_pid(current));
+	fp->fs_pid = get_pid(task_pid(sysiso_current));
 	rc = raw3270_add_view(&fp->view, &fs3270_fn, minor,
 			      RAW3270_VIEW_LOCK_BH);
 	if (rc) {
diff --git a/drivers/s390/char/keyboard.c b/drivers/s390/char/keyboard.c
index 567aedc03..5cf25b564 100644
--- a/drivers/s390/char/keyboard.c
+++ b/drivers/s390/char/keyboard.c
@@ -489,7 +489,7 @@ int kbd_ioctl(struct kbd_data *kbd, unsigned int cmd, unsigned long arg)
 	 */
 	tty = tty_port_tty_get(kbd->port);
 	/* FIXME this test is pretty racy */
-	perm = current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG);
+	perm = sysiso_current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG);
 	tty_kref_put(tty);
 	switch (cmd) {
 	case KDGKBTYPE:
diff --git a/drivers/s390/cio/device.c b/drivers/s390/cio/device.c
index 8d1456982..08dbe43c3 100644
--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@ -1334,7 +1334,7 @@ static int purge_fn(struct device *dev, void *data)
 	}
 	spin_unlock_irq(cdev->ccwlock);
 	/* Abort loop in case of pending signal. */
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	return 0;
diff --git a/drivers/s390/crypto/zcrypt_msgtype50.c b/drivers/s390/crypto/zcrypt_msgtype50.c
index 99937f3e1..d85a0ded9 100644
--- a/drivers/s390/crypto/zcrypt_msgtype50.c
+++ b/drivers/s390/crypto/zcrypt_msgtype50.c
@@ -477,7 +477,7 @@ static long zcrypt_cex2a_modexpo(struct zcrypt_queue *zq,
 	if (!ap_msg->msg)
 		return -ENOMEM;
 	ap_msg->receive = zcrypt_cex2a_receive;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 		atomic_inc_return(&zcrypt_step);
 	ap_msg->private = &work;
 	rc = ICAMEX_msg_to_type50MEX_msg(zq, ap_msg, mex);
@@ -522,7 +522,7 @@ static long zcrypt_cex2a_modexpo_crt(struct zcrypt_queue *zq,
 	if (!ap_msg->msg)
 		return -ENOMEM;
 	ap_msg->receive = zcrypt_cex2a_receive;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 		atomic_inc_return(&zcrypt_step);
 	ap_msg->private = &work;
 	rc = ICACRT_msg_to_type50CRT_msg(zq, ap_msg, crt);
diff --git a/drivers/s390/crypto/zcrypt_msgtype6.c b/drivers/s390/crypto/zcrypt_msgtype6.c
index bc5a8c31b..40607f9c4 100644
--- a/drivers/s390/crypto/zcrypt_msgtype6.c
+++ b/drivers/s390/crypto/zcrypt_msgtype6.c
@@ -1036,7 +1036,7 @@ static long zcrypt_msgtype6_modexpo(struct zcrypt_queue *zq,
 		return -ENOMEM;
 	ap_msg->bufsize = PAGE_SIZE;
 	ap_msg->receive = zcrypt_msgtype6_receive;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 		atomic_inc_return(&zcrypt_step);
 	ap_msg->private = &resp_type;
 	rc = ICAMEX_msg_to_type6MEX_msgX(zq, ap_msg, mex);
@@ -1084,7 +1084,7 @@ static long zcrypt_msgtype6_modexpo_crt(struct zcrypt_queue *zq,
 		return -ENOMEM;
 	ap_msg->bufsize = PAGE_SIZE;
 	ap_msg->receive = zcrypt_msgtype6_receive;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 		atomic_inc_return(&zcrypt_step);
 	ap_msg->private = &resp_type;
 	rc = ICACRT_msg_to_type6CRT_msgX(zq, ap_msg, crt);
@@ -1132,7 +1132,7 @@ unsigned int get_cprb_fc(bool userspace, struct ica_xcRB *xcRB,
 	if (!ap_msg->msg)
 		return -ENOMEM;
 	ap_msg->receive = zcrypt_msgtype6_receive;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 				atomic_inc_return(&zcrypt_step);
 	ap_msg->private = kmemdup(&resp_type, sizeof(resp_type), GFP_KERNEL);
 	if (!ap_msg->private)
@@ -1190,7 +1190,7 @@ unsigned int get_ep11cprb_fc(bool userspace, struct ep11_urb *xcrb,
 	if (!ap_msg->msg)
 		return -ENOMEM;
 	ap_msg->receive = zcrypt_msgtype6_receive_ep11;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 				atomic_inc_return(&zcrypt_step);
 	ap_msg->private = kmemdup(&resp_type, sizeof(resp_type), GFP_KERNEL);
 	if (!ap_msg->private)
@@ -1287,7 +1287,7 @@ unsigned int get_rng_fc(struct ap_message *ap_msg, int *func_code,
 	if (!ap_msg->msg)
 		return -ENOMEM;
 	ap_msg->receive = zcrypt_msgtype6_receive;
-	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
+	ap_msg->psmid = (((unsigned long long) sysiso_current->pid) << 32) +
 				atomic_inc_return(&zcrypt_step);
 	ap_msg->private = kmemdup(&resp_type, sizeof(resp_type), GFP_KERNEL);
 	if (!ap_msg->private)
diff --git a/drivers/sbus/char/envctrl.c b/drivers/sbus/char/envctrl.c
index 843e830b5..70a4e99ee 100644
--- a/drivers/sbus/char/envctrl.c
+++ b/drivers/sbus/char/envctrl.c
@@ -995,7 +995,7 @@ static int kenvctrld(void *__unused)
 
 	poll_interval = 5000; /* TODO env_mon_interval */
 
-	printk(KERN_INFO PFX "%s starting...\n", current->comm);
+	printk(KERN_INFO PFX "%s starting...\n", sysiso_current->comm);
 	for (;;) {
 		msleep_interruptible(poll_interval);
 
@@ -1010,14 +1010,14 @@ static int kenvctrld(void *__unused)
 					printk(KERN_CRIT 
 						"%s: WARNING: CPU%i temperature %i C meets or exceeds "\
 						"shutdown threshold %i C\n", 
-						current->comm, whichcpu, 
+						sysiso_current->comm, whichcpu, 
 						tempbuf[0], shutdown_temperature);
 					envctrl_do_shutdown();
 				}
 			}
 		}
 	}
-	printk(KERN_INFO PFX "%s exiting...\n", current->comm);
+	printk(KERN_INFO PFX "%s exiting...\n", sysiso_current->comm);
 	return 0;
 }
 
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index deb32c9f4..0b5100066 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -1494,7 +1494,7 @@ static int _aac_reset_adapter(struct aac_dev *aac, int forced, u8 reset_type)
 	 *	  commands are completing in the interrupt service.
 	 */
 	aac_adapter_disable_int(aac);
-	if (aac->thread && aac->thread->pid != current->pid) {
+	if (aac->thread && aac->thread->pid != sysiso_current->pid) {
 		spin_unlock_irq(host->host_lock);
 		kthread_stop(aac->thread);
 		aac->thread = NULL;
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 8863a74e6..08239f94e 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -985,7 +985,7 @@ static void bnx2fc_indicate_netevent(void *context, unsigned long event,
 				hba->num_ofld_sess);
 		hba->wait_for_link_down = 0;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			flush_signals(current);
 	}
 }
@@ -1950,7 +1950,7 @@ static void bnx2fc_fw_destroy(struct bnx2fc_hba *hba)
 						 &hba->flags));
 			clear_bit(BNX2FC_FLAG_DESTROY_CMPL, &hba->flags);
 			/* This should never happen */
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				flush_signals(current);
 
 			del_timer_sync(&hba->destroy_timer);
diff --git a/drivers/scsi/bnx2fc/bnx2fc_tgt.c b/drivers/scsi/bnx2fc/bnx2fc_tgt.c
index 9200b7180..65856f0bf 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_tgt.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_tgt.c
@@ -72,7 +72,7 @@ static void bnx2fc_ofld_wait(struct bnx2fc_rport *tgt)
 				 (test_bit(
 				  BNX2FC_FLAG_OFLD_REQ_CMPL,
 				  &tgt->flags)));
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&tgt->ofld_timer);
 }
@@ -283,7 +283,7 @@ static void bnx2fc_upld_wait(struct bnx2fc_rport *tgt)
 				 (test_bit(
 				  BNX2FC_FLAG_UPLD_REQ_COMPL,
 				  &tgt->flags)));
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&tgt->upld_timer);
 }
diff --git a/drivers/scsi/bnx2i/bnx2i_iscsi.c b/drivers/scsi/bnx2i/bnx2i_iscsi.c
index 1b5f3e143..bb0af752b 100644
--- a/drivers/scsi/bnx2i/bnx2i_iscsi.c
+++ b/drivers/scsi/bnx2i/bnx2i_iscsi.c
@@ -1624,7 +1624,7 @@ static int bnx2i_conn_start(struct iscsi_cls_conn *cls_conn)
 	wait_event_interruptible(bnx2i_conn->ep->ofld_wait,
 			bnx2i_conn->ep->state != EP_STATE_ULP_UPDATE_START);
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&bnx2i_conn->ep->ofld_timer);
 
@@ -1747,7 +1747,7 @@ static int bnx2i_tear_down_conn(struct bnx2i_hba *hba,
 	wait_event_interruptible(ep->ofld_wait,
 				 (ep->state != EP_STATE_CLEANUP_START));
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&ep->ofld_timer);
 
@@ -1859,7 +1859,7 @@ static struct iscsi_endpoint *bnx2i_ep_connect(struct Scsi_Host *shost,
 	wait_event_interruptible(bnx2i_ep->ofld_wait,
 				 bnx2i_ep->state != EP_STATE_OFLD_START);
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&bnx2i_ep->ofld_timer);
 
@@ -2098,7 +2098,7 @@ int bnx2i_hw_ep_disconnect(struct bnx2i_endpoint *bnx2i_ep)
 				((bnx2i_ep->state != EP_STATE_DISCONN_START)
 				&& (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD)));
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&bnx2i_ep->ofld_timer);
 
diff --git a/drivers/scsi/cxlflash/ocxl_hw.c b/drivers/scsi/cxlflash/ocxl_hw.c
index 244fc2721..049eab92e 100644
--- a/drivers/scsi/cxlflash/ocxl_hw.c
+++ b/drivers/scsi/cxlflash/ocxl_hw.c
@@ -1043,7 +1043,7 @@ static ssize_t afu_read(struct file *file, char __user *buf, size_t count,
 			goto err;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			dev_err(dev, "%s: Signal pending on the process\n",
 				__func__);
 			rc = -ERESTARTSYS;
diff --git a/drivers/scsi/cxlflash/superpipe.c b/drivers/scsi/cxlflash/superpipe.c
index df0ebabbf..5e4d5972b 100644
--- a/drivers/scsi/cxlflash/superpipe.c
+++ b/drivers/scsi/cxlflash/superpipe.c
@@ -162,7 +162,7 @@ struct ctx_info *get_context(struct cxlflash_cfg *cfg, u64 rctxid,
 	struct llun_info *lli = arg;
 	u64 ctxid = DECODE_CTXID(rctxid);
 	int rc;
-	pid_t pid = task_tgid_nr(current), ctxpid = 0;
+	pid_t pid = task_tgid_nr(sysiso_current), ctxpid = 0;
 
 	if (ctx_ctrl & CTX_CTRL_FILE) {
 		lli = NULL;
@@ -170,7 +170,7 @@ struct ctx_info *get_context(struct cxlflash_cfg *cfg, u64 rctxid,
 	}
 
 	if (ctx_ctrl & CTX_CTRL_CLONE)
-		pid = task_ppid_nr(current);
+		pid = task_ppid_nr(sysiso_current);
 
 	if (likely(ctxid < MAX_CONTEXT)) {
 		while (true) {
@@ -831,7 +831,7 @@ static void init_context(struct ctx_info *ctxi, struct cxlflash_cfg *cfg,
 	ctxi->ctrl_map = &afu->afu_map->ctrls[ctxid].ctrl;
 	ctxi->ctxid = ENCODE_CTXID(ctxi, ctxid);
 	ctxi->irqs = irqs;
-	ctxi->pid = task_tgid_nr(current); /* tgid = pid */
+	ctxi->pid = task_tgid_nr(sysiso_current); /* tgid = pid */
 	ctxi->ctx = ctx;
 	ctxi->cfg = cfg;
 	ctxi->file = file;
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 5bc91d34d..bb17a5eea 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1872,7 +1872,7 @@ static int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,
 	wait_event_interruptible(session->ehwait, age != session->age ||
 				 session->state != ISCSI_STATE_LOGGED_IN ||
 				 session->tmf_state != TMF_QUEUED);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 	del_timer_sync(&session->tmf_timer);
 
@@ -2527,7 +2527,7 @@ int iscsi_eh_session_reset(struct scsi_cmnd *sc)
 				 session->state == ISCSI_STATE_TERMINATE ||
 				 session->state == ISCSI_STATE_LOGGED_IN ||
 				 session->state == ISCSI_STATE_RECOVERY_FAILED);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 
 	mutex_lock(&session->eh_mutex);
@@ -2843,7 +2843,7 @@ void iscsi_host_remove(struct Scsi_Host *shost)
 	iscsi_host_for_each_session(shost, iscsi_notify_host_removed);
 	wait_event_interruptible(ihost->session_removal_wq,
 				 ihost->num_sessions == 0);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 
 	scsi_remove_host(shost);
diff --git a/drivers/scsi/libsas/sas_discover.c b/drivers/scsi/libsas/sas_discover.c
index 12e1e36d7..ef22022aa 100644
--- a/drivers/scsi/libsas/sas_discover.c
+++ b/drivers/scsi/libsas/sas_discover.c
@@ -444,7 +444,7 @@ static void sas_discover_domain(struct work_struct *work)
 	dev = port->port_dev;
 
 	pr_debug("DOING DISCOVERY on port %d, pid:%d\n", port->id,
-		 task_pid_nr(current));
+		 task_pid_nr(sysiso_current));
 
 	switch (dev->dev_type) {
 	case SAS_END_DEVICE:
@@ -484,7 +484,7 @@ static void sas_discover_domain(struct work_struct *work)
 	sas_probe_devices(port);
 
 	pr_debug("DONE DISCOVERY on port %d, pid:%d, result:%d\n", port->id,
-		 task_pid_nr(current), error);
+		 task_pid_nr(sysiso_current), error);
 }
 
 static void sas_revalidate_domain(struct work_struct *work)
@@ -499,20 +499,20 @@ static void sas_revalidate_domain(struct work_struct *work)
 	mutex_lock(&ha->disco_mutex);
 	if (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {
 		pr_debug("REVALIDATION DEFERRED on port %d, pid:%d\n",
-			 port->id, task_pid_nr(current));
+			 port->id, task_pid_nr(sysiso_current));
 		goto out;
 	}
 
 	clear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);
 
 	pr_debug("REVALIDATING DOMAIN on port %d, pid:%d\n", port->id,
-		 task_pid_nr(current));
+		 task_pid_nr(sysiso_current));
 
 	if (ddev && dev_is_expander(ddev->dev_type))
 		res = sas_ex_revalidate_domain(ddev);
 
 	pr_debug("done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\n",
-		 port->id, task_pid_nr(current), res);
+		 port->id, task_pid_nr(sysiso_current), res);
  out:
 	mutex_unlock(&ha->disco_mutex);
 
diff --git a/drivers/scsi/lpfc/lpfc_bsg.c b/drivers/scsi/lpfc/lpfc_bsg.c
index fdf08cb57..75d64806d 100644
--- a/drivers/scsi/lpfc/lpfc_bsg.c
+++ b/drivers/scsi/lpfc/lpfc_bsg.c
@@ -2644,8 +2644,8 @@ static int lpfcdiag_loop_get_xri(struct lpfc_hba *phba, uint16_t rpi,
 
 	*txxri = 0;
 	*rxxri = 0;
-	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,
-				SLI_CT_ELX_LOOPBACK);
+	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, sysiso_current->pid,
+				 SLI_CT_ELX_LOOPBACK);
 	if (!evt)
 		return -ENOMEM;
 
@@ -3191,8 +3191,8 @@ lpfc_bsg_diag_loopback_run(struct bsg_job *job)
 			goto loopback_test_exit;
 		}
 	}
-	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,
-				SLI_CT_ELX_LOOPBACK);
+	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, sysiso_current->pid,
+				 SLI_CT_ELX_LOOPBACK);
 	if (!evt) {
 		lpfcdiag_loop_self_unreg(phba, rpi);
 		rc = -ENOMEM;
diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c
index 7195ca027..cab74eb0c 100644
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -900,7 +900,7 @@ lpfc_do_work(void *p)
 	int rc;
 
 	set_user_nice(current, MIN_NICE);
-	current->flags |= PF_NOFREEZE;
+	sysiso_current->flags |= PF_NOFREEZE;
 	phba->data_flags = 0;
 
 	while (!kthread_should_stop()) {
diff --git a/drivers/scsi/lpfc/lpfc_vport.c b/drivers/scsi/lpfc/lpfc_vport.c
index da9a1f72d..46a484cfb 100644
--- a/drivers/scsi/lpfc/lpfc_vport.c
+++ b/drivers/scsi/lpfc/lpfc_vport.c
@@ -144,7 +144,7 @@ lpfc_vport_sparm(struct lpfc_hba *phba, struct lpfc_vport *vport)
 	pmb->vport = vport;
 	rc = lpfc_sli_issue_mbox_wait(phba, pmb, phba->fc_ratov * 2);
 	if (rc != MBX_SUCCESS) {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			lpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,
 					 "1830 Signal aborted mbxCmd x%x\n",
 					 mb->mbxCommand);
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index b6c86cce5..04f74300d 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -1249,7 +1249,7 @@ int scsi_eh_get_sense(struct list_head *work_q,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				scmd_printk(KERN_INFO, scmd,
 					    "%s: skip request sense, past eh deadline\n",
-					     current->comm));
+					     sysiso_current->comm));
 			break;
 		}
 		if (!scsi_status_is_check_condition(scmd->result))
@@ -1263,7 +1263,7 @@ int scsi_eh_get_sense(struct list_head *work_q,
 
 		SCSI_LOG_ERROR_RECOVERY(2, scmd_printk(KERN_INFO, scmd,
 						  "%s: requesting sense\n",
-						  current->comm));
+						  sysiso_current->comm));
 		rtn = scsi_request_sense(scmd);
 		if (rtn != SUCCESS)
 			continue;
@@ -1365,7 +1365,7 @@ static int scsi_eh_test_devices(struct list_head *cmd_list,
 				SCSI_LOG_ERROR_RECOVERY(3,
 					sdev_printk(KERN_INFO, sdev,
 						    "%s: skip test device, past eh deadline",
-						    current->comm));
+						    sysiso_current->comm));
 				break;
 			}
 		}
@@ -1435,7 +1435,7 @@ static int scsi_eh_stu(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				sdev_printk(KERN_INFO, sdev,
 					    "%s: skip START_UNIT, past eh deadline\n",
-					    current->comm));
+					    sysiso_current->comm));
 			scsi_device_put(sdev);
 			break;
 		}
@@ -1453,7 +1453,7 @@ static int scsi_eh_stu(struct Scsi_Host *shost,
 		SCSI_LOG_ERROR_RECOVERY(3,
 			sdev_printk(KERN_INFO, sdev,
 				     "%s: Sending START_UNIT\n",
-				    current->comm));
+				    sysiso_current->comm));
 
 		if (!scsi_eh_try_stu(stu_scmd)) {
 			if (!scsi_device_online(sdev) ||
@@ -1469,7 +1469,7 @@ static int scsi_eh_stu(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				sdev_printk(KERN_INFO, sdev,
 					    "%s: START_UNIT failed\n",
-					    current->comm));
+					    sysiso_current->comm));
 		}
 	}
 
@@ -1502,7 +1502,7 @@ static int scsi_eh_bus_device_reset(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				sdev_printk(KERN_INFO, sdev,
 					    "%s: skip BDR, past eh deadline\n",
-					     current->comm));
+					     sysiso_current->comm));
 			scsi_device_put(sdev);
 			break;
 		}
@@ -1518,7 +1518,7 @@ static int scsi_eh_bus_device_reset(struct Scsi_Host *shost,
 
 		SCSI_LOG_ERROR_RECOVERY(3,
 			sdev_printk(KERN_INFO, sdev,
-				     "%s: Sending BDR\n", current->comm));
+				     "%s: Sending BDR\n", sysiso_current->comm));
 		rtn = scsi_try_bus_device_reset(bdr_scmd);
 		if (rtn == SUCCESS || rtn == FAST_IO_FAIL) {
 			if (!scsi_device_online(sdev) ||
@@ -1535,7 +1535,7 @@ static int scsi_eh_bus_device_reset(struct Scsi_Host *shost,
 		} else {
 			SCSI_LOG_ERROR_RECOVERY(3,
 				sdev_printk(KERN_INFO, sdev,
-					    "%s: BDR failed\n", current->comm));
+					    "%s: BDR failed\n", sysiso_current->comm));
 		}
 	}
 
@@ -1572,7 +1572,7 @@ static int scsi_eh_target_reset(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				shost_printk(KERN_INFO, shost,
 					    "%s: Skip target reset, past eh deadline\n",
-					     current->comm));
+					     sysiso_current->comm));
 			return list_empty(work_q);
 		}
 
@@ -1582,14 +1582,14 @@ static int scsi_eh_target_reset(struct Scsi_Host *shost,
 		SCSI_LOG_ERROR_RECOVERY(3,
 			shost_printk(KERN_INFO, shost,
 				     "%s: Sending target reset to target %d\n",
-				     current->comm, id));
+				     sysiso_current->comm, id));
 		rtn = scsi_try_target_reset(scmd);
 		if (rtn != SUCCESS && rtn != FAST_IO_FAIL)
 			SCSI_LOG_ERROR_RECOVERY(3,
 				shost_printk(KERN_INFO, shost,
 					     "%s: Target reset failed"
 					     " target: %d\n",
-					     current->comm, id));
+					     sysiso_current->comm, id));
 		list_for_each_entry_safe(scmd, next, &tmp_list, eh_entry) {
 			if (scmd_id(scmd) != id)
 				continue;
@@ -1635,7 +1635,7 @@ static int scsi_eh_bus_reset(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				shost_printk(KERN_INFO, shost,
 					    "%s: skip BRST, past eh deadline\n",
-					     current->comm));
+					     sysiso_current->comm));
 			return list_empty(work_q);
 		}
 
@@ -1656,7 +1656,7 @@ static int scsi_eh_bus_reset(struct Scsi_Host *shost,
 		SCSI_LOG_ERROR_RECOVERY(3,
 			shost_printk(KERN_INFO, shost,
 				     "%s: Sending BRST chan: %d\n",
-				     current->comm, channel));
+				     sysiso_current->comm, channel));
 		rtn = scsi_try_bus_reset(chan_scmd);
 		if (rtn == SUCCESS || rtn == FAST_IO_FAIL) {
 			list_for_each_entry_safe(scmd, next, work_q, eh_entry) {
@@ -1673,7 +1673,7 @@ static int scsi_eh_bus_reset(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				shost_printk(KERN_INFO, shost,
 					     "%s: BRST failed chan: %d\n",
-					     current->comm, channel));
+					     sysiso_current->comm, channel));
 		}
 	}
 	return scsi_eh_test_devices(&check_list, work_q, done_q, 0);
@@ -1700,7 +1700,7 @@ static int scsi_eh_host_reset(struct Scsi_Host *shost,
 		SCSI_LOG_ERROR_RECOVERY(3,
 			shost_printk(KERN_INFO, shost,
 				     "%s: Sending HRST\n",
-				     current->comm));
+				     sysiso_current->comm));
 
 		rtn = scsi_try_host_reset(scmd);
 		if (rtn == SUCCESS) {
@@ -1713,7 +1713,7 @@ static int scsi_eh_host_reset(struct Scsi_Host *shost,
 			SCSI_LOG_ERROR_RECOVERY(3,
 				shost_printk(KERN_INFO, shost,
 					     "%s: HRST failed\n",
-					     current->comm));
+					     sysiso_current->comm));
 		}
 	}
 	return scsi_eh_test_devices(&check_list, work_q, done_q, 1);
@@ -2118,7 +2118,7 @@ void scsi_eh_flush_done_q(struct list_head *done_q)
 			SCSI_LOG_ERROR_RECOVERY(3,
 				scmd_printk(KERN_INFO, scmd,
 					     "%s: flush retry cmd\n",
-					     current->comm));
+					     sysiso_current->comm));
 				scsi_queue_insert(scmd, SCSI_MLQUEUE_EH_RETRY);
 		} else {
 			/*
@@ -2131,7 +2131,7 @@ void scsi_eh_flush_done_q(struct list_head *done_q)
 			SCSI_LOG_ERROR_RECOVERY(3,
 				scmd_printk(KERN_INFO, scmd,
 					     "%s: flush finish cmd\n",
-					     current->comm));
+					     sysiso_current->comm));
 			scsi_finish_command(scmd);
 		}
 	}
diff --git a/drivers/scsi/scsi_ioctl.c b/drivers/scsi/scsi_ioctl.c
index 6ff2207bd..f3f26708a 100644
--- a/drivers/scsi/scsi_ioctl.c
+++ b/drivers/scsi/scsi_ioctl.c
@@ -905,7 +905,7 @@ int scsi_ioctl(struct scsi_device *sdev, struct gendisk *disk, fmode_t mode,
 	case SCSI_IOCTL_START_UNIT:
 	case SCSI_IOCTL_STOP_UNIT:
 		printk(KERN_WARNING "program %s is using a deprecated SCSI "
-		       "ioctl, please convert it to SG_IO\n", current->comm);
+		       "ioctl, please convert it to SG_IO\n", sysiso_current->comm);
 		break;
 	default:
 		break;
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index 8f0524892..028c760b1 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -220,12 +220,12 @@ static int sg_check_file_access(struct file *filp, const char *caller)
 {
 	if (filp->f_cred != current_real_cred()) {
 		pr_err_once("%s: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\n",
-			caller, task_tgid_vnr(current), current->comm);
+			caller, task_tgid_vnr(sysiso_current), sysiso_current->comm);
 		return -EPERM;
 	}
 	if (uaccess_kernel()) {
 		pr_err_once("%s: process %d (%s) called from kernel context, this is not allowed.\n",
-			caller, task_tgid_vnr(current), current->comm);
+			caller, task_tgid_vnr(sysiso_current), sysiso_current->comm);
 		return -EACCES;
 	}
 	return 0;
@@ -705,7 +705,7 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 				   "count and/or reply_len properly\n",
 				   old_hdr.reply_len - (int)SZ_SG_HEADER,
 				   input_size, (unsigned int) cmnd[0],
-				   current->comm);
+				   sysiso_current->comm);
 	}
 	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
 	return (k < 0) ? k : count;
diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index ae8636d37..b1c663727 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -455,7 +455,7 @@ static struct st_request *st_allocate_request(struct scsi_tape *stp)
 	else {
 		st_printk(KERN_ERR, stp,
 			  "Can't get SCSI request.\n");
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			stp->buffer->syscall_result = -EINTR;
 		else
 			stp->buffer->syscall_result = -EBUSY;
@@ -599,7 +599,7 @@ st_do_scsi(struct st_request * SRpnt, struct scsi_tape * STp, unsigned char *cmd
 	if (!do_wait && ((STp->buffer)->last_SRpnt)) {
 		st_printk(KERN_ERR, STp,
 			  "Async command already active.\n");
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			(STp->buffer)->syscall_result = (-EINTR);
 		else
 			(STp->buffer)->syscall_result = (-EBUSY);
diff --git a/drivers/staging/android/ashmem.c b/drivers/staging/android/ashmem.c
index ddbde3f84..b07d280ed 100644
--- a/drivers/staging/android/ashmem.c
+++ b/drivers/staging/android/ashmem.c
@@ -550,7 +550,7 @@ static int set_prot_mask(struct ashmem_area *asma, unsigned long prot)
 	}
 
 	/* does the application expect PROT_READ to imply PROT_EXEC? */
-	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+	if ((prot & PROT_READ) && (sysiso_current->personality & READ_IMPLIES_EXEC))
 		prot |= PROT_EXEC;
 
 	asma->prot_mask = prot;
diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index dc4ed0ff1..967ec474a 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -664,7 +664,7 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 			if (arg & TIOCM_CD)
 				break;
 			retval = -ENODEV;
-		} else if (signal_pending(current)) {
+		} else if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 		}
 	} while (!retval);
diff --git a/drivers/staging/r8188eu/include/osdep_service.h b/drivers/staging/r8188eu/include/osdep_service.h
index 029aa4e92..82e97813a 100644
--- a/drivers/staging/r8188eu/include/osdep_service.h
+++ b/drivers/staging/r8188eu/include/osdep_service.h
@@ -183,7 +183,7 @@ static __inline void thread_enter(char *name)
 
 static inline void flush_signals_thread(void)
 {
-	if (signal_pending (current))
+	if (signal_pending (sysiso_current))
 		flush_signals(current);
 }
 
diff --git a/drivers/staging/r8188eu/os_dep/usb_intf.c b/drivers/staging/r8188eu/os_dep/usb_intf.c
index bb85ab77f..fc32f0fcb 100644
--- a/drivers/staging/r8188eu/os_dep/usb_intf.c
+++ b/drivers/staging/r8188eu/os_dep/usb_intf.c
@@ -431,7 +431,8 @@ static int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
 	u32 start_time = jiffies;
 
 
-	DBG_88E("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
+	DBG_88E("==> %s (%s:%d)\n", __func__, sysiso_current->comm,
+		sysiso_current->pid);
 
 	if ((!padapter->bup) || (padapter->bDriverStopped) ||
 	    (padapter->bSurpriseRemoved)) {
@@ -510,7 +511,8 @@ int rtw_resume_process(struct adapter *padapter)
 	int ret = -1;
 	u32 start_time = jiffies;
 
-	DBG_88E("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
+	DBG_88E("==> %s (%s:%d)\n", __func__, sysiso_current->comm,
+		sysiso_current->pid);
 
 	if (padapter) {
 		pnetdev = padapter->pnetdev;
diff --git a/drivers/staging/rtl8712/osdep_service.h b/drivers/staging/rtl8712/osdep_service.h
index d33ddffb7..c9fa72be6 100644
--- a/drivers/staging/rtl8712/osdep_service.h
+++ b/drivers/staging/rtl8712/osdep_service.h
@@ -53,7 +53,7 @@ static inline u32 end_of_queue_search(struct list_head *head,
 
 static inline void flush_signals_thread(void)
 {
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		flush_signals(current);
 }
 
diff --git a/drivers/staging/rtl8723bs/hal/rtl8723bs_xmit.c b/drivers/staging/rtl8723bs/hal/rtl8723bs_xmit.c
index 156d6aba1..8b69b5389 100644
--- a/drivers/staging/rtl8723bs/hal/rtl8723bs_xmit.c
+++ b/drivers/staging/rtl8723bs/hal/rtl8723bs_xmit.c
@@ -428,7 +428,7 @@ int rtl8723bs_xmit_thread(void *context)
 
 	do {
 		ret = rtl8723bs_xmit_handler(padapter);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			flush_signals(current);
 		}
 	} while (_SUCCESS == ret);
diff --git a/drivers/staging/rtl8723bs/include/osdep_service.h b/drivers/staging/rtl8723bs/include/osdep_service.h
index bde415db4..1c1d48e60 100644
--- a/drivers/staging/rtl8723bs/include/osdep_service.h
+++ b/drivers/staging/rtl8723bs/include/osdep_service.h
@@ -80,7 +80,7 @@ static inline void thread_enter(char *name)
 
 static inline void flush_signals_thread(void)
 {
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 	{
 		flush_signals(current);
 	}
diff --git a/drivers/staging/unisys/visornic/visornic_main.c b/drivers/staging/unisys/visornic/visornic_main.c
index a3bc568c6..d8443b593 100644
--- a/drivers/staging/unisys/visornic/visornic_main.c
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@ -1437,7 +1437,7 @@ static ssize_t info_debugfs_read(struct file *file, char __user *buf,
 
 	/* for each vnic channel dump out channel specific data */
 	rcu_read_lock();
-	for_each_netdev_rcu(current->nsproxy->net_ns, dev) {
+	for_each_netdev_rcu(sysiso_current->nsproxy->net_ns, dev) {
 		/* Only consider netdevs that are visornic, and are open */
 		if (dev->netdev_ops != &visornic_dev_ops ||
 		    (!netif_queue_stopped(dev)))
diff --git a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
index 967f10b95..c6d6eec22 100644
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
@@ -778,7 +778,8 @@ vchiq_open_service(struct vchiq_instance *instance,
 
 	if (service) {
 		*phandle = service->handle;
-		status = vchiq_open_service_internal(service, current->pid);
+		status = vchiq_open_service_internal(service,
+						     sysiso_current->pid);
 		if (status != VCHIQ_SUCCESS) {
 			vchiq_remove_service(service->handle);
 			*phandle = VCHIQ_SERVICE_HANDLE_INVALID;
@@ -888,7 +889,7 @@ vchiq_blocking_bulk_transfer(unsigned int handle, void *data, unsigned int size,
 
 	mutex_lock(&instance->bulk_waiter_list_mutex);
 	list_for_each_entry(waiter, &instance->bulk_waiter_list, list) {
-		if (waiter->pid == current->pid) {
+		if (waiter->pid == sysiso_current->pid) {
 			list_del(&waiter->list);
 			found = true;
 			break;
@@ -925,7 +926,7 @@ vchiq_blocking_bulk_transfer(unsigned int handle, void *data, unsigned int size,
 	status = vchiq_bulk_transfer(handle, data, NULL, size,
 				     &waiter->bulk_waiter,
 				     VCHIQ_BULK_MODE_BLOCKING, dir);
-	if ((status != VCHIQ_RETRY) || fatal_signal_pending(current) ||
+	if ((status != VCHIQ_RETRY) || fatal_signal_pending(sysiso_current) ||
 		!waiter->bulk_waiter.bulk) {
 		struct vchiq_bulk *bulk = waiter->bulk_waiter.bulk;
 
@@ -937,13 +938,13 @@ vchiq_blocking_bulk_transfer(unsigned int handle, void *data, unsigned int size,
 		}
 		kfree(waiter);
 	} else {
-		waiter->pid = current->pid;
+		waiter->pid = sysiso_current->pid;
 		mutex_lock(&instance->bulk_waiter_list_mutex);
 		list_add(&waiter->list, &instance->bulk_waiter_list);
 		mutex_unlock(&instance->bulk_waiter_list_mutex);
 		vchiq_log_info(vchiq_arm_log_level,
 				"saved bulk_waiter %pK for pid %d",
-				waiter, current->pid);
+				waiter, sysiso_current->pid);
 	}
 
 	return status;
diff --git a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_dev.c b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_dev.c
index bf1a88c9d..9516c89df 100644
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_dev.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_dev.c
@@ -319,7 +319,7 @@ static int vchiq_irq_queue_bulk_tx_rx(struct vchiq_instance *instance,
 		mutex_lock(&instance->bulk_waiter_list_mutex);
 		list_for_each_entry(waiter, &instance->bulk_waiter_list,
 				    list) {
-			if (waiter->pid == current->pid) {
+			if (waiter->pid == sysiso_current->pid) {
 				list_del(&waiter->list);
 				found = true;
 				break;
@@ -329,13 +329,13 @@ static int vchiq_irq_queue_bulk_tx_rx(struct vchiq_instance *instance,
 		if (!found) {
 			vchiq_log_error(vchiq_arm_log_level,
 				"no bulk_waiter found for pid %d",
-				current->pid);
+				sysiso_current->pid);
 			ret = -ESRCH;
 			goto out;
 		}
 		vchiq_log_info(vchiq_arm_log_level,
 			"found bulk_waiter %pK for pid %d", waiter,
-			current->pid);
+			sysiso_current->pid);
 		userdata = &waiter->bulk_waiter;
 	} else {
 		userdata = args->userdata;
@@ -349,7 +349,7 @@ static int vchiq_irq_queue_bulk_tx_rx(struct vchiq_instance *instance,
 		goto out;
 	}
 
-	if ((status != VCHIQ_RETRY) || fatal_signal_pending(current) ||
+	if ((status != VCHIQ_RETRY) || fatal_signal_pending(sysiso_current) ||
 		!waiter->bulk_waiter.bulk) {
 		if (waiter->bulk_waiter.bulk) {
 			/* Cancel the signal when the transfer completes. */
@@ -362,13 +362,13 @@ static int vchiq_irq_queue_bulk_tx_rx(struct vchiq_instance *instance,
 	} else {
 		const enum vchiq_bulk_mode mode_waiting =
 			VCHIQ_BULK_MODE_WAITING;
-		waiter->pid = current->pid;
+		waiter->pid = sysiso_current->pid;
 		mutex_lock(&instance->bulk_waiter_list_mutex);
 		list_add(&waiter->list, &instance->bulk_waiter_list);
 		mutex_unlock(&instance->bulk_waiter_list_mutex);
 		vchiq_log_info(vchiq_arm_log_level,
 			"saved bulk_waiter %pK for pid %d",
-			waiter, current->pid);
+			waiter, sysiso_current->pid);
 
 		ret = put_user(mode_waiting, mode);
 	}
@@ -1209,7 +1209,7 @@ static int vchiq_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	instance->state = state;
-	instance->pid = current->tgid;
+	instance->pid = sysiso_current->tgid;
 
 	vchiq_debugfs_add_instance(instance);
 
diff --git a/drivers/target/iscsi/cxgbit/cxgbit_target.c b/drivers/target/iscsi/cxgbit/cxgbit_target.c
index 282297ffc..54fb2f4e5 100644
--- a/drivers/target/iscsi/cxgbit/cxgbit_target.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_target.c
@@ -317,7 +317,7 @@ static int cxgbit_queue_skb(struct cxgbit_sock *csk, struct sk_buff *skb)
 	spin_unlock_bh(&csk->lock);
 
 	if (unlikely((csk->com.state != CSK_STATE_ESTABLISHED) ||
-		     signal_pending(current))) {
+		     signal_pending(sysiso_current))) {
 		__kfree_skb(skb);
 		__skb_queue_purge(&csk->ppodq);
 		ret = -1;
@@ -1594,7 +1594,7 @@ static int cxgbit_wait_rxq(struct cxgbit_sock *csk)
 
 	wait_event_interruptible(csk->waitq, cxgbit_rxq_len(csk, &rxq));
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		goto out;
 
 	while ((skb = __skb_dequeue(&rxq))) {
diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 2c54c5d84..bbaaf7e44 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -3826,7 +3826,7 @@ int iscsi_target_tx_thread(void *arg)
 		wait_event_interruptible(conn->queues_wq,
 					 !iscsit_conn_all_queues_empty(conn));
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto transport_err;
 
 get_immediate:
@@ -4056,7 +4056,7 @@ int iscsi_target_rx_thread(void *arg)
 
 	conn->conn_transport->iscsit_get_rx_pdu(conn);
 
-	if (!signal_pending(current))
+	if (!signal_pending(sysiso_current))
 		atomic_set(&conn->transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn, &conn_freed);
 
@@ -4148,13 +4148,13 @@ int iscsit_close_connection(
 	if (!conn->conn_transport->rdma_shutdown)
 		complete(&conn->conn_logout_comp);
 
-	if (!strcmp(current->comm, ISCSI_RX_THREAD_NAME)) {
+	if (!strcmp(sysiso_current->comm, ISCSI_RX_THREAD_NAME)) {
 		if (conn->tx_thread &&
 		    cmpxchg(&conn->tx_thread_active, true, false)) {
 			send_sig(SIGINT, conn->tx_thread, 1);
 			kthread_stop(conn->tx_thread);
 		}
-	} else if (!strcmp(current->comm, ISCSI_TX_THREAD_NAME)) {
+	} else if (!strcmp(sysiso_current->comm, ISCSI_TX_THREAD_NAME)) {
 		if (conn->rx_thread &&
 		    cmpxchg(&conn->rx_thread_active, true, false)) {
 			send_sig(SIGINT, conn->rx_thread, 1);
diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c
index c0ed6f8e5..f0d3b03be 100644
--- a/drivers/target/iscsi/iscsi_target_nego.c
+++ b/drivers/target/iscsi/iscsi_target_nego.c
@@ -566,7 +566,7 @@ static void iscsi_target_do_login_rx(struct work_struct *work)
 	bool state;
 
 	pr_debug("entering iscsi_target_do_login_rx, conn: %p, %s:%d\n",
-			conn, current->comm, current->pid);
+			conn, sysiso_current->comm, current->pid);
 	/*
 	 * If iscsi_target_do_login_rx() has been invoked by ->sk_data_ready()
 	 * before initial PDU processing in iscsi_target_start_negotiation()
@@ -602,7 +602,7 @@ static void iscsi_target_do_login_rx(struct work_struct *work)
 	timeout.conn = conn;
 	timer_setup_on_stack(&timeout.timer, iscsi_target_login_timeout, 0);
 	mod_timer(&timeout.timer, jiffies + TA_LOGIN_TIMEOUT * HZ);
-	pr_debug("Starting login timer for %s/%d\n", current->comm, current->pid);
+	pr_debug("Starting login timer for %s/%d\n", sysiso_current->comm, current->pid);
 
 	rc = conn->conn_transport->iscsit_get_login_rx(conn, login);
 	del_timer_sync(&timeout.timer);
@@ -614,7 +614,7 @@ static void iscsi_target_do_login_rx(struct work_struct *work)
 		goto err;
 
 	pr_debug("iscsi_target_do_login_rx after rx_login_io, %p, %s:%d\n",
-			conn, current->comm, current->pid);
+			conn, sysiso_current->comm, current->pid);
 
 	/*
 	 * LOGIN_FLAGS_READ_ACTIVE is cleared so that sk_data_ready
diff --git a/drivers/target/iscsi/iscsi_target_util.c b/drivers/target/iscsi/iscsi_target_util.c
index 6dd5810e2..75b88e8cc 100644
--- a/drivers/target/iscsi/iscsi_target_util.c
+++ b/drivers/target/iscsi/iscsi_target_util.c
@@ -136,7 +136,7 @@ static int iscsit_wait_for_tag(struct se_session *se_sess, int state, int *cpup)
 	ws = &sbq->ws[0];
 	for (;;) {
 		sbitmap_prepare_to_wait(sbq, ws, &wait, state);
-		if (signal_pending_state(state, current))
+		if (signal_pending_state(state, sysiso_current))
 			break;
 		tag = sbitmap_queue_get(sbq, cpup);
 		if (tag >= 0)
diff --git a/drivers/tty/amiserial.c b/drivers/tty/amiserial.c
index 1e60dbef6..c4ed285cc 100644
--- a/drivers/tty/amiserial.c
+++ b/drivers/tty/amiserial.c
@@ -1158,7 +1158,7 @@ static int rs_ioctl(struct tty_struct *tty,
 				}
 				schedule();
 				/* see if a signal did it */
-				if (signal_pending(current)) {
+				if (signal_pending(sysiso_current)) {
 					ret = -ERESTARTSYS;
 					break;
 				}
@@ -1311,7 +1311,7 @@ static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
 		printk("serdatr = %d (jiff=%lu)...", lsr, jiffies);
 #endif
 		msleep_interruptible(jiffies_to_msecs(char_time));
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
diff --git a/drivers/tty/mxser.c b/drivers/tty/mxser.c
index 1216f3985..bd957e964 100644
--- a/drivers/tty/mxser.c
+++ b/drivers/tty/mxser.c
@@ -1495,7 +1495,7 @@ static void mxser_wait_until_sent(struct tty_struct *tty, int timeout)
 		spin_unlock_irqrestore(&info->slock, flags);
 		schedule_timeout_interruptible(char_time);
 		spin_lock_irqsave(&info->slock, flags);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 1d92d2a84..73f4a7176 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -2054,7 +2054,7 @@ static int gsm_disconnect(struct gsm_mux *gsm)
 	wait_event_interruptible(gsm->event,
 				dlci->state == DLCI_CLOSED);
 
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	return 0;
diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c
index 580a37b3f..bc0bb11d8 100644
--- a/drivers/tty/n_hdlc.c
+++ b/drivers/tty/n_hdlc.c
@@ -456,7 +456,7 @@ static ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,
 
 		schedule();
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
@@ -546,7 +546,7 @@ static ssize_t n_hdlc_tty_write(struct tty_struct *tty, struct file *file,
 		}
 		schedule();
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			error = -EINTR;
 			break;
 		}
diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 0ec93f1a6..ffedc3ed7 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -2024,7 +2024,7 @@ static bool canon_copy_from_read_buf(struct tty_struct *tty,
  *	error code if action should be taken.
  *
  *	Locking: redirected write test is safe
- *		 current->signal->tty check is safe
+ *		 sysiso_current->signal->tty check is safe
  *		 ctrl.lock to safely reference tty->ctrl.pgrp
  */
 
@@ -2170,7 +2170,7 @@ static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,
 					retval = -EAGAIN;
 					break;
 				}
-				if (signal_pending(current)) {
+				if (signal_pending(sysiso_current)) {
 					retval = -ERESTARTSYS;
 					break;
 				}
@@ -2275,7 +2275,7 @@ static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
 
 	add_wait_queue(&tty->write_wait, &wait);
 	while (1) {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/tty/serial/max3100.c b/drivers/tty/serial/max3100.c
index 3c92d4e01..94fbd7eba 100644
--- a/drivers/tty/serial/max3100.c
+++ b/drivers/tty/serial/max3100.c
@@ -174,7 +174,7 @@ static void max3100_work(struct work_struct *w);
 
 static void max3100_dowork(struct max3100_port *s)
 {
-	if (!s->force_end_work && !freezing(current) && !s->suspending)
+	if (!s->force_end_work && !freezing(sysiso_current) && !s->suspending)
 		queue_work(s->workqueue, &s->work);
 }
 
@@ -312,7 +312,7 @@ static void max3100_work(struct work_struct *w)
 			uart_write_wakeup(&s->port);
 
 	} while (!s->force_end_work &&
-		 !freezing(current) &&
+		 !freezing(sysiso_current) &&
 		 ((rx & MAX3100_R) ||
 		  (!uart_circ_empty(xmit) &&
 		   !uart_tx_stopped(&s->port))));
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 0e2e35ab6..c59214569 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -966,7 +966,7 @@ static int uart_set_info(struct tty_struct *tty, struct tty_port *port,
 			if (uport->flags & UPF_SPD_MASK) {
 				dev_notice_ratelimited(uport->dev,
 				       "%s sets custom speed on %s. This is deprecated.\n",
-				      current->comm,
+				      sysiso_current->comm,
 				      tty_name(port->tty));
 			}
 			uart_change_speed(tty, state, NULL);
@@ -1207,7 +1207,7 @@ static int uart_wait_modem_status(struct uart_state *state, unsigned long arg)
 		schedule();
 
 		/* see if a signal did it */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
@@ -1621,7 +1621,7 @@ static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
 	 */
 	while (!port->ops->tx_empty(port)) {
 		msleep_interruptible(jiffies_to_msecs(char_time));
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		if (time_after(jiffies, expire))
 			break;
diff --git a/drivers/tty/synclink_gt.c b/drivers/tty/synclink_gt.c
index 25c558e65..db77298c0 100644
--- a/drivers/tty/synclink_gt.c
+++ b/drivers/tty/synclink_gt.c
@@ -859,7 +859,7 @@ static void wait_until_sent(struct tty_struct *tty, int timeout)
 
 	while (info->tx_active) {
 		msleep_interruptible(jiffies_to_msecs(char_time));
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		if (timeout && time_after(jiffies, orig_jiffies + timeout))
 			break;
@@ -2698,7 +2698,7 @@ static int wait_mgsl_event(struct slgt_info *info, int __user *mask_ptr)
 
 	for(;;) {
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -ERESTARTSYS;
 			break;
 		}
@@ -3007,7 +3007,7 @@ static int wait_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)
 		add_cond_wait(&info->gpio_wait_q, &wait);
 		spin_unlock_irqrestore(&info->port_array[0]->lock, flags);
 		schedule();
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			rc = -ERESTARTSYS;
 		else
 			gpio.state = wait.data;
@@ -3041,7 +3041,7 @@ static int modem_input_wait(struct slgt_info *info,int arg)
 
 	for(;;) {
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = -ERESTARTSYS;
 			break;
 		}
@@ -3210,7 +3210,7 @@ static int block_til_ready(struct tty_struct *tty, struct file *filp,
 		if (do_clocal || cd)
 			break;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/tty/tty_audit.c b/drivers/tty/tty_audit.c
index ca7afd7b2..2d98b6518 100644
--- a/drivers/tty/tty_audit.c
+++ b/drivers/tty/tty_audit.c
@@ -24,7 +24,7 @@ static struct tty_audit_buf *tty_audit_buf_ref(void)
 {
 	struct tty_audit_buf *buf;
 
-	buf = current->signal->tty_audit_buf;
+	buf = sysiso_current->signal->tty_audit_buf;
 	WARN_ON(buf == ERR_PTR(-ESRCH));
 	return buf;
 }
@@ -62,14 +62,14 @@ static void tty_audit_log(const char *description, dev_t dev,
 			  unsigned char *data, size_t size)
 {
 	struct audit_buffer *ab;
-	pid_t pid = task_pid_nr(current);
+	pid_t pid = task_pid_nr(sysiso_current);
 	uid_t uid = from_kuid(&init_user_ns, task_uid(current));
 	uid_t loginuid = from_kuid(&init_user_ns, audit_get_loginuid(current));
 	unsigned int sessionid = audit_get_sessionid(current);
 
 	ab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_TTY);
 	if (ab) {
-		char name[sizeof(current->comm)];
+		char name[sizeof(sysiso_current->comm)];
 
 		audit_log_format(ab, "%s pid=%u uid=%u auid=%u ses=%u major=%d"
 				 " minor=%d comm=", description, pid, uid,
@@ -104,16 +104,16 @@ static void tty_audit_buf_push(struct tty_audit_buf *buf)
  *	tty_audit_exit	-	Handle a task exit
  *
  *	Make sure all buffered data is written out and deallocate the buffer.
- *	Only needs to be called if current->signal->tty_audit_buf != %NULL.
+ *	Only needs to be called if sysiso_current->signal->tty_audit_buf != %NULL.
  *
  *	The process is single-threaded at this point; no other threads share
- *	current->signal.
+ *	sysiso_current->signal.
  */
 void tty_audit_exit(void)
 {
 	struct tty_audit_buf *buf;
 
-	buf = xchg(&current->signal->tty_audit_buf, ERR_PTR(-ESRCH));
+	buf = xchg(&sysiso_current->signal->tty_audit_buf, ERR_PTR(-ESRCH));
 	if (!buf)
 		return;
 
@@ -128,7 +128,7 @@ void tty_audit_exit(void)
  */
 void tty_audit_fork(struct signal_struct *sig)
 {
-	sig->audit_tty = current->signal->audit_tty;
+	sig->audit_tty = sysiso_current->signal->audit_tty;
 }
 
 /*
@@ -155,7 +155,7 @@ int tty_audit_push(void)
 {
 	struct tty_audit_buf *buf;
 
-	if (~current->signal->audit_tty & AUDIT_TTY_ENABLE)
+	if (~sysiso_current->signal->audit_tty & AUDIT_TTY_ENABLE)
 		return -EPERM;
 
 	buf = tty_audit_buf_ref();
@@ -189,7 +189,7 @@ static struct tty_audit_buf *tty_audit_buf_get(void)
 	}
 
 	/* Race to use this buffer, free it if another wins */
-	if (cmpxchg(&current->signal->tty_audit_buf, NULL, buf) != NULL)
+	if (cmpxchg(&sysiso_current->signal->tty_audit_buf, NULL, buf) != NULL)
 		tty_audit_buf_free(buf);
 	return tty_audit_buf_ref();
 }
@@ -206,7 +206,7 @@ void tty_audit_add_data(struct tty_struct *tty, const void *data, size_t size)
 	unsigned int audit_tty;
 	dev_t dev;
 
-	audit_tty = READ_ONCE(current->signal->audit_tty);
+	audit_tty = READ_ONCE(sysiso_current->signal->audit_tty);
 	if (~audit_tty & AUDIT_TTY_ENABLE)
 		return;
 
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index 6616d4a0d..12b730e19 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1051,7 +1051,7 @@ static inline ssize_t do_tty_write(
 		if (!count)
 			break;
 		ret = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		cond_resched();
 	}
@@ -2148,7 +2148,7 @@ static int tty_open(struct inode *inode, struct file *filp)
 	if (IS_ERR(tty)) {
 		tty_free_file(filp);
 		retval = PTR_ERR(tty);
-		if (retval != -EAGAIN || signal_pending(current))
+		if (retval != -EAGAIN || signal_pending(sysiso_current))
 			return retval;
 		schedule();
 		goto retry_open;
@@ -2173,7 +2173,7 @@ static int tty_open(struct inode *inode, struct file *filp)
 		if (retval != -ERESTARTSYS)
 			return retval;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return retval;
 
 		schedule();
@@ -2251,7 +2251,7 @@ static int __tty_fasync(int fd, struct file *filp, int on)
 			pid = tty->ctrl.pgrp;
 			type = PIDTYPE_PGID;
 		} else {
-			pid = task_pid(current);
+			pid = task_pid(sysiso_current);
 			type = PIDTYPE_TGID;
 		}
 		get_pid(pid);
@@ -2289,7 +2289,7 @@ static int tty_fasync(int fd, struct file *filp, int on)
  *
  *	Locking:
  *		Called functions take tty_ldiscs_lock
- *		current->signal->tty check is safe without locks
+ *		sysiso_current->signal->tty check is safe without locks
  */
 
 static int tiocsti(struct tty_struct *tty, char __user *p)
@@ -2297,7 +2297,7 @@ static int tiocsti(struct tty_struct *tty, char __user *p)
 	char ch, mbz = 0;
 	struct tty_ldisc *ld;
 
-	if ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))
+	if ((sysiso_current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (get_user(ch, p))
 		return -EFAULT;
@@ -2510,12 +2510,12 @@ static int send_break(struct tty_struct *tty, unsigned int duration)
 		retval = tty->ops->break_ctl(tty, -1);
 		if (retval)
 			goto out;
-		if (!signal_pending(current))
+		if (!signal_pending(sysiso_current))
 			msleep_interruptible(duration);
 		retval = tty->ops->break_ctl(tty, 0);
 out:
 		tty_write_unlock(tty);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			retval = -EINTR;
 	}
 	return retval;
@@ -2705,7 +2705,7 @@ long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			return retval;
 		if (cmd != TIOCCBRK) {
 			tty_wait_until_sent(tty, 0);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -EINTR;
 		}
 		break;
diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c
index 507a25d69..bc2e91b8f 100644
--- a/drivers/tty/tty_ioctl.c
+++ b/drivers/tty/tty_ioctl.c
@@ -431,7 +431,7 @@ static int set_termios(struct tty_struct *tty, void __user *arg, int opt)
 
 	if (opt & TERMIOS_WAIT) {
 		tty_wait_until_sent(tty, 0);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 	}
 
diff --git a/drivers/tty/tty_jobctrl.c b/drivers/tty/tty_jobctrl.c
index 80b86a799..a00eb35c4 100644
--- a/drivers/tty/tty_jobctrl.c
+++ b/drivers/tty/tty_jobctrl.c
@@ -15,7 +15,7 @@
 
 static int is_ignored(int sig)
 {
-	return (sigismember(&current->blocked, sig) ||
+	return (sigismember(&sysiso_current->blocked, sig) ||
 		current->sighand->action[sig-1].sa.sa_handler == SIG_IGN);
 }
 
@@ -36,11 +36,11 @@ int __tty_check_change(struct tty_struct *tty, int sig)
 	struct pid *pgrp, *tty_pgrp;
 	int ret = 0;
 
-	if (current->signal->tty != tty)
+	if (sysiso_current->signal->tty != tty)
 		return 0;
 
 	rcu_read_lock();
-	pgrp = task_pgrp(current);
+	pgrp = task_pgrp(sysiso_current);
 
 	spin_lock_irqsave(&tty->ctrl.lock, flags);
 	tty_pgrp = tty->ctrl.pgrp;
@@ -106,24 +106,24 @@ static void __proc_set_tty(struct tty_struct *tty)
 	 */
 	put_pid(tty->ctrl.session);
 	put_pid(tty->ctrl.pgrp);
-	tty->ctrl.pgrp = get_pid(task_pgrp(current));
-	tty->ctrl.session = get_pid(task_session(current));
+	tty->ctrl.pgrp = get_pid(task_pgrp(sysiso_current));
+	tty->ctrl.session = get_pid(task_session(sysiso_current));
 	spin_unlock_irqrestore(&tty->ctrl.lock, flags);
-	if (current->signal->tty) {
+	if (sysiso_current->signal->tty) {
 		tty_debug(tty, "current tty %s not NULL!!\n",
-			  current->signal->tty->name);
-		tty_kref_put(current->signal->tty);
+			  sysiso_current->signal->tty->name);
+		tty_kref_put(sysiso_current->signal->tty);
 	}
-	put_pid(current->signal->tty_old_pgrp);
-	current->signal->tty = tty_kref_get(tty);
-	current->signal->tty_old_pgrp = NULL;
+	put_pid(sysiso_current->signal->tty_old_pgrp);
+	sysiso_current->signal->tty = tty_kref_get(tty);
+	sysiso_current->signal->tty_old_pgrp = NULL;
 }
 
 static void proc_set_tty(struct tty_struct *tty)
 {
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	__proc_set_tty(tty);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 
 /*
@@ -132,9 +132,9 @@ static void proc_set_tty(struct tty_struct *tty)
 void tty_open_proc_set_tty(struct file *filp, struct tty_struct *tty)
 {
 	read_lock(&tasklist_lock);
-	spin_lock_irq(&current->sighand->siglock);
-	if (current->signal->leader &&
-	    !current->signal->tty &&
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	if (sysiso_current->signal->leader &&
+	    !sysiso_current->signal->tty &&
 	    tty->ctrl.session == NULL) {
 		/*
 		 * Don't let a process that only has write access to the tty
@@ -153,7 +153,7 @@ void tty_open_proc_set_tty(struct file *filp, struct tty_struct *tty)
 		if (filp->f_mode & FMODE_READ)
 			__proc_set_tty(tty);
 	}
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 	read_unlock(&tasklist_lock);
 }
 
@@ -162,9 +162,9 @@ struct tty_struct *get_current_tty(void)
 	struct tty_struct *tty;
 	unsigned long flags;
 
-	spin_lock_irqsave(&current->sighand->siglock, flags);
-	tty = tty_kref_get(current->signal->tty);
-	spin_unlock_irqrestore(&current->sighand->siglock, flags);
+	spin_lock_irqsave(&sysiso_current->sighand->siglock, flags);
+	tty = tty_kref_get(sysiso_current->signal->tty);
+	spin_unlock_irqrestore(&sysiso_current->sighand->siglock, flags);
 	return tty;
 }
 EXPORT_SYMBOL_GPL(get_current_tty);
@@ -266,7 +266,7 @@ void disassociate_ctty(int on_exit)
 {
 	struct tty_struct *tty;
 
-	if (!current->signal->leader)
+	if (!sysiso_current->signal->leader)
 		return;
 
 	tty = get_current_tty();
@@ -288,10 +288,10 @@ void disassociate_ctty(int on_exit)
 	} else if (on_exit) {
 		struct pid *old_pgrp;
 
-		spin_lock_irq(&current->sighand->siglock);
-		old_pgrp = current->signal->tty_old_pgrp;
-		current->signal->tty_old_pgrp = NULL;
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_lock_irq(&sysiso_current->sighand->siglock);
+		old_pgrp = sysiso_current->signal->tty_old_pgrp;
+		sysiso_current->signal->tty_old_pgrp = NULL;
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 		if (old_pgrp) {
 			kill_pgrp(old_pgrp, SIGHUP, on_exit);
 			kill_pgrp(old_pgrp, SIGCONT, on_exit);
@@ -300,11 +300,11 @@ void disassociate_ctty(int on_exit)
 		return;
 	}
 
-	spin_lock_irq(&current->sighand->siglock);
-	put_pid(current->signal->tty_old_pgrp);
-	current->signal->tty_old_pgrp = NULL;
-	tty = tty_kref_get(current->signal->tty);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	put_pid(sysiso_current->signal->tty_old_pgrp);
+	sysiso_current->signal->tty_old_pgrp = NULL;
+	tty = tty_kref_get(sysiso_current->signal->tty);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	if (tty) {
 		unsigned long flags;
@@ -322,7 +322,7 @@ void disassociate_ctty(int on_exit)
 
 	/* Now clear signal->tty under the lock */
 	read_lock(&tasklist_lock);
-	session_clear_tty(task_session(current));
+	session_clear_tty(task_session(sysiso_current));
 	read_unlock(&tasklist_lock);
 }
 
@@ -364,15 +364,15 @@ static int tiocsctty(struct tty_struct *tty, struct file *file, int arg)
 	tty_lock(tty);
 	read_lock(&tasklist_lock);
 
-	if (current->signal->leader &&
-			task_session(current) == tty->ctrl.session)
+	if (sysiso_current->signal->leader &&
+			task_session(sysiso_current) == tty->ctrl.session)
 		goto unlock;
 
 	/*
 	 * The process must be a session leader and
 	 * not have a controlling tty already.
 	 */
-	if (!current->signal->leader || current->signal->tty) {
+	if (!sysiso_current->signal->leader || sysiso_current->signal->tty) {
 		ret = -EPERM;
 		goto unlock;
 	}
@@ -456,7 +456,7 @@ static struct pid *session_of_pgrp(struct pid *pgrp)
  *	Obtain the process group of the tty. If there is no process group
  *	return an error.
  *
- *	Locking: none. Reference to current->signal->tty is safe.
+ *	Locking: none. Reference to sysiso_current->signal->tty is safe.
  */
 static int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)
 {
@@ -466,7 +466,7 @@ static int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t
 	 * (tty == real_tty) is a cheap way of
 	 * testing if the tty is NOT a master pty.
 	 */
-	if (tty == real_tty && current->signal->tty != real_tty)
+	if (tty == real_tty && sysiso_current->signal->tty != real_tty)
 		return -ENOTTY;
 	pid = tty_get_pgrp(real_tty);
 	ret =  put_user(pid_vnr(pid), p);
@@ -502,9 +502,9 @@ static int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t
 		return -EINVAL;
 
 	spin_lock_irq(&real_tty->ctrl.lock);
-	if (!current->signal->tty ||
-	    (current->signal->tty != real_tty) ||
-	    (real_tty->ctrl.session != task_session(current))) {
+	if (!sysiso_current->signal->tty ||
+	    (sysiso_current->signal->tty != real_tty) ||
+	    (real_tty->ctrl.session != task_session(sysiso_current))) {
 		retval = -ENOTTY;
 		goto out_unlock_ctrl;
 	}
@@ -514,7 +514,7 @@ static int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t
 	if (!pgrp)
 		goto out_unlock;
 	retval = -EPERM;
-	if (session_of_pgrp(pgrp) != task_session(current))
+	if (session_of_pgrp(pgrp) != task_session(sysiso_current))
 		goto out_unlock;
 	retval = 0;
 	put_pid(real_tty->ctrl.pgrp);
@@ -544,7 +544,7 @@ static int tiocgsid(struct tty_struct *tty, struct tty_struct *real_tty, pid_t _
 	 * (tty == real_tty) is a cheap way of
 	 * testing if the tty is NOT a master pty.
 	 */
-	if (tty == real_tty && current->signal->tty != real_tty)
+	if (tty == real_tty && sysiso_current->signal->tty != real_tty)
 		return -ENOTTY;
 
 	spin_lock_irqsave(&real_tty->ctrl.lock, flags);
@@ -571,7 +571,7 @@ long tty_jobctrl_ioctl(struct tty_struct *tty, struct tty_struct *real_tty,
 
 	switch (cmd) {
 	case TIOCNOTTY:
-		if (current->signal->tty != tty)
+		if (sysiso_current->signal->tty != tty)
 			return -ENOTTY;
 		no_tty();
 		return 0;
diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c
index 2f1061a9d..06b5df8b7 100644
--- a/drivers/tty/tty_port.c
+++ b/drivers/tty/tty_port.c
@@ -522,7 +522,7 @@ int tty_port_block_til_ready(struct tty_port *port,
 		 */
 		if (do_clocal || tty_port_carrier_raised(port))
 			break;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/tty/vt/selection.c b/drivers/tty/vt/selection.c
index f7755e736..2c462d9c8 100644
--- a/drivers/tty/vt/selection.c
+++ b/drivers/tty/vt/selection.c
@@ -393,7 +393,7 @@ int paste_selection(struct tty_struct *tty)
 	mutex_lock(&vc_sel.lock);
 	while (vc_sel.buffer && vc_sel.buf_len > pasted) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index 7359c3e80..e4cbbba46 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -3188,7 +3188,7 @@ int tioclinux(struct tty_struct *tty, unsigned long arg)
 	int lines;
 	int ret;
 
-	if (current->signal->tty != tty && !capable(CAP_SYS_ADMIN))
+	if (sysiso_current->signal->tty != tty && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (get_user(type, p))
 		return -EFAULT;
diff --git a/drivers/tty/vt/vt_ioctl.c b/drivers/tty/vt/vt_ioctl.c
index 3639bb6dc..d8350b629 100644
--- a/drivers/tty/vt/vt_ioctl.c
+++ b/drivers/tty/vt/vt_ioctl.c
@@ -459,7 +459,7 @@ static int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,
 
 		spin_lock_irq(&vt_spawn_con.lock);
 		put_pid(vt_spawn_con.pid);
-		vt_spawn_con.pid = get_pid(task_pid(current));
+		vt_spawn_con.pid = get_pid(task_pid(sysiso_current));
 		vt_spawn_con.sig = arg;
 		spin_unlock_irq(&vt_spawn_con.lock);
 		break;
@@ -616,7 +616,7 @@ static int vt_setactivate(struct vt_setactivate __user *sa)
 	nvc->vt_mode = vsa.mode;
 	nvc->vt_mode.frsig = 0;
 	put_pid(nvc->vt_pid);
-	nvc->vt_pid = get_pid(task_pid(current));
+	nvc->vt_pid = get_pid(task_pid(sysiso_current));
 	console_unlock();
 
 	/* Commence switch and lock */
@@ -746,7 +746,7 @@ int vt_ioctl(struct tty_struct *tty,
 	 * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.
 	 */
 	perm = 0;
-	if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+	if (sysiso_current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
 		perm = 1;
 
 	ret = vt_k_ioctl(tty, cmd, arg, perm);
@@ -1066,7 +1066,7 @@ long vt_compat_ioctl(struct tty_struct *tty,
 	 * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.
 	 */
 	perm = 0;
-	if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
+	if (sysiso_current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
 		perm = 1;
 
 	switch (cmd) {
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index ea96e319c..295e9389a 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -602,7 +602,7 @@ static ssize_t uio_read(struct file *filep, char __user *buf,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index 7b2e2420e..777c915b4 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -1005,7 +1005,7 @@ static int wait_serial_change(struct acm *acm, unsigned long arg)
 			else
 				rv = -ENODEV;
 		} else {
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				rv = -ERESTARTSYS;
 		}
 	} while (!rv);
diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c
index f27b4aecf..bc1108572 100644
--- a/drivers/usb/class/usblp.c
+++ b/drivers/usb/class/usblp.c
@@ -941,7 +941,7 @@ static int usblp_wtest(struct usblp *usblp, int nonblock)
 
 	if (!usblp->present)
 		return -ENODEV;
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 	spin_lock_irqsave(&usblp->lock, flags);
 	if (usblp->wcomplete) {
@@ -993,7 +993,7 @@ static int usblp_rtest(struct usblp *usblp, int nonblock)
 
 	if (!usblp->present)
 		return -ENODEV;
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 	spin_lock_irqsave(&usblp->lock, flags);
 	if (usblp->rcomplete) {
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 9618ba622..1ec6abb8a 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -823,8 +823,8 @@ static int checkintf(struct usb_dev_state *ps, unsigned int ifnum)
 		return 0;
 	/* if not yet claimed, claim it for the driver */
 	dev_warn(&ps->dev->dev, "usbfs: process %d (%s) did not claim "
-		 "interface %u before use\n", task_pid_nr(current),
-		 current->comm, ifnum);
+		 "interface %u before use\n", task_pid_nr(sysiso_current),
+		 sysiso_current->comm, ifnum);
 	return claimintf(ps, ifnum);
 }
 
@@ -898,8 +898,8 @@ static int check_ctrlrecip(struct usb_dev_state *ps, unsigned int requesttype,
 			if (ret >= 0)
 				dev_info(&ps->dev->dev,
 					"%s: process %i (%s) requesting ep %02x but needs %02x\n",
-					__func__, task_pid_nr(current),
-					current->comm, index, index ^ 0x80);
+					__func__, task_pid_nr(sysiso_current),
+					sysiso_current->comm, index, index ^ 0x80);
 		}
 		if (ret >= 0)
 			ret = checkintf(ps, ret);
@@ -1044,7 +1044,7 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	INIT_LIST_HEAD(&ps->memory_list);
 	init_waitqueue_head(&ps->wait);
 	init_waitqueue_head(&ps->wait_for_resume);
-	ps->disc_pid = get_pid(task_pid(current));
+	ps->disc_pid = get_pid(task_pid(sysiso_current));
 	ps->cred = get_current_cred();
 	smp_wmb();
 
@@ -1052,8 +1052,9 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	list_add_tail(&ps->list, &dev->filelist);
 	file->private_data = ps;
 	usb_unlock_device(dev);
-	snoop(&dev->dev, "opened by process %d: %s\n", task_pid_nr(current),
-			current->comm);
+	snoop(&dev->dev, "opened by process %d: %s\n",
+			task_pid_nr(sysiso_current),
+			sysiso_current->comm);
 	return ret;
 
  out_unlock_device:
@@ -1171,7 +1172,7 @@ static int do_proc_control(struct usb_dev_state *ps,
 	if (i < 0 && i != -EPIPE) {
 		dev_printk(KERN_DEBUG, &dev->dev, "usbfs: USBDEVFS_CONTROL "
 			   "failed cmd %s rqt %u rq %u len %u ret %d\n",
-			   current->comm, ctrl->bRequestType, ctrl->bRequest,
+			   sysiso_current->comm, ctrl->bRequestType, ctrl->bRequest,
 			   ctrl->wLength, i);
 	}
 	ret = i;
@@ -1283,7 +1284,7 @@ static void check_reset_of_active_ep(struct usb_device *udev,
 	ep = eps[epnum & 0x0f];
 	if (ep && !list_empty(&ep->urb_list))
 		dev_warn(&udev->dev, "Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\n",
-				task_pid_nr(current), current->comm,
+				task_pid_nr(sysiso_current), sysiso_current->comm,
 				ioctl_name, epnum);
 }
 
@@ -1411,7 +1412,7 @@ static int proc_resetdevice(struct usb_dev_state *ps)
 					!test_bit(number, &ps->ifclaimed)) {
 				dev_warn(&ps->dev->dev,
 					"usbfs: interface %d claimed by %s while '%s' resets device\n",
-					number,	interface->dev.driver->name, current->comm);
+					number,	interface->dev.driver->name, sysiso_current->comm);
 				return -EACCES;
 			}
 		}
@@ -1465,7 +1466,7 @@ static int proc_setconfig(struct usb_dev_state *ps, void __user *arg)
 						->desc.bInterfaceNumber,
 					actconfig->interface[i]
 						->dev.driver->name,
-					current->comm, u);
+					sysiso_current->comm, u);
 				status = -EBUSY;
 				break;
 			}
@@ -1824,7 +1825,7 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 		as->userbuffer = uurb->buffer;
 	as->signr = uurb->signr;
 	as->ifnum = ifnum;
-	as->pid = get_pid(task_pid(current));
+	as->pid = get_pid(task_pid(sysiso_current));
 	as->cred = get_current_cred();
 	snoop_urb(ps->dev, as->userurb, as->urb->pipe,
 			as->urb->transfer_buffer_length, 0, SUBMIT,
@@ -1984,7 +1985,7 @@ static struct async *reap_as(struct usb_dev_state *ps)
 		as = async_getcompleted(ps);
 		if (as || !connected(ps))
 			break;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		usb_unlock_device(dev);
 		schedule();
@@ -2007,7 +2008,7 @@ static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)
 		free_async(as);
 		return retval;
 	}
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 	return -ENODEV;
 }
@@ -2152,7 +2153,7 @@ static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)
 		free_async(as);
 		return retval;
 	}
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 	return -ENODEV;
 }
@@ -2322,7 +2323,7 @@ static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
 	rc = usb_hub_claim_port(ps->dev, portnum, ps);
 	if (rc == 0)
 		snoop(&ps->dev->dev, "port %d claimed by process %d: %s\n",
-			portnum, task_pid_nr(current), current->comm);
+			portnum, task_pid_nr(current), sysiso_current->comm);
 	return rc;
 }
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 4d59d927a..12acfc2fa 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -66,7 +66,7 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 
 		dev_dbg(&urb->dev->dev,
 			"%s timed out on ep%d%s len=%u/%u\n",
-			current->comm,
+			sysiso_current->comm,
 			usb_endpoint_num(&urb->ep->desc),
 			usb_urb_dir_in(urb) ? "in" : "out",
 			urb->actual_length,
diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index 6ad669dde..be518604c 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -664,7 +664,7 @@ static int do_read(struct fsg_common *common)
 				&file_offset_tmp);
 		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
 		      (unsigned long long)file_offset, (int)nread);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		if (nread < 0) {
@@ -860,7 +860,7 @@ static int do_write(struct fsg_common *common)
 				&file_offset_tmp);
 		VLDBG(curlun, "file write %u @ %llu -> %d\n", amount,
 				(unsigned long long)file_offset, (int)nwritten);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;		/* Interrupted! */
 
 		if (nwritten < 0) {
@@ -965,11 +965,11 @@ static int do_verify(struct fsg_common *common)
 
 	/* Write out all the dirty buffers before invalidating them */
 	fsg_lun_fsync_sub(curlun);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	invalidate_sub(curlun);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -EINTR;
 
 	/* Just try to read the requested blocks */
@@ -999,7 +999,7 @@ static int do_verify(struct fsg_common *common)
 		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
 				(unsigned long long) file_offset,
 				(int) nread);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		if (nread < 0) {
@@ -2022,7 +2022,7 @@ static int do_scsi_command(struct fsg_common *common)
 	}
 	up_read(&common->filesem);
 
-	if (reply == -EINTR || signal_pending(current))
+	if (reply == -EINTR || signal_pending(sysiso_current))
 		return -EINTR;
 
 	/* Set up the single reply buffer for finish_reply() */
@@ -2429,7 +2429,7 @@ static int fsg_main_thread(void *common_)
 
 	/* The main loop */
 	while (common->state != FSG_STATE_TERMINATED) {
-		if (exception_in_progress(common) || signal_pending(current)) {
+		if (exception_in_progress(common) || signal_pending(sysiso_current)) {
 			handle_exception(common);
 			continue;
 		}
diff --git a/drivers/usb/image/mdc800.c b/drivers/usb/image/mdc800.c
index fc0e22cc6..9f35e8e56 100644
--- a/drivers/usb/image/mdc800.c
+++ b/drivers/usb/image/mdc800.c
@@ -705,7 +705,7 @@ static ssize_t mdc800_device_read (struct file *file, char __user *buf, size_t l
 
 	while (left)
 	{
-		if (signal_pending (current)) 
+		if (signal_pending (sysiso_current)) 
 		{
 			mutex_unlock(&mdc800->io_lock);
 			return -EINTR;
@@ -797,7 +797,7 @@ static ssize_t mdc800_device_write (struct file *file, const char __user *buf, s
 	while (i<len)
 	{
 		unsigned char c;
-		if (signal_pending (current)) 
+		if (signal_pending (sysiso_current)) 
 		{
 			mutex_unlock(&mdc800->io_lock);
 			return -EINTR;
diff --git a/drivers/usb/misc/adutux.c b/drivers/usb/misc/adutux.c
index ed6a19254..9b9fc4a84 100644
--- a/drivers/usb/misc/adutux.c
+++ b/drivers/usb/misc/adutux.c
@@ -461,7 +461,7 @@ static ssize_t adu_read(struct file *file, __user char *buffer, size_t count,
 					goto exit;
 				}
 
-				if (signal_pending(current)) {
+				if (signal_pending(sysiso_current)) {
 					dev_dbg(&dev->udev->dev,
 						"%s : signal pending\n",
 						__func__);
@@ -539,7 +539,7 @@ static ssize_t adu_write(struct file *file, const __user char *buffer,
 			spin_unlock_irqrestore(&dev->buflock, flags);
 
 			mutex_unlock(&dev->mtx);
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				dev_dbg(&dev->udev->dev, "%s : interrupted\n",
 					__func__);
 				set_current_state(TASK_RUNNING);
diff --git a/drivers/usb/misc/idmouse.c b/drivers/usb/misc/idmouse.c
index e9437a176..9dfd91b8c 100644
--- a/drivers/usb/misc/idmouse.c
+++ b/drivers/usb/misc/idmouse.c
@@ -170,7 +170,7 @@ static int idmouse_create_image(struct usb_idmouse *dev)
 			}
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			result = -EINTR;
 			break;
 		}
diff --git a/drivers/usb/misc/uss720.c b/drivers/usb/misc/uss720.c
index 748139d26..a0ca99be3 100644
--- a/drivers/usb/misc/uss720.c
+++ b/drivers/usb/misc/uss720.c
@@ -287,7 +287,7 @@ static int change_mode(struct parport *pp, int m)
 					/* The FIFO is stuck. */
 					return -EBUSY;
 				msleep_interruptible(10);
-				if (signal_pending (current))
+				if (signal_pending (sysiso_current))
 					break;
 			}
 		}
diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index f48a23adb..32f6e4be0 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -1307,7 +1307,7 @@ static int mon_bin_wait_event(struct file *file, struct mon_reader_bin *rp)
 			return -EWOULDBLOCK; /* Same as EAGAIN in Linux */
 		}
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			remove_wait_queue(&rp->b_wait, &waita);
 			return -EINTR;
 		}
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 39cb14164..00a05cffd 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -497,7 +497,7 @@ static struct mon_event_text *mon_text_read_wait(struct mon_reader_text *rp,
 		 * to be called when all openers are gone only.
 		 */
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			remove_wait_queue(&rp->wait, &waita);
 			return ERR_PTR(-EINTR);
 		}
diff --git a/drivers/usb/serial/digi_acceleport.c b/drivers/usb/serial/digi_acceleport.c
index af65eb863..1522ed754 100644
--- a/drivers/usb/serial/digi_acceleport.c
+++ b/drivers/usb/serial/digi_acceleport.c
@@ -384,7 +384,7 @@ static int digi_write_oob_command(struct usb_serial_port *port,
 			cond_wait_interruptible_timeout_irqrestore(
 				&oob_priv->write_wait, DIGI_RETRY_TIMEOUT,
 				&oob_priv->dp_port_lock, flags);
-			if (interruptible && signal_pending(current))
+			if (interruptible && signal_pending(sysiso_current))
 				return -EINTR;
 			spin_lock_irqsave(&oob_priv->dp_port_lock, flags);
 		}
@@ -447,7 +447,7 @@ static int digi_write_inb_command(struct usb_serial_port *port,
 			cond_wait_interruptible_timeout_irqrestore(
 				&priv->write_wait, DIGI_RETRY_TIMEOUT,
 				&priv->dp_port_lock, flags);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -EINTR;
 			spin_lock_irqsave(&priv->dp_port_lock, flags);
 		}
@@ -525,7 +525,7 @@ static int digi_set_modem_signals(struct usb_serial_port *port,
 		cond_wait_interruptible_timeout_irqrestore(
 			&oob_priv->write_wait, DIGI_RETRY_TIMEOUT,
 			&oob_priv->dp_port_lock, flags);
-		if (interruptible && signal_pending(current))
+		if (interruptible && signal_pending(sysiso_current))
 			return -EINTR;
 		spin_lock_irqsave(&oob_priv->dp_port_lock, flags);
 		spin_lock(&port_priv->dp_port_lock);
@@ -597,7 +597,7 @@ static int digi_transmit_idle(struct usb_serial_port *port,
 		cond_wait_interruptible_timeout_irqrestore(
 			&priv->dp_transmit_idle_wait, DIGI_RETRY_TIMEOUT,
 			&priv->dp_port_lock, flags);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 		spin_lock_irqsave(&priv->dp_port_lock, flags);
 	}
diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index 15b6dee3a..6c874a77e 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -289,7 +289,7 @@ void usb_serial_generic_wait_until_sent(struct tty_struct *tty, long timeout)
 	expire = jiffies + timeout;
 	while (!port->serial->type->tx_empty(port)) {
 		schedule_timeout_interruptible(period);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		if (timeout && time_after(jiffies, expire))
 			break;
diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c
index 3c034fe14..49b71c481 100644
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@ -983,7 +983,8 @@ void vfio_unregister_group_dev(struct vfio_device *device)
 					 "Device is currently in use, task"
 					 " \"%s\" (%d) "
 					 "blocked until device is released",
-					 current->comm, task_pid_nr(current));
+					 sysiso_current->comm,
+					 task_pid_nr(sysiso_current));
 			}
 		}
 	}
@@ -1498,7 +1499,8 @@ static int vfio_group_get_device_fd(struct vfio_group *group, char *buf)
 
 	if (group->noiommu)
 		dev_warn(device->dev, "vfio-noiommu device opened by user "
-			 "(%s:%d)\n", current->comm, task_pid_nr(current));
+			 "(%s:%d)\n", sysiso_current->comm,
+			 task_pid_nr(sysiso_current));
 	return fdno;
 
 err_fd:
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index 0e9217687..dd65a421d 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -597,7 +597,7 @@ static int vfio_wait(struct vfio_iommu *iommu)
 	mutex_lock(&iommu->lock);
 	finish_wait(&iommu->vaddr_wait, &wait);
 	if (kthread_should_stop() || !iommu->container_open ||
-	    fatal_signal_pending(current)) {
+	    fatal_signal_pending(sysiso_current)) {
 		return -EFAULT;
 	}
 	return WAITED;
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 28ef32388..55b627e1b 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -416,7 +416,7 @@ static inline unsigned long busy_clock(void)
 static bool vhost_can_busy_poll(unsigned long endtime)
 {
 	return likely(!need_resched() && !time_after(busy_clock(), endtime) &&
-		      !signal_pending(current));
+		      !signal_pending(sysiso_current));
 }
 
 static void vhost_net_disable_vq(struct vhost_net *n,
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 59edb5a1f..e134bb3a2 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -596,7 +596,7 @@ long vhost_dev_set_owner(struct vhost_dev *dev)
 	dev->kcov_handle = kcov_common_handle();
 	if (dev->use_worker) {
 		worker = kthread_create(vhost_worker, dev,
-					"vhost-%d", current->pid);
+					"vhost-%d", sysiso_current->pid);
 		if (IS_ERR(worker)) {
 			err = PTR_ERR(worker);
 			goto err_worker;
@@ -1223,7 +1223,7 @@ ssize_t vhost_chr_read_iter(struct vhost_dev *dev, struct iov_iter *to,
 			ret = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/drivers/video/fbdev/cobalt_lcdfb.c b/drivers/video/fbdev/cobalt_lcdfb.c
index 5f8b6324d..329cd9b78 100644
--- a/drivers/video/fbdev/cobalt_lcdfb.c
+++ b/drivers/video/fbdev/cobalt_lcdfb.c
@@ -157,7 +157,7 @@ static ssize_t cobalt_lcdfb_read(struct fb_info *info, char __user *buf,
 			pos++;
 	}
 
-	if (retval < 0 && signal_pending(current))
+	if (retval < 0 && signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	if (copy_to_user(buf, src, len))
@@ -206,7 +206,7 @@ static ssize_t cobalt_lcdfb_write(struct fb_info *info, const char __user *buf,
 			pos++;
 	}
 
-	if (retval < 0 && signal_pending(current))
+	if (retval < 0 && signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	*ppos += len;
diff --git a/drivers/video/fbdev/omap2/omapfb/displays/panel-dsi-cm.c b/drivers/video/fbdev/omap2/omapfb/displays/panel-dsi-cm.c
index 4b0793abd..9ab42836e 100644
--- a/drivers/video/fbdev/omap2/omapfb/displays/panel-dsi-cm.c
+++ b/drivers/video/fbdev/omap2/omapfb/displays/panel-dsi-cm.c
@@ -1055,7 +1055,7 @@ static int dsicm_memory_read(struct omap_dss_device *dssdev,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			dev_err(&ddata->pdev->dev, "signal pending, "
 					"aborting memory read\n");
 			r = -ERESTARTSYS;
diff --git a/drivers/xen/evtchn.c b/drivers/xen/evtchn.c
index c99415a70..3b52a055b 100644
--- a/drivers/xen/evtchn.c
+++ b/drivers/xen/evtchn.c
@@ -623,7 +623,7 @@ static int evtchn_open(struct inode *inode, struct file *filp)
 	if (u == NULL)
 		return -ENOMEM;
 
-	u->name = kasprintf(GFP_KERNEL, "evtchn:%s", current->comm);
+	u->name = kasprintf(GFP_KERNEL, "evtchn:%s", sysiso_current->comm);
 	if (u->name == NULL) {
 		kfree(u);
 		return -ENOMEM;
diff --git a/drivers/xen/grant-table.c b/drivers/xen/grant-table.c
index 3729bea0c..3d2910e41 100644
--- a/drivers/xen/grant-table.c
+++ b/drivers/xen/grant-table.c
@@ -1071,7 +1071,7 @@ gnttab_retry_eagain_gop(unsigned int cmd, void *gop, int16_t *status,
 	} while ((*status == GNTST_eagain) && (delay < MAX_DELAY));
 
 	if (delay >= MAX_DELAY) {
-		pr_err("%s: %s eagain grant\n", func, current->comm);
+		pr_err("%s: %s eagain grant\n", func, sysiso_current->comm);
 		*status = GNTST_bad_page;
 	}
 }
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index 12e02eb01..c2c9e8411 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -815,7 +815,7 @@ void unregister_xenbus_watch(struct xenbus_watch *watch)
 
 	/* Make sure there are no callbacks running currently (unless
 	   its us) */
-	if (current->pid != xenwatch_pid)
+	if (sysiso_current->pid != xenwatch_pid)
 		mutex_lock(&xenwatch_mutex);
 
 	/* Cancel pending watch events. */
@@ -831,7 +831,7 @@ void unregister_xenbus_watch(struct xenbus_watch *watch)
 	}
 	spin_unlock(&watch_events_lock);
 
-	if (current->pid != xenwatch_pid)
+	if (sysiso_current->pid != xenwatch_pid)
 		mutex_unlock(&xenwatch_mutex);
 }
 EXPORT_SYMBOL_GPL(unregister_xenbus_watch);
@@ -876,7 +876,7 @@ static int xenwatch_thread(void *unused)
 {
 	struct xs_watch_event *event;
 
-	xenwatch_pid = current->pid;
+	xenwatch_pid = sysiso_current->pid;
 
 	for (;;) {
 		wait_event_interruptible(watch_events_waitq,
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index 08f48b70a..62ebd5a04 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -357,7 +357,7 @@ struct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)
 	inode = new_inode(sb);
 	if (!inode) {
 		pr_warn("%s (%d): Problem allocating inode\n",
-			__func__, task_pid_nr(current));
+			__func__, task_pid_nr(sysiso_current));
 		return ERR_PTR(-ENOMEM);
 	}
 	err = v9fs_init_inode(v9ses, inode, mode, rdev);
diff --git a/fs/afs/fs_probe.c b/fs/afs/fs_probe.c
index c0031a3ab..cc6e204ec 100644
--- a/fs/afs/fs_probe.c
+++ b/fs/afs/fs_probe.c
@@ -280,7 +280,7 @@ int afs_wait_for_fs_probes(struct afs_server_list *slist, unsigned long untried)
 			}
 		}
 
-		if (!still_probing || signal_pending(current))
+		if (!still_probing || signal_pending(sysiso_current))
 			goto stop;
 		schedule();
 	}
@@ -304,7 +304,7 @@ int afs_wait_for_fs_probes(struct afs_server_list *slist, unsigned long untried)
 
 	kfree(waits);
 
-	if (pref == -1 && signal_pending(current))
+	if (pref == -1 && signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	if (pref >= 0)
@@ -448,7 +448,7 @@ int afs_wait_for_one_fs_probe(struct afs_server *server, bool is_intr)
 		if (timo == 0 ||
 		    server->probe.responded ||
 		    atomic_read(&server->probe_outstanding) == 0 ||
-		    (is_intr && signal_pending(current)))
+		    (is_intr && signal_pending(sysiso_current)))
 			break;
 		timo = schedule_timeout(timo);
 	}
@@ -458,7 +458,7 @@ int afs_wait_for_one_fs_probe(struct afs_server *server, bool is_intr)
 dont_wait:
 	if (server->probe.responded)
 		return 0;
-	if (is_intr && signal_pending(current))
+	if (is_intr && signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 	if (timo == 0)
 		return -ETIME;
diff --git a/fs/afs/internal.h b/fs/afs/internal.h
index 0ad97a8fc..804749a8f 100644
--- a/fs/afs/internal.h
+++ b/fs/afs/internal.h
@@ -1637,7 +1637,7 @@ static inline int afs_bad(struct afs_vnode *vnode, enum afs_file_error where)
 extern unsigned afs_debug;
 
 #define dbgprintk(FMT,...) \
-	printk("[%-6.6s] "FMT"\n", current->comm ,##__VA_ARGS__)
+	printk("[%-6.6s] "FMT"\n", sysiso_current->comm ,##__VA_ARGS__)
 
 #define kenter(FMT,...)	dbgprintk("==> %s("FMT")",__func__ ,##__VA_ARGS__)
 #define kleave(FMT,...)	dbgprintk("<== %s()"FMT"",__func__ ,##__VA_ARGS__)
diff --git a/fs/afs/rotate.c b/fs/afs/rotate.c
index 79e1a5f67..0f350c92b 100644
--- a/fs/afs/rotate.c
+++ b/fs/afs/rotate.c
@@ -91,7 +91,7 @@ static bool afs_sleep_and_retry(struct afs_operation *op)
 {
 	if (!(op->flags & AFS_OPERATION_UNINTR)) {
 		msleep_interruptible(1000);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			op->error = -ERESTARTSYS;
 			return false;
 		}
diff --git a/fs/afs/vl_probe.c b/fs/afs/vl_probe.c
index d1c7068b4..a512fdd1b 100644
--- a/fs/afs/vl_probe.c
+++ b/fs/afs/vl_probe.c
@@ -257,7 +257,7 @@ int afs_wait_for_vl_probes(struct afs_vlserver_list *vllist,
 			}
 		}
 
-		if (!still_probing || signal_pending(current))
+		if (!still_probing || signal_pending(sysiso_current))
 			goto stop;
 		schedule();
 	}
@@ -281,7 +281,7 @@ int afs_wait_for_vl_probes(struct afs_vlserver_list *vllist,
 
 	kfree(waits);
 
-	if (pref == -1 && signal_pending(current))
+	if (pref == -1 && signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	if (pref >= 0)
diff --git a/fs/afs/vl_rotate.c b/fs/afs/vl_rotate.c
index 488e58490..a4420c6be 100644
--- a/fs/afs/vl_rotate.c
+++ b/fs/afs/vl_rotate.c
@@ -23,7 +23,7 @@ bool afs_begin_vlserver_operation(struct afs_vl_cursor *vc, struct afs_cell *cel
 	vc->error = -EDESTADDRREQ;
 	vc->ac.error = SHRT_MAX;
 
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		vc->error = -EINTR;
 		vc->flags |= AFS_VL_CURSOR_STOP;
 		return false;
diff --git a/fs/aio.c b/fs/aio.c
index 51b08ab01..5603a7ba2 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -308,7 +308,8 @@ static void aio_free_ring(struct kioctx *ctx)
 
 	for (i = 0; i < ctx->nr_pages; i++) {
 		struct page *page;
-		pr_debug("pid(%d) [%d] page->count=%d\n", current->pid, i,
+		pr_debug("pid(%d) [%d] page->count=%d\n", sysiso_current->pid,
+				i,
 				page_count(ctx->ring_pages[i]));
 		page = ctx->ring_pages[i];
 		if (!page)
@@ -502,7 +503,7 @@ static int aio_setup_ring(struct kioctx *ctx, unsigned int nr_events)
 		if (!page)
 			break;
 		pr_debug("pid(%d) page[%d]->count=%d\n",
-			 current->pid, i, page_count(page));
+			 sysiso_current->pid, i, page_count(page));
 		SetPageUptodate(page);
 		unlock_page(page);
 
@@ -2089,7 +2090,7 @@ SYSCALL_DEFINE5(io_getevents, aio_context_t, ctx_id,
 		return -EFAULT;
 
 	ret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);
-	if (!ret && signal_pending(current))
+	if (!ret && signal_pending(sysiso_current))
 		ret = -EINTR;
 	return ret;
 }
@@ -2126,7 +2127,7 @@ SYSCALL_DEFINE6(io_pgetevents,
 
 	ret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);
 
-	interrupted = signal_pending(current);
+	interrupted = signal_pending(sysiso_current);
 	restore_saved_sigmask_unless(interrupted);
 	if (interrupted && !ret)
 		ret = -ERESTARTNOHAND;
@@ -2162,7 +2163,7 @@ SYSCALL_DEFINE6(io_pgetevents_time32,
 
 	ret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);
 
-	interrupted = signal_pending(current);
+	interrupted = signal_pending(sysiso_current);
 	restore_saved_sigmask_unless(interrupted);
 	if (interrupted && !ret)
 		ret = -ERESTARTNOHAND;
@@ -2187,7 +2188,7 @@ SYSCALL_DEFINE5(io_getevents_time32, __u32, ctx_id,
 		return -EFAULT;
 
 	ret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);
-	if (!ret && signal_pending(current))
+	if (!ret && signal_pending(sysiso_current))
 		ret = -EINTR;
 	return ret;
 }
@@ -2228,7 +2229,7 @@ COMPAT_SYSCALL_DEFINE6(io_pgetevents,
 
 	ret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);
 
-	interrupted = signal_pending(current);
+	interrupted = signal_pending(sysiso_current);
 	restore_saved_sigmask_unless(interrupted);
 	if (interrupted && !ret)
 		ret = -ERESTARTNOHAND;
@@ -2263,7 +2264,7 @@ COMPAT_SYSCALL_DEFINE6(io_pgetevents_time64,
 
 	ret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);
 
-	interrupted = signal_pending(current);
+	interrupted = signal_pending(sysiso_current);
 	restore_saved_sigmask_unless(interrupted);
 	if (interrupted && !ret)
 		ret = -ERESTARTNOHAND;
diff --git a/fs/autofs/autofs_i.h b/fs/autofs/autofs_i.h
index 918826eac..c8fa559b7 100644
--- a/fs/autofs/autofs_i.h
+++ b/fs/autofs/autofs_i.h
@@ -145,7 +145,7 @@ static inline struct autofs_info *autofs_dentry_ino(struct dentry *dentry)
 static inline int autofs_oz_mode(struct autofs_sb_info *sbi)
 {
 	return ((sbi->flags & AUTOFS_SBI_CATATONIC) ||
-		 task_pgrp(current) == sbi->oz_pgrp);
+		 task_pgrp(sysiso_current) == sbi->oz_pgrp);
 }
 
 struct inode *autofs_get_inode(struct super_block *, umode_t);
diff --git a/fs/autofs/root.c b/fs/autofs/root.c
index 91fe4548c..9e1bbf93d 100644
--- a/fs/autofs/root.c
+++ b/fs/autofs/root.c
@@ -489,7 +489,7 @@ static struct dentry *autofs_lookup(struct inode *dir,
 	sbi = autofs_sbi(dir->i_sb);
 
 	pr_debug("pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\n",
-		 current->pid, task_pgrp_nr(current),
+		 sysiso_current->pid, task_pgrp_nr(sysiso_current),
 		 sbi->flags & AUTOFS_SBI_CATATONIC,
 		 autofs_oz_mode(sbi));
 
@@ -866,7 +866,7 @@ static int autofs_root_ioctl_unlocked(struct inode *inode, struct file *filp,
 	void __user *p = (void __user *)arg;
 
 	pr_debug("cmd = 0x%08x, arg = 0x%08lx, sbi = %p, pgrp = %u\n",
-		 cmd, arg, sbi, task_pgrp_nr(current));
+		 cmd, arg, sbi, task_pgrp_nr(sysiso_current));
 
 	if (_IOC_TYPE(cmd) != _IOC_TYPE(AUTOFS_IOC_FIRST) ||
 	     _IOC_NR(cmd) - _IOC_NR(AUTOFS_IOC_FIRST) >= AUTOFS_IOC_COUNT)
diff --git a/fs/autofs/waitq.c b/fs/autofs/waitq.c
index 54c1f8b8b..2eeb55ae3 100644
--- a/fs/autofs/waitq.c
+++ b/fs/autofs/waitq.c
@@ -49,7 +49,7 @@ static int autofs_write(struct autofs_sb_info *sbi,
 	const char *data = (const char *)addr;
 	ssize_t wr = 0;
 
-	sigpipe = sigismember(&current->pending.signal, SIGPIPE);
+	sigpipe = sigismember(&sysiso_current->pending.signal, SIGPIPE);
 
 	mutex_lock(&sbi->pipe_mutex);
 	while (bytes) {
@@ -65,10 +65,10 @@ static int autofs_write(struct autofs_sb_info *sbi,
 	 * SIGPIPE unless it was already supposed to get one
 	 */
 	if (wr == -EPIPE && !sigpipe) {
-		spin_lock_irqsave(&current->sighand->siglock, flags);
-		sigdelset(&current->pending.signal, SIGPIPE);
+		spin_lock_irqsave(&sysiso_current->sighand->siglock, flags);
+		sigdelset(&sysiso_current->pending.signal, SIGPIPE);
 		recalc_sigpending();
-		spin_unlock_irqrestore(&current->sighand->siglock, flags);
+		spin_unlock_irqrestore(&sysiso_current->sighand->siglock, flags);
 	}
 
 	/* if 'wr' returned 0 (impossible) we assume -EIO (safe) */
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index a813b70f5..c45a25357 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -246,7 +246,7 @@ create_elf_tables(struct linux_binprm *bprm, const struct elfhdr *exec,
 	} while (0)
 
 #ifdef ARCH_DLINFO
-	/* 
+	/*
 	 * ARCH_DLINFO must come first so PPC can do its special alignment of
 	 * AUXV.
 	 * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in
@@ -394,7 +394,8 @@ static unsigned long elf_map(struct file *filep, unsigned long addr,
 	if ((type & MAP_FIXED_NOREPLACE) &&
 	    PTR_ERR((void *)map_addr) == -EEXIST)
 		pr_info("%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\n",
-			task_pid_nr(current), current->comm, (void *)addr);
+			task_pid_nr(sysiso_current), sysiso_current->comm,
+			(void *)addr);
 
 	return(map_addr);
 }
@@ -1006,10 +1007,10 @@ static int load_elf_binary(struct linux_binprm *bprm)
 	   may depend on the personality.  */
 	SET_PERSONALITY2(*elf_ex, &arch_state);
 	if (elf_read_implies_exec(*elf_ex, executable_stack))
-		current->personality |= READ_IMPLIES_EXEC;
+		sysiso_current->personality |= READ_IMPLIES_EXEC;
 
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		current->flags |= PF_RANDOMIZE;
+	if (!(sysiso_current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+		sysiso_current->flags |= PF_RANDOMIZE;
 
 	setup_new_exec(bprm);
 
@@ -1019,7 +1020,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 				 executable_stack);
 	if (retval < 0)
 		goto out_free_dentry;
-	
+
 	elf_bss = 0;
 	elf_brk = 0;
 
@@ -1042,7 +1043,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 
 		if (unlikely (elf_brk > elf_bss)) {
 			unsigned long nbyte;
-	            
+
 			/* There was a PT_LOAD segment with p_memsz > p_filesz
 			   before this one. Map anonymous pages, if needed,
 			   and clear the area.  */
@@ -1112,7 +1113,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 			 */
 			if (interpreter) {
 				load_bias = ELF_ET_DYN_BASE;
-				if (current->flags & PF_RANDOMIZE)
+				if (sysiso_current->flags & PF_RANDOMIZE)
 					load_bias += arch_mmap_rnd();
 				alignment = maximum_alignment(elf_phdata, elf_ex->e_phnum);
 				if (alignment)
@@ -1266,7 +1267,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 	mm->end_data = end_data;
 	mm->start_stack = bprm->p;
 
-	if ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {
+	if ((sysiso_current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {
 		/*
 		 * For architectures with ELF randomization, when executing
 		 * a loader directly (i.e. no interpreter listed in ELF
@@ -1285,7 +1286,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 #endif
 	}
 
-	if (current->personality & MMAP_PAGE_ZERO) {
+	if (sysiso_current->personality & MMAP_PAGE_ZERO) {
 		/* Why this, you ask???  Well SVr4 maps page 0 as read-only,
 		   and some applications "depend" upon this behavior.
 		   Since we do not have the power to recompile these, we
@@ -1485,7 +1486,7 @@ static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)
 	phdr->p_align = 0;
 }
 
-static void fill_note(struct memelfnote *note, const char *name, int type, 
+static void fill_note(struct memelfnote *note, const char *name, int type,
 		unsigned int sz, void *data)
 {
 	note->name = name;
@@ -1964,8 +1965,8 @@ static int elf_dump_thread_status(long signr, struct elf_thread_status *t)
 	t->num_notes = 0;
 
 	fill_prstatus(&t->prstatus.common, p, signr);
-	elf_core_copy_task_regs(p, &t->prstatus.pr_reg);	
-	
+	elf_core_copy_task_regs(p, &t->prstatus.pr_reg);
+
 	fill_note(&t->notes[0], "CORE", NT_PRSTATUS, sizeof(t->prstatus),
 		  &(t->prstatus));
 	t->num_notes++;
@@ -2055,7 +2056,7 @@ static int fill_note_info(struct elfhdr *elf, int phdrs,
 
 	fill_note(info->notes + 0, "CORE", NT_PRSTATUS,
 		  sizeof(*info->prstatus), info->prstatus);
-	fill_psinfo(info->psinfo, current->group_leader, current->mm);
+	fill_psinfo(info->psinfo, sysiso_current->group_leader, current->mm);
 	fill_note(info->notes + 1, "CORE", NT_PRPSINFO,
 		  sizeof(*info->psinfo), info->psinfo);
 
diff --git a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c
index 6d8fd6030..a3a9941e0 100644
--- a/fs/binfmt_elf_fdpic.c
+++ b/fs/binfmt_elf_fdpic.c
@@ -197,7 +197,7 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm)
 	int retval, i;
 	loff_t pos;
 
-	kdebug("____ LOAD %d ____", current->pid);
+	kdebug("____ LOAD %d ____", sysiso_current->pid);
 
 	memset(&exec_params, 0, sizeof(exec_params));
 	memset(&interp_params, 0, sizeof(interp_params));
@@ -350,7 +350,7 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm)
 	else
 		set_personality(PER_LINUX);
 	if (elf_read_implies_exec(&exec_params.hdr, executable_stack))
-		current->personality |= READ_IMPLIES_EXEC;
+		sysiso_current->personality |= READ_IMPLIES_EXEC;
 
 	setup_new_exec(bprm);
 
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index 5d776f80e..5badbdfdb 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -115,7 +115,7 @@ static struct linux_binfmt flat_format = {
 static int flat_core_dump(struct coredump_params *cprm)
 {
 	pr_warn("Process %s:%d received signr %d and should have core dumped\n",
-		current->comm, current->pid, cprm->siginfo->si_signo);
+		sysiso_current->comm, sysiso_current->pid, cprm->siginfo->si_signo);
 	return 1;
 }
 
@@ -383,7 +383,7 @@ calc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)
 	return addr;
 
 failed:
-	pr_cont(", killing %s!\n", current->comm);
+	pr_cont(", killing %s!\n", sysiso_current->comm);
 	send_sig(SIGSEGV, current, 0);
 
 	return RELOC_FAILED;
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index c0cebcf74..41490dbbf 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -3796,7 +3796,7 @@ static inline int is_fstree(u64 rootid)
 
 static inline int btrfs_defrag_cancelled(struct btrfs_fs_info *fs_info)
 {
-	return signal_pending(current);
+	return signal_pending(sysiso_current);
 }
 
 /* verity.c */
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index 355ea88d5..09a05f676 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -4502,7 +4502,7 @@ static void __btrfs_btree_balance_dirty(struct btrfs_fs_info *fs_info,
 	 */
 	int ret;
 
-	if (current->flags & PF_MEMALLOC)
+	if (sysiso_current->flags & PF_MEMALLOC)
 		return;
 
 	if (flush_delayed)
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 0ab456cb4..a160be9cf 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -4723,10 +4723,11 @@ btrfs_init_new_buffer(struct btrfs_trans_handle *trans, struct btrfs_root *root,
 	 * allocator chooses to use a tree block which is already used and
 	 * locked.
 	 */
-	if (buf->lock_owner == current->pid) {
+	if (buf->lock_owner == sysiso_current->pid) {
 		btrfs_err_rl(fs_info,
 "tree block %llu owner %llu already locked by pid=%d, extent tree corruption detected",
-			buf->start, btrfs_header_owner(buf), current->pid);
+			buf->start, btrfs_header_owner(buf),
+			sysiso_current->pid);
 		free_extent_buffer(buf);
 		return ERR_PTR(-EUCLEAN);
 	}
@@ -5929,7 +5930,7 @@ static int btrfs_trim_free_extents(struct btrfs_device *device, u64 *trimmed)
 		start += len;
 		*trimmed += bytes;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index da0eee7c9..73fb78a22 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -3650,7 +3650,7 @@ static int trim_no_bitmap(struct btrfs_block_group *block_group,
 		if (async && *total_trimmed)
 			break;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
@@ -3841,7 +3841,7 @@ static int trim_bitmaps(struct btrfs_block_group *block_group,
 		}
 		block_group->discard_cursor = start;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			if (start != offset)
 				reset_trimming_bitmap(ctl, offset);
 			ret = -ERESTARTSYS;
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 7c096ab9b..ae98a5689 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -8425,7 +8425,7 @@ static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 	struct inode *inode = page->mapping->host;
 	int ret;
 
-	if (current->flags & PF_MEMALLOC) {
+	if (sysiso_current->flags & PF_MEMALLOC) {
 		redirty_page_for_writepage(wbc, page);
 		unlock_page(page);
 		return 0;
diff --git a/fs/btrfs/locking.c b/fs/btrfs/locking.c
index 313d9d685..5f6c48a7a 100644
--- a/fs/btrfs/locking.c
+++ b/fs/btrfs/locking.c
@@ -45,7 +45,7 @@ void __btrfs_tree_read_lock(struct extent_buffer *eb, enum btrfs_lock_nesting ne
 		start_ns = ktime_get_ns();
 
 	down_read_nested(&eb->lock, nest);
-	eb->lock_owner = current->pid;
+	eb->lock_owner = sysiso_current->pid;
 	trace_btrfs_tree_read_lock(eb, start_ns);
 }
 
@@ -62,7 +62,7 @@ void btrfs_tree_read_lock(struct extent_buffer *eb)
 int btrfs_try_tree_read_lock(struct extent_buffer *eb)
 {
 	if (down_read_trylock(&eb->lock)) {
-		eb->lock_owner = current->pid;
+		eb->lock_owner = sysiso_current->pid;
 		trace_btrfs_try_tree_read_lock(eb);
 		return 1;
 	}
@@ -77,7 +77,7 @@ int btrfs_try_tree_read_lock(struct extent_buffer *eb)
 int btrfs_try_tree_write_lock(struct extent_buffer *eb)
 {
 	if (down_write_trylock(&eb->lock)) {
-		eb->lock_owner = current->pid;
+		eb->lock_owner = sysiso_current->pid;
 		trace_btrfs_try_tree_write_lock(eb);
 		return 1;
 	}
diff --git a/fs/btrfs/print-tree.c b/fs/btrfs/print-tree.c
index aae1027bd..a2657ef92 100644
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -191,7 +191,8 @@ static void print_eb_refs_lock(struct extent_buffer *eb)
 {
 #ifdef CONFIG_BTRFS_DEBUG
 	btrfs_info(eb->fs_info, "refs %u lock_owner %u current %u",
-		   atomic_read(&eb->refs), eb->lock_owner, current->pid);
+		   atomic_read(&eb->refs), eb->lock_owner,
+		   sysiso_current->pid);
 #endif
 }
 
diff --git a/fs/btrfs/reflink.c b/fs/btrfs/reflink.c
index 9b0814318..bfef2d4c0 100644
--- a/fs/btrfs/reflink.c
+++ b/fs/btrfs/reflink.c
@@ -542,7 +542,7 @@ static int btrfs_clone(struct inode *src, struct inode *inode,
 		btrfs_release_path(path);
 		key.offset = next_key_min_offset;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			goto out;
 		}
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 914d403b4..9c38381e6 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -2943,7 +2943,7 @@ noinline int btrfs_should_cancel_balance(struct btrfs_fs_info *fs_info)
 {
 	return atomic_read(&fs_info->balance_cancel_req) ||
 		atomic_read(&fs_info->reloc_cancel_req) ||
-		fatal_signal_pending(current);
+		fatal_signal_pending(sysiso_current);
 }
 ALLOW_ERROR_INJECTION(btrfs_should_cancel_balance, TRUE);
 
diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c
index b415c5ec0..6cac71cde 100644
--- a/fs/btrfs/tree-log.c
+++ b/fs/btrfs/tree-log.c
@@ -181,8 +181,8 @@ static int start_log_trans(struct btrfs_trans_handle *trans,
 
 		if (!root->log_start_pid) {
 			clear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);
-			root->log_start_pid = current->pid;
-		} else if (root->log_start_pid != current->pid) {
+			root->log_start_pid = sysiso_current->pid;
+		} else if (root->log_start_pid != sysiso_current->pid) {
 			set_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);
 		}
 	} else {
@@ -203,7 +203,7 @@ static int start_log_trans(struct btrfs_trans_handle *trans,
 
 		set_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state);
 		clear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);
-		root->log_start_pid = current->pid;
+		root->log_start_pid = sysiso_current->pid;
 	}
 
 	atomic_inc(&root->log_writers);
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 2ec3b8ac8..1139917ff 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -870,12 +870,12 @@ static noinline struct btrfs_device *device_list_add(const char *path,
 			pr_info(
 	"BTRFS: device label %s devid %llu transid %llu %s scanned by %s (%d)\n",
 				disk_super->label, devid, found_transid, path,
-				current->comm, task_pid_nr(current));
+				sysiso_current->comm, task_pid_nr(sysiso_current));
 		else
 			pr_info(
 	"BTRFS: device fsid %pU devid %llu transid %llu %s scanned by %s (%d)\n",
 				disk_super->fsid, devid, found_transid, path,
-				current->comm, task_pid_nr(current));
+				sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	} else if (!device->name || strcmp(device->name->str, path)) {
 		/*
@@ -941,15 +941,15 @@ static noinline struct btrfs_device *device_list_add(const char *path,
 				btrfs_warn_in_rcu(NULL,
 	"duplicate device %s devid %llu generation %llu scanned by %s (%d)",
 						  path, devid, found_transid,
-						  current->comm,
-						  task_pid_nr(current));
+						  sysiso_current->comm,
+						  task_pid_nr(sysiso_current));
 				return ERR_PTR(-EEXIST);
 			}
 			btrfs_info_in_rcu(device->fs_info,
 	"devid %llu device path %s changed to %s scanned by %s (%d)",
 					  devid, rcu_str_deref(device->name),
-					  path, current->comm,
-					  task_pid_nr(current));
+					  path, sysiso_current->comm,
+					  task_pid_nr(sysiso_current));
 		}
 
 		name = rcu_string_strdup(path, GFP_NOFS);
@@ -5761,7 +5761,7 @@ static int find_live_mirror(struct btrfs_fs_info *fs_info,
 		fs_info->fs_devices->read_policy = BTRFS_READ_POLICY_PID;
 		fallthrough;
 	case BTRFS_READ_POLICY_PID:
-		preferred_mirror = first + (current->pid % num_stripes);
+		preferred_mirror = first + (sysiso_current->pid % num_stripes);
 		break;
 	}
 
@@ -7864,7 +7864,7 @@ int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,
 				btrfs_dev_stat_set(dev, i, 0);
 		}
 		btrfs_info(fs_info, "device stats zeroed by %s (%d)",
-			   current->comm, task_pid_nr(current));
+			   sysiso_current->comm, task_pid_nr(sysiso_current));
 	} else {
 		for (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)
 			if (stats->nr_items > i)
diff --git a/fs/buffer.c b/fs/buffer.c
index c615387ae..6853d3e03 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2407,7 +2407,7 @@ static int cont_expand_zero(struct file *file, struct address_space *mapping,
 
 		balance_dirty_pages_ratelimited(mapping);
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -EINTR;
 			goto out;
 		}
diff --git a/fs/cachefiles/daemon.c b/fs/cachefiles/daemon.c
index 752c1e434..f2eefd52f 100644
--- a/fs/cachefiles/daemon.c
+++ b/fs/cachefiles/daemon.c
@@ -569,7 +569,7 @@ static int cachefiles_daemon_cull(struct cachefiles_cache *cache, char *args)
 	}
 
 	/* extract the directory dentry from the cwd */
-	get_fs_pwd(current->fs, &path);
+	get_fs_pwd(sysiso_current->fs, &path);
 
 	if (!d_can_lookup(path.dentry))
 		goto notdir;
@@ -641,7 +641,7 @@ static int cachefiles_daemon_inuse(struct cachefiles_cache *cache, char *args)
 	}
 
 	/* extract the directory dentry from the cwd */
-	get_fs_pwd(current->fs, &path);
+	get_fs_pwd(sysiso_current->fs, &path);
 
 	if (!d_can_lookup(path.dentry))
 		goto notdir;
diff --git a/fs/cachefiles/internal.h b/fs/cachefiles/internal.h
index 0a511c36d..32f9e7b3f 100644
--- a/fs/cachefiles/internal.h
+++ b/fs/cachefiles/internal.h
@@ -261,7 +261,7 @@ do {									\
  * debug tracing
  */
 #define dbgprintk(FMT, ...) \
-	printk(KERN_DEBUG "[%-6.6s] "FMT"\n", current->comm, ##__VA_ARGS__)
+	printk(KERN_DEBUG "[%-6.6s] "FMT"\n", sysiso_current->comm, ##__VA_ARGS__)
 
 #define kenter(FMT, ...) dbgprintk("==> %s("FMT")", __func__, ##__VA_ARGS__)
 #define kleave(FMT, ...) dbgprintk("<== %s()"FMT"", __func__, ##__VA_ARGS__)
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index 99b80b5c7..206cfa34a 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -506,7 +506,7 @@ static int writepage_nounlock(struct page *page, struct writeback_control *wbc)
 		dout("writepage %p page %p snapc %p not writeable - noop\n",
 		     inode, page, snapc);
 		/* we should only noop if called by kswapd */
-		WARN_ON(!(current->flags & PF_MEMALLOC));
+		WARN_ON(!(sysiso_current->flags & PF_MEMALLOC));
 		ceph_put_snap_context(oldest);
 		redirty_page_for_writepage(wbc, page);
 		return 0;
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index 8f537f1d9..edc79e412 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -2885,7 +2885,7 @@ int ceph_get_caps(struct file *filp, int need, int want, loff_t endoff, int *got
 			DEFINE_WAIT_FUNC(wait, woken_wake_function);
 
 			cw.ino = ceph_ino(inode);
-			cw.tgid = current->tgid;
+			cw.tgid = sysiso_current->tgid;
 			cw.need = need;
 			cw.want = want;
 
@@ -2900,7 +2900,7 @@ int ceph_get_caps(struct file *filp, int need, int want, loff_t endoff, int *got
 			flags |= NON_BLOCKING;
 			while (!(ret = try_get_cap_refs(inode, need, want,
 							endoff, flags, &_got))) {
-				if (signal_pending(current)) {
+				if (signal_pending(sysiso_current)) {
 					ret = -ERESTARTSYS;
 					break;
 				}
diff --git a/fs/cifs/cifs_spnego.c b/fs/cifs/cifs_spnego.c
index 353bd0dd7..398160e65 100644
--- a/fs/cifs/cifs_spnego.c
+++ b/fs/cifs/cifs_spnego.c
@@ -154,7 +154,7 @@ cifs_get_spnego_key(struct cifs_ses *sesInfo)
 	}
 
 	dp = description + strlen(description);
-	sprintf(dp, ";pid=0x%x", current->pid);
+	sprintf(dp, ";pid=0x%x", sysiso_current->pid);
 
 	cifs_dbg(FYI, "key description = %s\n", description);
 	saved_cred = override_creds(spnego_cred);
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 243d17696..5568f60c4 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -5720,7 +5720,8 @@ CIFSSMBSetPathInfoFB(const unsigned int xid, struct cifs_tcon *tcon,
 	if (rc)
 		goto out;
 
-	rc = CIFSSMBSetFileInfo(xid, tcon, data, fid.netfid, current->tgid);
+	rc = CIFSSMBSetFileInfo(xid, tcon, data, fid.netfid,
+				sysiso_current->tgid);
 	CIFSSMBClose(xid, tcon, fid.netfid);
 out:
 
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index c3b94c1e4..4789fe5cd 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -919,7 +919,7 @@ cifs_demultiplex_thread(void *p)
 	unsigned int noreclaim_flag, num_io_timeout = 0;
 
 	noreclaim_flag = memalloc_noreclaim_save();
-	cifs_dbg(FYI, "Demultiplex PID: %d\n", task_pid_nr(current));
+	cifs_dbg(FYI, "Demultiplex PID: %d\n", task_pid_nr(sysiso_current));
 
 	length = atomic_inc_return(&tcpSesAllocCount);
 	if (length > 1)
@@ -1078,7 +1078,7 @@ cifs_demultiplex_thread(void *p)
 	/* if server->tsk was NULL then wait for a signal before exiting */
 	if (!task_to_wake) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		while (!signal_pending(current)) {
+		while (!signal_pending(sysiso_current)) {
 			schedule();
 			set_current_state(TASK_INTERRUPTIBLE);
 		}
@@ -1232,7 +1232,7 @@ static int match_server(struct TCP_Server_Info *server, struct smb3_fs_context *
 	} else if ((server->vals != ctx->vals) || (server->ops != ctx->ops))
 		return 0;
 
-	if (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))
+	if (!net_eq(cifs_net_ns(server), sysiso_current->nsproxy->net_ns))
 		return 0;
 
 	if (!match_address(server, addr,
@@ -1363,7 +1363,7 @@ cifs_get_tcp_session(struct smb3_fs_context *ctx)
 
 	tcp_ses->ops = ctx->ops;
 	tcp_ses->vals = ctx->vals;
-	cifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));
+	cifs_set_net_ns(tcp_ses, get_net(sysiso_current->nsproxy->net_ns));
 	tcp_ses->hostname = extract_hostname(ctx->UNC);
 	if (IS_ERR(tcp_ses->hostname)) {
 		rc = PTR_ERR(tcp_ses->hostname);
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index 6e8e7cc26..307d353de 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -339,7 +339,7 @@ cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,
 			args.gid = INVALID_GID; /* no change */
 		}
 		CIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,
-				       current->tgid);
+				       sysiso_current->tgid);
 	} else {
 		/*
 		 * BB implement mode setting via Windows security
diff --git a/fs/cifs/dns_resolve.c b/fs/cifs/dns_resolve.c
index 0458d28d7..b5877b376 100644
--- a/fs/cifs/dns_resolve.c
+++ b/fs/cifs/dns_resolve.c
@@ -65,7 +65,7 @@ dns_resolve_server_name_to_ip(const char *unc, char **ip_addr, time64_t *expiry)
 		goto name_is_IP_address;
 
 	/* Perform the upcall */
-	rc = dns_query(current->nsproxy->net_ns, NULL, hostname, len,
+	rc = dns_query(sysiso_current->nsproxy->net_ns, NULL, hostname, len,
 		       NULL, ip_addr, expiry, false);
 	if (rc < 0)
 		cifs_dbg(FYI, "%s: unable to resolve: %*.*s\n",
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 13f3182cf..df1d60f35 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -69,7 +69,7 @@ static u32 cifs_posix_convert_flags(unsigned int flags)
 			posix_flags |= SMB_O_EXCL;
 	} else if (flags & O_EXCL)
 		cifs_dbg(FYI, "Application %s pid %d has incorrectly set O_EXCL flag but not O_CREAT on file open. Ignoring O_EXCL\n",
-			 current->comm, current->tgid);
+			 sysiso_current->comm, sysiso_current->tgid);
 
 	if (flags & O_TRUNC)
 		posix_flags |= SMB_O_TRUNC;
@@ -305,7 +305,7 @@ cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,
 	cfile->llist = fdlocks;
 
 	cfile->count = 1;
-	cfile->pid = current->tgid;
+	cfile->pid = sysiso_current->tgid;
 	cfile->uid = current_fsuid();
 	cfile->dentry = dget(dentry);
 	cfile->f_flags = file->f_flags;
@@ -1016,7 +1016,7 @@ cifs_lock_init(__u64 offset, __u64 length, __u8 type, __u16 flags)
 	lock->offset = offset;
 	lock->length = length;
 	lock->type = type;
-	lock->pid = current->tgid;
+	lock->pid = sysiso_current->tgid;
 	lock->flags = flags;
 	INIT_LIST_HEAD(&lock->blist);
 	init_waitqueue_head(&lock->block_q);
@@ -1052,7 +1052,7 @@ cifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,
 		if (offset + length <= li->offset ||
 		    offset >= li->offset + li->length)
 			continue;
-		if (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&
+		if (rw_check != CIFS_LOCK_OP && sysiso_current->tgid == li->pid &&
 		    server->ops->compare_fids(cfile, cur_cfile)) {
 			/* shared lock prevents write op through the same fid */
 			if (!(li->type & server->vals->shared_lock_type) ||
@@ -1061,7 +1061,7 @@ cifs_find_fid_lock_conflict(struct cifs_fid_locks *fdlocks, __u64 offset,
 		}
 		if ((type & server->vals->shared_lock_type) &&
 		    ((server->ops->compare_fids(cfile, cur_cfile) &&
-		     current->tgid == li->pid) || type == li->type))
+		     sysiso_current->tgid == li->pid) || type == li->type))
 			continue;
 		if (rw_check == CIFS_LOCK_OP &&
 		    (flags & FL_OFDLCK) && (li->flags & FL_OFDLCK) &&
@@ -1635,7 +1635,7 @@ cifs_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 			    (flock->fl_start + length) <
 			    (li->offset + li->length))
 				continue;
-			if (current->tgid != li->pid)
+			if (sysiso_current->tgid != li->pid)
 				continue;
 			if (types[i] != li->type)
 				continue;
@@ -2067,7 +2067,7 @@ cifs_get_writable_file(struct cifsInodeInfo *cifs_inode, int flags,
 		return rc;
 	}
 	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
-		if (!any_available && open_file->pid != current->tgid)
+		if (!any_available && open_file->pid != sysiso_current->tgid)
 			continue;
 		if (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))
 			continue;
@@ -2607,7 +2607,7 @@ static int cifs_write_end(struct file *file, struct address_space *mapping,
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
 		pid = cfile->pid;
 	else
-		pid = current->tgid;
+		pid = sysiso_current->tgid;
 
 	cifs_dbg(FYI, "write_end for page %p from pos %lld with %d bytes\n",
 		 page, pos, copied);
@@ -2962,7 +2962,7 @@ cifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
 		pid = open_file->pid;
 	else
-		pid = current->tgid;
+		pid = sysiso_current->tgid;
 
 	server = cifs_pick_channel(tlink_tcon(open_file->tlink)->ses);
 	xid = get_xid();
@@ -3697,7 +3697,7 @@ cifs_send_async_read(loff_t offset, size_t len, struct cifsFileInfo *open_file,
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
 		pid = open_file->pid;
 	else
-		pid = current->tgid;
+		pid = sysiso_current->tgid;
 
 	if (ctx->direct_io)
 		iov_iter_advance(&direct_iov, offset - ctx->pos);
@@ -4116,7 +4116,7 @@ cifs_read(struct file *file, char *read_data, size_t read_size, loff_t *offset)
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
 		pid = open_file->pid;
 	else
-		pid = current->tgid;
+		pid = sysiso_current->tgid;
 
 	if ((file->f_flags & O_ACCMODE) == O_WRONLY)
 		cifs_dbg(FYI, "attempting read on write only file instance\n");
@@ -4454,7 +4454,7 @@ static int cifs_readpages(struct file *file, struct address_space *mapping,
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
 		pid = open_file->pid;
 	else
-		pid = current->tgid;
+		pid = sysiso_current->tgid;
 
 	rc = 0;
 	server = cifs_pick_channel(tlink_tcon(open_file->tlink)->ses);
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 82848412a..725d92293 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -486,7 +486,7 @@ cifs_sfu_type(struct cifs_fattr *fattr, const char *path,
 
 	/* Read header */
 	io_parms.netfid = fid.netfid;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = 24;
@@ -1499,7 +1499,7 @@ cifs_rename_pending_delete(const char *full_path, struct dentry *dentry,
 		}
 		info_buf->Attributes = cpu_to_le32(dosattr);
 		rc = CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,
-					current->tgid);
+					sysiso_current->tgid);
 		/* although we would like to mark the file hidden
  		   if that fails we will still try to rename it */
 		if (!rc)
@@ -1520,7 +1520,7 @@ cifs_rename_pending_delete(const char *full_path, struct dentry *dentry,
 	/* try to set DELETE_ON_CLOSE */
 	if (!test_bit(CIFS_INO_DELETE_PENDING, &cifsInode->flags)) {
 		rc = CIFSSMBSetFileDisposition(xid, tcon, true, fid.netfid,
-					       current->tgid);
+					       sysiso_current->tgid);
 		/*
 		 * some samba versions return -ENOENT when we try to set the
 		 * file disposition here. Likely a samba bug, but work around
@@ -1557,7 +1557,7 @@ cifs_rename_pending_delete(const char *full_path, struct dentry *dentry,
 	if (dosattr != origattr) {
 		info_buf->Attributes = cpu_to_le32(origattr);
 		if (!CIFSSMBSetFileInfo(xid, tcon, info_buf, fid.netfid,
-					current->tgid))
+					sysiso_current->tgid))
 			cifsInode->cifsAttrs = origattr;
 	}
 
@@ -2286,7 +2286,7 @@ static int
 cifs_wait_bit_killable(struct wait_bit_key *key, int mode)
 {
 	freezable_schedule_unsafe();
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -ERESTARTSYS;
 	return 0;
 }
diff --git a/fs/cifs/link.c b/fs/cifs/link.c
index 852e54ee8..3ae981a71 100644
--- a/fs/cifs/link.c
+++ b/fs/cifs/link.c
@@ -320,7 +320,7 @@ cifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	}
 
 	io_parms.netfid = fid.netfid;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;
@@ -356,7 +356,7 @@ cifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 		return rc;
 
 	io_parms.netfid = fid.netfid;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;
@@ -415,7 +415,7 @@ smb3_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	}
 
 	io_parms.netfid = fid.netfid;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;
@@ -465,7 +465,7 @@ smb3_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	}
 
 	io_parms.netfid = fid.netfid;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;
diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c
index bb1185fff..1b78ff9d6 100644
--- a/fs/cifs/misc.c
+++ b/fs/cifs/misc.c
@@ -252,8 +252,8 @@ header_assemble(struct smb_hdr *buffer, char smb_command /* command */ ,
 	buffer->Command = smb_command;
 	buffer->Flags = 0x00;	/* case sensitive */
 	buffer->Flags2 = SMBFLG2_KNOWS_LONG_NAMES;
-	buffer->Pid = cpu_to_le16((__u16)current->tgid);
-	buffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));
+	buffer->Pid = cpu_to_le16((__u16) sysiso_current->tgid);
+	buffer->PidHigh = cpu_to_le16((__u16)(sysiso_current->tgid >> 16));
 	if (treeCon) {
 		buffer->Tid = treeCon->tid;
 		if (treeCon->ses) {
diff --git a/fs/cifs/smb1ops.c b/fs/cifs/smb1ops.c
index 3b83839fc..df071402f 100644
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@ -809,7 +809,7 @@ smb_set_file_info(struct inode *inode, const char *full_path,
 		goto out;
 	}
 
-	netpid = current->tgid;
+	netpid = sysiso_current->tgid;
 
 set_via_filehandle:
 	rc = CIFSSMBSetFileInfo(xid, tcon, buf, fid.netfid, netpid);
@@ -867,7 +867,8 @@ static int
 cifs_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,
 		     struct cifsInodeInfo *cinode)
 {
-	return CIFSSMBLock(0, tcon, fid->netfid, current->tgid, 0, 0, 0, 0,
+	return CIFSSMBLock(0, tcon, fid->netfid, sysiso_current->tgid, 0, 0,
+			   0, 0,
 			   LOCKING_ANDX_OPLOCK_RELEASE, false,
 			   CIFS_CACHE_READ(cinode) ? 1 : 0);
 }
@@ -909,7 +910,7 @@ cifs_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,
 	       __u64 length, __u32 type, int lock, int unlock, bool wait)
 {
 	return CIFSSMBLock(xid, tlink_tcon(cfile->tlink), cfile->fid.netfid,
-			   current->tgid, length, offset, unlock, lock,
+			   sysiso_current->tgid, length, offset, unlock, lock,
 			   (__u8)type, wait, 0);
 }
 
@@ -1114,7 +1115,7 @@ cifs_make_node(unsigned int xid, struct inode *inode,
 	 */
 
 	pdev = (struct win_dev *)buf;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = sizeof(struct win_dev);
diff --git a/fs/cifs/smb2file.c b/fs/cifs/smb2file.c
index f5dcc4940..567fd1b60 100644
--- a/fs/cifs/smb2file.c
+++ b/fs/cifs/smb2file.c
@@ -138,7 +138,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 		    (flock->fl_start + length) <
 		    (li->offset + li->length))
 			continue;
-		if (current->tgid != li->pid)
+		if (sysiso_current->tgid != li->pid)
 			/*
 			 * flock and OFD lock are associated with an open
 			 * file description, not the process.
@@ -167,7 +167,7 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 			stored_rc = smb2_lockv(xid, tcon,
 					       cfile->fid.persistent_fid,
 					       cfile->fid.volatile_fid,
-					       current->tgid, num, buf);
+					       sysiso_current->tgid, num, buf);
 			if (stored_rc) {
 				/*
 				 * We failed on the unlock range request - add
@@ -190,7 +190,8 @@ smb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,
 	}
 	if (num) {
 		stored_rc = smb2_lockv(xid, tcon, cfile->fid.persistent_fid,
-				       cfile->fid.volatile_fid, current->tgid,
+				       cfile->fid.volatile_fid,
+				       sysiso_current->tgid,
 				       num, buf);
 		if (stored_rc) {
 			cifs_move_llist(&tmp_llist, &cfile->llist->locks);
@@ -224,7 +225,7 @@ smb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,
 			stored_rc = smb2_lockv(xid, tcon,
 					       cfile->fid.persistent_fid,
 					       cfile->fid.volatile_fid,
-					       current->tgid, num, buf);
+					       sysiso_current->tgid, num, buf);
 			if (stored_rc)
 				rc = stored_rc;
 			cur = buf;
@@ -236,7 +237,7 @@ smb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,
 		stored_rc = smb2_lockv(xid, tcon,
 				       cfile->fid.persistent_fid,
 				       cfile->fid.volatile_fid,
-				       current->tgid, num, buf);
+				       sysiso_current->tgid, num, buf);
 		if (stored_rc)
 			rc = stored_rc;
 	}
diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c
index 829770349..24b5a3a63 100644
--- a/fs/cifs/smb2inode.c
+++ b/fs/cifs/smb2inode.c
@@ -207,7 +207,7 @@ smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 
 		rc = SMB2_set_info_init(tcon, server,
 					&rqst[num_rqst], COMPOUND_FID,
-					COMPOUND_FID, current->tgid,
+					COMPOUND_FID, sysiso_current->tgid,
 					FILE_DISPOSITION_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		if (rc)
@@ -225,7 +225,7 @@ smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 
 		rc = SMB2_set_info_init(tcon, server,
 					&rqst[num_rqst], COMPOUND_FID,
-					COMPOUND_FID, current->tgid,
+					COMPOUND_FID, sysiso_current->tgid,
 					FILE_END_OF_FILE_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		if (rc)
@@ -246,14 +246,14 @@ smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 			rc = SMB2_set_info_init(tcon, server,
 				&rqst[num_rqst],
 				cfile->fid.persistent_fid,
-				cfile->fid.volatile_fid, current->tgid,
+				cfile->fid.volatile_fid, sysiso_current->tgid,
 				FILE_BASIC_INFORMATION,
 				SMB2_O_INFO_FILE, 0, data, size);
 		else {
 			rc = SMB2_set_info_init(tcon, server,
 				&rqst[num_rqst],
 				COMPOUND_FID,
-				COMPOUND_FID, current->tgid,
+				COMPOUND_FID, sysiso_current->tgid,
 				FILE_BASIC_INFORMATION,
 				SMB2_O_INFO_FILE, 0, data, size);
 			if (!rc) {
@@ -289,13 +289,15 @@ smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 						&rqst[num_rqst],
 						cfile->fid.persistent_fid,
 						cfile->fid.volatile_fid,
-					current->tgid, FILE_RENAME_INFORMATION,
+					sysiso_current->tgid,
+					FILE_RENAME_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		else {
 			rc = SMB2_set_info_init(tcon, server,
 					&rqst[num_rqst],
 					COMPOUND_FID, COMPOUND_FID,
-					current->tgid, FILE_RENAME_INFORMATION,
+					sysiso_current->tgid,
+					FILE_RENAME_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 			if (!rc) {
 				smb2_set_next_command(tcon, &rqst[num_rqst]);
@@ -325,7 +327,7 @@ smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 
 		rc = SMB2_set_info_init(tcon, server,
 					&rqst[num_rqst], COMPOUND_FID,
-					COMPOUND_FID, current->tgid,
+					COMPOUND_FID, sysiso_current->tgid,
 					FILE_LINK_INFORMATION,
 					SMB2_O_INFO_FILE, 0, data, size);
 		if (rc)
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index bda606dc7..5926ad082 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -1354,7 +1354,7 @@ smb2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,
 
 	rc = SMB2_set_info_init(tcon, server,
 				&rqst[1], COMPOUND_FID,
-				COMPOUND_FID, current->tgid,
+				COMPOUND_FID, sysiso_current->tgid,
 				FILE_FULL_EA_INFORMATION,
 				SMB2_O_INFO_FILE, 0, data, size);
 	smb2_set_next_command(tcon, &rqst[1]);
@@ -2808,7 +2808,7 @@ smb2_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,
 		type = SMB2_LOCKFLAG_UNLOCK;
 	return SMB2_lock(xid, tlink_tcon(cfile->tlink),
 			 cfile->fid.persistent_fid, cfile->fid.volatile_fid,
-			 current->tgid, length, offset, type, wait);
+			 sysiso_current->tgid, length, offset, type, wait);
 }
 
 static void
@@ -3630,7 +3630,7 @@ static int smb3_simple_fallocate_write_range(unsigned int xid,
 	struct kvec iov[2];
 
 	io_parms.netfid = cfile->fid.netfid;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.persistent_fid = cfile->fid.persistent_fid;
 	io_parms.volatile_fid = cfile->fid.volatile_fid;
@@ -5322,7 +5322,7 @@ smb2_make_node(unsigned int xid, struct inode *inode,
 	 */
 
 	pdev = (struct win_dev *)buf;
-	io_parms.pid = current->tgid;
+	io_parms.pid = sysiso_current->tgid;
 	io_parms.tcon = tcon;
 	io_parms.offset = 0;
 	io_parms.length = sizeof(struct win_dev);
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index 7829c590e..d41e74de8 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -104,7 +104,7 @@ smb2_hdr_assemble(struct smb2_sync_hdr *shdr, __le16 smb2_cmd,
 	} else {
 		shdr->CreditRequest = cpu_to_le16(2);
 	}
-	shdr->ProcessId = cpu_to_le32((__u16)current->tgid);
+	shdr->ProcessId = cpu_to_le32((__u16) sysiso_current->tgid);
 
 	if (!tcon)
 		goto out;
@@ -5032,7 +5032,8 @@ SMB2_set_acl(const unsigned int xid, struct cifs_tcon *tcon,
 		struct cifs_ntsd *pnntsd, int pacllen, int aclflag)
 {
 	return send_set_info(xid, tcon, persistent_fid, volatile_fid,
-			current->tgid, 0, SMB2_O_INFO_SECURITY, aclflag,
+			sysiso_current->tgid, 0, SMB2_O_INFO_SECURITY,
+			aclflag,
 			1, (void **)&pnntsd, &pacllen);
 }
 
@@ -5042,7 +5043,8 @@ SMB2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,
 	    struct smb2_file_full_ea_info *buf, int len)
 {
 	return send_set_info(xid, tcon, persistent_fid, volatile_fid,
-		current->tgid, FILE_FULL_EA_INFORMATION, SMB2_O_INFO_FILE,
+		sysiso_current->tgid, FILE_FULL_EA_INFORMATION,
+		SMB2_O_INFO_FILE,
 		0, 1, (void **)&buf, &len);
 }
 
diff --git a/fs/cifs/smb2transport.c b/fs/cifs/smb2transport.c
index f59b956f9..f338c2323 100644
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@ -716,7 +716,7 @@ smb2_mid_entry_alloc(const struct smb2_sync_hdr *shdr,
 	kref_init(&temp->refcount);
 	temp->mid = le64_to_cpu(shdr->MessageId);
 	temp->credits = credits > 0 ? credits : 1;
-	temp->pid = current->pid;
+	temp->pid = sysiso_current->pid;
 	temp->command = shdr->Command; /* Always LE */
 	temp->when_alloc = jiffies;
 	temp->server = server;
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index b7379329b..b749d4388 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -51,7 +51,7 @@ AllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)
 	memset(temp, 0, sizeof(struct mid_q_entry));
 	kref_init(&temp->refcount);
 	temp->mid = get_mid(smb_buffer);
-	temp->pid = current->pid;
+	temp->pid = sysiso_current->pid;
 	temp->command = cpu_to_le16(smb_buffer->Command);
 	cifs_dbg(FYI, "For smb_command %d\n", smb_buffer->Command);
 	/*	do_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */
@@ -325,7 +325,7 @@ __smb_send_rqst(struct TCP_Server_Info *server, int num_rqst,
 	if (ssocket == NULL)
 		return -EAGAIN;
 
-	if (fatal_signal_pending(current)) {
+	if (fatal_signal_pending(sysiso_current)) {
 		cifs_dbg(FYI, "signal pending before send request\n");
 		return -ERESTARTSYS;
 	}
@@ -414,7 +414,7 @@ __smb_send_rqst(struct TCP_Server_Info *server, int num_rqst,
 	 * won't be any response from the server to handle.
 	 */
 
-	if (signal_pending(current) && (total_len != send_length)) {
+	if (signal_pending(sysiso_current) && (total_len != send_length)) {
 		cifs_dbg(FYI, "signal is pending after attempt to send\n");
 		rc = -ERESTARTSYS;
 	}
diff --git a/fs/coda/inode.c b/fs/coda/inode.c
index d9f1bd715..f8e9a3506 100644
--- a/fs/coda/inode.c
+++ b/fs/coda/inode.c
@@ -152,7 +152,7 @@ static int coda_fill_super(struct super_block *sb, void *data, int silent)
 	int error;
 	int idx;
 
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	idx = get_device_index((struct coda_mount_data *) data);
diff --git a/fs/coda/psdev.c b/fs/coda/psdev.c
index 240669f51..54122dc53 100644
--- a/fs/coda/psdev.c
+++ b/fs/coda/psdev.c
@@ -226,7 +226,7 @@ static ssize_t coda_psdev_read(struct file * file, char __user * buf,
 			retval = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
@@ -274,7 +274,7 @@ static int coda_psdev_open(struct inode * inode, struct file * file)
 	struct venus_comm *vcp;
 	int idx, err;
 
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	if (current_user_ns() != &init_user_ns)
diff --git a/fs/coda/upcall.c b/fs/coda/upcall.c
index eb3b1898d..4f0cfcde2 100644
--- a/fs/coda/upcall.c
+++ b/fs/coda/upcall.c
@@ -52,7 +52,7 @@ static void *alloc_upcall(int opcode, int size)
 
         inp->ih.opcode = opcode;
 	inp->ih.pid = task_pid_nr_ns(current, &init_pid_ns);
-	inp->ih.pgid = task_pgrp_nr_ns(current, &init_pid_ns);
+	inp->ih.pgid = task_pgrp_nr_ns(sysiso_current, &init_pid_ns);
 	inp->ih.uid = from_kuid(&init_user_ns, current_fsuid());
 
 	return (void*)inp;
@@ -615,24 +615,24 @@ int venus_access_intent(struct super_block *sb, struct CodaFid *fid,
  */
 static void coda_block_signals(sigset_t *old)
 {
-	spin_lock_irq(&current->sighand->siglock);
-	*old = current->blocked;
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	*old = sysiso_current->blocked;
 
-	sigfillset(&current->blocked);
-	sigdelset(&current->blocked, SIGKILL);
-	sigdelset(&current->blocked, SIGSTOP);
-	sigdelset(&current->blocked, SIGINT);
+	sigfillset(&sysiso_current->blocked);
+	sigdelset(&sysiso_current->blocked, SIGKILL);
+	sigdelset(&sysiso_current->blocked, SIGSTOP);
+	sigdelset(&sysiso_current->blocked, SIGINT);
 
 	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 
 static void coda_unblock_signals(sigset_t *old)
 {
-	spin_lock_irq(&current->sighand->siglock);
-	current->blocked = *old;
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	sysiso_current->blocked = *old;
 	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 
 /* Don't allow signals to interrupt the following upcalls before venus
@@ -677,7 +677,7 @@ static inline void coda_waitfor_upcall(struct venus_comm *vcp,
 			blocked = 0;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			list_del(&req->uc_chain);
 			break;
 		}
@@ -771,7 +771,7 @@ static int coda_upcall(struct venus_comm *vcp,
 	}
 
 	error = -EINTR;
-	if ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {
+	if ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(sysiso_current)) {
 		pr_warn("Unexpected interruption.\n");
 		goto exit;
 	}
diff --git a/fs/coredump.c b/fs/coredump.c
index 3224dee44..e12c5cc7b 100644
--- a/fs/coredump.c
+++ b/fs/coredump.c
@@ -161,7 +161,7 @@ static int cn_print_exe_file(struct core_name *cn, bool name_only)
 
 	exe_file = get_mm_exe_file(current->mm);
 	if (!exe_file)
-		return cn_esc_printf(cn, "%s (path unknown)", current->comm);
+		return cn_esc_printf(cn, "%s (path unknown)", sysiso_current->comm);
 
 	pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
 	if (!pathbuf) {
@@ -256,20 +256,20 @@ static int format_corename(struct core_name *cn, struct coredump_params *cprm,
 			case 'p':
 				pid_in_pattern = 1;
 				err = cn_printf(cn, "%d",
-					      task_tgid_vnr(current));
+					      task_tgid_vnr(sysiso_current));
 				break;
 			/* global pid */
 			case 'P':
 				err = cn_printf(cn, "%d",
-					      task_tgid_nr(current));
+					      task_tgid_nr(sysiso_current));
 				break;
 			case 'i':
 				err = cn_printf(cn, "%d",
-					      task_pid_vnr(current));
+					      task_pid_vnr(sysiso_current));
 				break;
 			case 'I':
 				err = cn_printf(cn, "%d",
-					      task_pid_nr(current));
+					      task_pid_nr(sysiso_current));
 				break;
 			/* uid */
 			case 'u':
@@ -309,7 +309,7 @@ static int format_corename(struct core_name *cn, struct coredump_params *cprm,
 				break;
 			/* executable, could be changed by prctl PR_SET_NAME etc */
 			case 'e':
-				err = cn_esc_printf(cn, "%s", current->comm);
+				err = cn_esc_printf(cn, "%s", sysiso_current->comm);
 				break;
 			/* file name of executable */
 			case 'f':
@@ -340,7 +340,7 @@ static int format_corename(struct core_name *cn, struct coredump_params *cprm,
 	 * and core_uses_pid is set, then .%pid will be appended to
 	 * the filename. Do not do this for piped commands. */
 	if (!ispipe && !pid_in_pattern && core_uses_pid) {
-		err = cn_printf(cn, ".%d", task_tgid_vnr(current));
+		err = cn_printf(cn, ".%d", task_tgid_vnr(sysiso_current));
 		if (err)
 			return err;
 	}
@@ -488,12 +488,12 @@ static void coredump_finish(struct mm_struct *mm, bool core_dumped)
 	struct core_thread *curr, *next;
 	struct task_struct *task;
 
-	spin_lock_irq(&current->sighand->siglock);
-	if (core_dumped && !__fatal_signal_pending(current))
-		current->signal->group_exit_code |= 0x80;
-	current->signal->group_exit_task = NULL;
-	current->signal->flags = SIGNAL_GROUP_EXIT;
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	if (core_dumped && !__fatal_signal_pending(sysiso_current))
+		sysiso_current->signal->group_exit_code |= 0x80;
+	sysiso_current->signal->group_exit_task = NULL;
+	sysiso_current->signal->flags = SIGNAL_GROUP_EXIT;
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	next = mm->core_state->dumper.next;
 	while ((curr = next) != NULL) {
@@ -519,7 +519,7 @@ static bool dump_interrupted(void)
 	 * but then we need to teach dump_write() to restart and clear
 	 * TIF_SIGPENDING.
 	 */
-	return fatal_signal_pending(current) || freezing(current);
+	return fatal_signal_pending(sysiso_current) || freezing(sysiso_current);
 }
 
 static void wait_for_dump_helpers(struct file *file)
@@ -569,7 +569,7 @@ static int umh_pipe_setup(struct subprocess_info *info, struct cred *new)
 	err = replace_fd(0, files[0], 0);
 	fput(files[0]);
 	/* and disallow core files too */
-	current->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};
+	sysiso_current->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};
 
 	return err;
 }
@@ -663,7 +663,7 @@ void do_coredump(const kernel_siginfo_t *siginfo)
 			 */
 			printk(KERN_WARNING
 				"Process %d(%s) has RLIMIT_CORE set to 1\n",
-				task_tgid_vnr(current), current->comm);
+				task_tgid_vnr(sysiso_current), sysiso_current->comm);
 			printk(KERN_WARNING "Aborting core\n");
 			goto fail_unlock;
 		}
@@ -672,7 +672,7 @@ void do_coredump(const kernel_siginfo_t *siginfo)
 		dump_count = atomic_inc_return(&core_dump_count);
 		if (core_pipe_limit && (core_pipe_limit < dump_count)) {
 			printk(KERN_WARNING "Pid %d(%s) over core_pipe_limit\n",
-			       task_tgid_vnr(current), current->comm);
+			       task_tgid_vnr(sysiso_current), sysiso_current->comm);
 			printk(KERN_WARNING "Skipping core dump\n");
 			goto fail_dropcount;
 		}
@@ -714,7 +714,7 @@ void do_coredump(const kernel_siginfo_t *siginfo)
 		if (need_suid_safe && cn.corename[0] != '/') {
 			printk(KERN_WARNING "Pid %d(%s) can only dump core "\
 				"to fully qualified path!\n",
-				task_tgid_vnr(current), current->comm);
+				task_tgid_vnr(sysiso_current), sysiso_current->comm);
 			printk(KERN_WARNING "Skipping core dump\n");
 			goto fail_unlock;
 		}
diff --git a/fs/crypto/policy.c b/fs/crypto/policy.c
index ed3d62372..dd8cf3ff5 100644
--- a/fs/crypto/policy.c
+++ b/fs/crypto/policy.c
@@ -411,7 +411,7 @@ static int set_encryption_policy(struct inode *inode,
 		 * policy version for all new encrypted directories.
 		 */
 		pr_warn_once("%s (pid %d) is setting deprecated v1 encryption policy; recommend upgrading to v2.\n",
-			     current->comm, current->pid);
+			     sysiso_current->comm, sysiso_current->pid);
 		break;
 	case FSCRYPT_POLICY_V2:
 		err = fscrypt_verify_key_added(inode->i_sb,
@@ -420,7 +420,7 @@ static int set_encryption_policy(struct inode *inode,
 			return err;
 		if (policy->v2.flags & FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32)
 			pr_warn_once("%s (pid %d) is setting an IV_INO_LBLK_32 encryption policy.  This should only be used if there are certain hardware limitations.\n",
-				     current->comm, current->pid);
+				     sysiso_current->comm, sysiso_current->pid);
 		break;
 	default:
 		WARN_ON(1);
diff --git a/fs/d_path.c b/fs/d_path.c
index cd60c7535..018e4dd65 100644
--- a/fs/d_path.c
+++ b/fs/d_path.c
@@ -284,7 +284,7 @@ char *d_path(const struct path *path, char *buf, int buflen)
 		return path->dentry->d_op->d_dname(path->dentry, buf, buflen);
 
 	rcu_read_lock();
-	get_fs_root_rcu(current->fs, &root);
+	get_fs_root_rcu(sysiso_current->fs, &root);
 	if (unlikely(d_unlinked(path->dentry)))
 		prepend(&b, " (deleted)", 11);
 	else
@@ -421,7 +421,7 @@ SYSCALL_DEFINE2(getcwd, char __user *, buf, unsigned long, size)
 		return -ENOMEM;
 
 	rcu_read_lock();
-	get_fs_root_and_pwd_rcu(current->fs, &root, &pwd);
+	get_fs_root_and_pwd_rcu(sysiso_current->fs, &root, &pwd);
 
 	if (unlikely(d_unlinked(pwd.dentry))) {
 		rcu_read_unlock();
diff --git a/fs/dax.c b/fs/dax.c
index 4e3e5a283..d4757100d 100644
--- a/fs/dax.c
+++ b/fs/dax.c
@@ -1208,7 +1208,7 @@ static loff_t dax_iomap_iter(const struct iomap_iter *iomi,
 		pgoff_t pgoff;
 		void *kaddr;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index 42e5a766d..9836e7e2f 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -262,7 +262,7 @@ static int parse_mount_options(char *data, int op, struct pts_mount_opts *opts)
 	 */
 	if (op == PARSE_MOUNT)
 		opts->reserve =
-			(current->nsproxy->mnt_ns == init_task.nsproxy->mnt_ns);
+			(sysiso_current->nsproxy->mnt_ns == init_task.nsproxy->mnt_ns);
 
 	while ((p = strsep(&data, ",")) != NULL) {
 		substring_t args[MAX_OPT_ARGS];
diff --git a/fs/dlm/lock.c b/fs/dlm/lock.c
index c502c065d..cd1d18a7d 100644
--- a/fs/dlm/lock.c
+++ b/fs/dlm/lock.c
@@ -2915,7 +2915,7 @@ static int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,
 	lkb->lkb_rqmode = args->mode;
 	lkb->lkb_lksb = args->lksb;
 	lkb->lkb_lvbptr = args->lksb->sb_lvbptr;
-	lkb->lkb_ownpid = (int) current->pid;
+	lkb->lkb_ownpid = (int) sysiso_current->pid;
 	lkb->lkb_timeout_cs = args->timeout;
 	rv = 0;
  out:
@@ -5931,7 +5931,7 @@ int dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,
 	}
 
 	lkb->lkb_exflags = flags;
-	lkb->lkb_ownpid = (int) current->pid;
+	lkb->lkb_ownpid = (int) sysiso_current->pid;
 
 	ua = lkb->lkb_ua;
 
@@ -6292,7 +6292,7 @@ int dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,
 		error = send_purge(ls, nodeid, pid);
 	} else {
 		dlm_lock_recovery(ls);
-		if (pid == current->pid)
+		if (pid == sysiso_current->pid)
 			purge_proc_locks(ls, proc);
 		else
 			do_purge(ls, nodeid, pid);
diff --git a/fs/dlm/user.c b/fs/dlm/user.c
index e5cefa90b..3ec2f3751 100644
--- a/fs/dlm/user.c
+++ b/fs/dlm/user.c
@@ -464,8 +464,8 @@ static int check_version(struct dlm_write_request *req)
 
 		printk(KERN_DEBUG "dlm: process %s (%d) version mismatch "
 		       "user (%d.%d.%d) kernel (%d.%d.%d)\n",
-		       current->comm,
-		       task_pid_nr(current),
+		       sysiso_current->comm,
+		       task_pid_nr(sysiso_current),
 		       req->version[0],
 		       req->version[1],
 		       req->version[2],
@@ -817,7 +817,7 @@ static ssize_t device_read(struct file *file, char __user *buf, size_t count,
 
 	repeat:
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (list_empty(&proc->asts) && !signal_pending(current)) {
+		if (list_empty(&proc->asts) && !signal_pending(sysiso_current)) {
 			spin_unlock(&proc->asts_spin);
 			schedule();
 			spin_lock(&proc->asts_spin);
@@ -826,7 +826,7 @@ static ssize_t device_read(struct file *file, char __user *buf, size_t count,
 		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&proc->wait, &wait);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			spin_unlock(&proc->asts_spin);
 			return -ERESTARTSYS;
 		}
diff --git a/fs/drop_caches.c b/fs/drop_caches.c
index e619c31b6..924943e66 100644
--- a/fs/drop_caches.c
+++ b/fs/drop_caches.c
@@ -68,7 +68,7 @@ int drop_caches_sysctl_handler(struct ctl_table *table, int write,
 		}
 		if (!stfu) {
 			pr_info("%s (%d): drop_caches: %d\n",
-				current->comm, task_pid_nr(current),
+				sysiso_current->comm, task_pid_nr(sysiso_current),
 				sysctl_drop_caches);
 		}
 		stfu |= sysctl_drop_caches & 4;
diff --git a/fs/ecryptfs/read_write.c b/fs/ecryptfs/read_write.c
index 60bdcaddc..9c69d1ff3 100644
--- a/fs/ecryptfs/read_write.c
+++ b/fs/ecryptfs/read_write.c
@@ -116,7 +116,7 @@ int ecryptfs_write(struct inode *ecryptfs_inode, char *data, loff_t offset,
 		size_t num_bytes = (PAGE_SIZE - start_offset_in_page);
 		loff_t total_remaining_bytes = ((offset + size) - pos);
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			rc = -EINTR;
 			break;
 		}
diff --git a/fs/eventfd.c b/fs/eventfd.c
index 3627dd7d2..7649445b5 100644
--- a/fs/eventfd.c
+++ b/fs/eventfd.c
@@ -69,17 +69,17 @@ __u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)
 	 * it returns false, the eventfd_signal() call should be deferred to a
 	 * safe context.
 	 */
-	if (WARN_ON_ONCE(current->in_eventfd_signal))
+	if (WARN_ON_ONCE(sysiso_current->in_eventfd_signal))
 		return 0;
 
 	spin_lock_irqsave(&ctx->wqh.lock, flags);
-	current->in_eventfd_signal = 1;
+	sysiso_current->in_eventfd_signal = 1;
 	if (ULLONG_MAX - ctx->count < n)
 		n = ULLONG_MAX - ctx->count;
 	ctx->count += n;
 	if (waitqueue_active(&ctx->wqh))
 		wake_up_locked_poll(&ctx->wqh, EPOLLIN);
-	current->in_eventfd_signal = 0;
+	sysiso_current->in_eventfd_signal = 0;
 	spin_unlock_irqrestore(&ctx->wqh.lock, flags);
 
 	return n;
@@ -239,7 +239,7 @@ static ssize_t eventfd_read(struct kiocb *iocb, struct iov_iter *to)
 			set_current_state(TASK_INTERRUPTIBLE);
 			if (ctx->count)
 				break;
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				__remove_wait_queue(&ctx->wqh, &wait);
 				__set_current_state(TASK_RUNNING);
 				spin_unlock_irq(&ctx->wqh.lock);
@@ -288,7 +288,7 @@ static ssize_t eventfd_write(struct file *file, const char __user *buf, size_t c
 				res = sizeof(ucnt);
 				break;
 			}
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				res = -ERESTARTSYS;
 				break;
 			}
@@ -455,4 +455,3 @@ SYSCALL_DEFINE1(eventfd, unsigned int, count)
 {
 	return do_eventfd(count, 0);
 }
-
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 06f4c5ae1..e0b007c8e 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -1640,7 +1640,7 @@ static int ep_send_events(struct eventpoll *ep,
 	 * timely exit without the chance of finding more events available and
 	 * fetching repeatedly.
 	 */
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 	init_poll_funcptr(&pt, NULL);
@@ -1808,7 +1808,7 @@ static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
 		if (eavail)
 			continue;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		/*
diff --git a/fs/exec.c b/fs/exec.c
index a098c133d..e7721f746 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -371,9 +371,9 @@ static int bprm_mm_init(struct linux_binprm *bprm)
 		goto err;
 
 	/* Save current stack limit for all calculations made during exec. */
-	task_lock(current->group_leader);
-	bprm->rlim_stack = current->signal->rlim[RLIMIT_STACK];
-	task_unlock(current->group_leader);
+	task_lock(sysiso_current->group_leader);
+	bprm->rlim_stack = sysiso_current->signal->rlim[RLIMIT_STACK];
+	task_unlock(sysiso_current->group_leader);
 
 	err = __bprm_mm_init(bprm);
 	if (err)
@@ -444,7 +444,7 @@ static int count(struct user_arg_ptr argv, int max)
 				return -E2BIG;
 			++i;
 
-			if (fatal_signal_pending(current))
+			if (fatal_signal_pending(sysiso_current))
 				return -ERESTARTNOHAND;
 			cond_resched();
 		}
@@ -462,7 +462,7 @@ static int count_strings_kernel(const char *const *argv)
 	for (i = 0; argv[i]; ++i) {
 		if (i >= MAX_ARG_STRINGS)
 			return -E2BIG;
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return -ERESTARTNOHAND;
 		cond_resched();
 	}
@@ -547,7 +547,7 @@ static int copy_strings(int argc, struct user_arg_ptr argv,
 		while (len > 0) {
 			int offset, bytes_to_copy;
 
-			if (fatal_signal_pending(current)) {
+			if (fatal_signal_pending(sysiso_current)) {
 				ret = -ERESTARTNOHAND;
 				goto out;
 			}
@@ -652,7 +652,7 @@ static int copy_strings_kernel(int argc, const char *const *argv,
 		int ret = copy_string_kernel(argv[argc], bprm);
 		if (ret < 0)
 			return ret;
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return -ERESTARTNOHAND;
 		cond_resched();
 	}
@@ -1237,7 +1237,7 @@ void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)
  */
 int begin_new_exec(struct linux_binprm * bprm)
 {
-	struct task_struct *me = current;
+	struct task_struct *me = sysiso_current;
 	int retval;
 
 	/* Once we are committed compute the creds */
@@ -1451,9 +1451,9 @@ EXPORT_SYMBOL(setup_new_exec);
 void finalize_exec(struct linux_binprm *bprm)
 {
 	/* Store any stack rlimit changes before starting thread. */
-	task_lock(current->group_leader);
-	current->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;
-	task_unlock(current->group_leader);
+	task_lock(sysiso_current->group_leader);
+	sysiso_current->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;
+	task_unlock(sysiso_current->group_leader);
 }
 EXPORT_SYMBOL(finalize_exec);
 
@@ -1465,14 +1465,14 @@ EXPORT_SYMBOL(finalize_exec);
  */
 static int prepare_bprm_creds(struct linux_binprm *bprm)
 {
-	if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))
+	if (mutex_lock_interruptible(&sysiso_current->signal->cred_guard_mutex))
 		return -ERESTARTNOINTR;
 
 	bprm->cred = prepare_exec_creds();
 	if (likely(bprm->cred))
 		return 0;
 
-	mutex_unlock(&current->signal->cred_guard_mutex);
+	mutex_unlock(&sysiso_current->signal->cred_guard_mutex);
 	return -ENOMEM;
 }
 
@@ -1484,7 +1484,7 @@ static void free_bprm(struct linux_binprm *bprm)
 	}
 	free_arg_pages(bprm);
 	if (bprm->cred) {
-		mutex_unlock(&current->signal->cred_guard_mutex);
+		mutex_unlock(&sysiso_current->signal->cred_guard_mutex);
 		abort_creds(bprm->cred);
 	}
 	if (bprm->file) {
@@ -1552,7 +1552,7 @@ EXPORT_SYMBOL(bprm_change_interp);
  */
 static void check_unsafe_exec(struct linux_binprm *bprm)
 {
-	struct task_struct *p = current, *t;
+	struct task_struct *p = sysiso_current, *t;
 	unsigned n_fs;
 
 	if (p->ptrace)
@@ -1752,9 +1752,9 @@ static int exec_binprm(struct linux_binprm *bprm)
 	int ret, depth;
 
 	/* Need to fetch pid before load_binary changes it */
-	old_pid = current->pid;
+	old_pid = sysiso_current->pid;
 	rcu_read_lock();
-	old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));
+	old_vpid = task_pid_nr_ns(sysiso_current, task_active_pid_ns(sysiso_current->parent));
 	rcu_read_unlock();
 
 	/* This allows 4 levels of binfmt rewrites before failing hard. */
@@ -1805,7 +1805,7 @@ static int bprm_execve(struct linux_binprm *bprm,
 		return retval;
 
 	check_unsafe_exec(bprm);
-	current->in_execve = 1;
+	sysiso_current->in_execve = 1;
 
 	file = do_open_execat(fd, filename, flags);
 	retval = PTR_ERR(file);
@@ -1837,8 +1837,8 @@ static int bprm_execve(struct linux_binprm *bprm,
 		goto out;
 
 	/* execve succeeded */
-	current->fs->in_exec = 0;
-	current->in_execve = 0;
+	sysiso_current->fs->in_exec = 0;
+	sysiso_current->in_execve = 0;
 	rseq_execve(current);
 	acct_update_integrals(current);
 	task_numa_free(current, false);
@@ -1851,12 +1851,12 @@ static int bprm_execve(struct linux_binprm *bprm,
 	 * signal if present otherwise terminate the process with
 	 * SIGSEGV.
 	 */
-	if (bprm->point_of_no_return && !fatal_signal_pending(current))
+	if (bprm->point_of_no_return && !fatal_signal_pending(sysiso_current))
 		force_sigsegv(SIGSEGV);
 
 out_unmark:
-	current->fs->in_exec = 0;
-	current->in_execve = 0;
+	sysiso_current->fs->in_exec = 0;
+	sysiso_current->in_execve = 0;
 
 	return retval;
 }
@@ -1878,7 +1878,7 @@ static int do_execveat_common(int fd, struct filename *filename,
 	 * don't check setuid() return code.  Here we additionally recheck
 	 * whether NPROC limit is still exceeded.
 	 */
-	if ((current->flags & PF_NPROC_EXCEEDED) &&
+	if ((sysiso_current->flags & PF_NPROC_EXCEEDED) &&
 	    is_ucounts_overlimit(current_ucounts(), UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC))) {
 		retval = -EAGAIN;
 		goto out_ret;
@@ -1886,7 +1886,7 @@ static int do_execveat_common(int fd, struct filename *filename,
 
 	/* We're below the limit (still or again), so we don't want to make
 	 * further execve() calls fail. */
-	current->flags &= ~PF_NPROC_EXCEEDED;
+	sysiso_current->flags &= ~PF_NPROC_EXCEEDED;
 
 	bprm = alloc_bprm(fd, filename);
 	if (IS_ERR(bprm)) {
diff --git a/fs/exfat/balloc.c b/fs/exfat/balloc.c
index cc5cffc4a..9c8f5cc9f 100644
--- a/fs/exfat/balloc.c
+++ b/fs/exfat/balloc.c
@@ -318,7 +318,7 @@ int exfat_trim_fs(struct inode *inode, struct fstrim_range *range)
 		if (next_free_clu >= clu_end)
 			break;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto unlock;
 		}
diff --git a/fs/exfat/super.c b/fs/exfat/super.c
index 5539ffc20..1f2667ade 100644
--- a/fs/exfat/super.c
+++ b/fs/exfat/super.c
@@ -758,8 +758,8 @@ static int exfat_init_fs_context(struct fs_context *fc)
 
 	sbi->options.fs_uid = current_uid();
 	sbi->options.fs_gid = current_gid();
-	sbi->options.fs_fmask = current->fs->umask;
-	sbi->options.fs_dmask = current->fs->umask;
+	sbi->options.fs_fmask = sysiso_current->fs->umask;
+	sbi->options.fs_dmask = sysiso_current->fs->umask;
 	sbi->options.allow_utime = -1;
 	sbi->options.iocharset = exfat_default_iocharset;
 	sbi->options.errors = EXFAT_ERRORS_RO;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 333fa6266..d15beac37 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -313,7 +313,7 @@ static ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)
 	 * the same cylinder group then.
 	 */
 	bg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);
-	colour = (current->pid % 16) *
+	colour = (sysiso_current->pid % 16) *
 			(EXT2_BLOCKS_PER_GROUP(inode->i_sb) / 16);
 	return bg_start + colour;
 }
diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index a0fb0c4bd..74fd6b8fe 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -935,10 +935,10 @@ ext4_fsblk_t ext4_inode_to_goal_block(struct inode *inode)
 		return bg_start;
 
 	if (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)
-		colour = (task_pid_nr(current) % 16) *
+		colour = (task_pid_nr(sysiso_current) % 16) *
 			(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);
 	else
-		colour = (task_pid_nr(current) % 16) *
+		colour = (task_pid_nr(sysiso_current) % 16) *
 			((last_block - bg_start) / 16);
 	return bg_start + colour;
 }
diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index 74b172a4a..453e0bd6f 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -170,7 +170,7 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 	while (ctx->pos < inode->i_size) {
 		struct ext4_map_blocks map;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto errout;
 		}
@@ -529,7 +529,7 @@ static int call_filldir(struct file *file, struct dir_context *ctx,
 	if (!fname) {
 		ext4_msg(sb, KERN_ERR, "%s:%d: inode #%lu: comm %s: "
 			 "called with null fname?!?", __func__, __LINE__,
-			 inode->i_ino, current->comm);
+			 inode->i_ino, sysiso_current->comm);
 		return 0;
 	}
 	ctx->pos = hash2pos(file, fname->hash, fname->minor_hash);
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 382519553..0ebaba982 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -91,7 +91,7 @@
 #ifdef CONFIG_EXT4_DEBUG
 #define ext_debug(ino, fmt, ...)					\
 	pr_debug("[%s/%d] EXT4-fs (%s): ino %lu: (%s, %d): %s:" fmt,	\
-		 current->comm, task_pid_nr(current),			\
+		 sysiso_current->comm, task_pid_nr(current),			\
 		 ino->i_sb->s_id, ino->i_ino, __FILE__, __LINE__,	\
 		 __func__, ##__VA_ARGS__)
 #else
diff --git a/fs/ext4/fsmap.c b/fs/ext4/fsmap.c
index 4493ef0c7..f1d721bbf 100644
--- a/fs/ext4/fsmap.c
+++ b/fs/ext4/fsmap.c
@@ -92,7 +92,7 @@ static int ext4_getfsmap_helper(struct super_block *sb,
 	ext4_grpblk_t cno;
 	int error;
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 	/*
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 0f0630516..0f34925c2 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2032,14 +2032,14 @@ static int ext4_writepage(struct page *page,
 	if (ext4_walk_page_buffers(NULL, inode, page_bufs, 0, len, NULL,
 				   ext4_bh_delay_or_unwritten)) {
 		redirty_page_for_writepage(wbc, page);
-		if ((current->flags & PF_MEMALLOC) ||
+		if ((sysiso_current->flags & PF_MEMALLOC) ||
 		    (inode->i_sb->s_blocksize == PAGE_SIZE)) {
 			/*
 			 * For memory cleaning there's no point in writing only
 			 * some buffers. So just bail out. Warn if we came here
 			 * from direct reclaim.
 			 */
-			WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD))
+			WARN_ON_ONCE((sysiso_current->flags & (PF_MEMALLOC|PF_KSWAPD))
 							== PF_MEMALLOC);
 			unlock_page(page);
 			return 0;
@@ -4565,7 +4565,7 @@ struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 			return ERR_PTR(-ESTALE);
 		__ext4_error(sb, function, line, false, EFSCORRUPTED, 0,
 			     "inode #%lu: comm %s: iget: illegal inode #",
-			     ino, current->comm);
+			     ino, sysiso_current->comm);
 		return ERR_PTR(-EFSCORRUPTED);
 	}
 
@@ -5157,7 +5157,7 @@ int ext4_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
 	int err;
 
-	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC) ||
+	if (WARN_ON_ONCE(sysiso_current->flags & PF_MEMALLOC) ||
 	    sb_rdonly(inode->i_sb))
 		return 0;
 
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 72bfac2d6..d6e592bbd 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -6323,7 +6323,7 @@ __releases(ext4_group_lock_ptr(sb, e4b->bd_group))
 		free_count += next - start;
 		start = next + 1;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			count = -ERESTARTSYS;
 			break;
 		}
diff --git a/fs/ext4/mballoc.h b/fs/ext4/mballoc.h
index 39da92cea..9a9e45c50 100644
--- a/fs/ext4/mballoc.h
+++ b/fs/ext4/mballoc.h
@@ -29,7 +29,7 @@
 #ifdef CONFIG_EXT4_DEBUG
 #define mb_debug(sb, fmt, ...)						\
 	pr_debug("[%s/%d] EXT4-fs (%s): (%s, %d): %s: " fmt,		\
-		current->comm, task_pid_nr(current), sb->s_id,		\
+		sysiso_current->comm, task_pid_nr(current), sb->s_id,		\
 	       __FILE__, __LINE__, __func__, ##__VA_ARGS__)
 #else
 #define mb_debug(sb, fmt, ...)	no_printk(fmt, ##__VA_ARGS__)
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index da7698341..c70f8940d 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -119,7 +119,7 @@ static struct buffer_head *__ext4_read_dirblock(struct inode *inode,
 			       "inode #%lu: lblock %lu: comm %s: "
 			       "error %ld reading directory block",
 			       inode->i_ino, (unsigned long)block,
-			       current->comm, PTR_ERR(bh));
+			       sysiso_current->comm, PTR_ERR(bh));
 
 		return bh;
 	}
@@ -1192,7 +1192,7 @@ int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 	}
 
 	while (1) {
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto errout;
 		}
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 88d5d274a..7d498949a 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -756,7 +756,7 @@ void __ext4_error(struct super_block *sb, const char *function,
 		vaf.va = &args;
 		printk(KERN_CRIT
 		       "EXT4-fs error (device %s): %s:%d: comm %s: %pV\n",
-		       sb->s_id, function, line, current->comm, &vaf);
+		       sb->s_id, function, line, sysiso_current->comm, &vaf);
 		va_end(args);
 	}
 	ext4_handle_error(sb, force_ro, error, 0, block, function, line);
@@ -781,12 +781,12 @@ void __ext4_error_inode(struct inode *inode, const char *function,
 			printk(KERN_CRIT "EXT4-fs error (device %s): %s:%d: "
 			       "inode #%lu: block %llu: comm %s: %pV\n",
 			       inode->i_sb->s_id, function, line, inode->i_ino,
-			       block, current->comm, &vaf);
+			       block, sysiso_current->comm, &vaf);
 		else
 			printk(KERN_CRIT "EXT4-fs error (device %s): %s:%d: "
 			       "inode #%lu: comm %s: %pV\n",
 			       inode->i_sb->s_id, function, line, inode->i_ino,
-			       current->comm, &vaf);
+			       sysiso_current->comm, &vaf);
 		va_end(args);
 	}
 	ext4_handle_error(inode->i_sb, false, error, inode->i_ino, block,
@@ -818,13 +818,13 @@ void __ext4_error_file(struct file *file, const char *function,
 			       "EXT4-fs error (device %s): %s:%d: inode #%lu: "
 			       "block %llu: comm %s: path %s: %pV\n",
 			       inode->i_sb->s_id, function, line, inode->i_ino,
-			       block, current->comm, path, &vaf);
+			       block, sysiso_current->comm, path, &vaf);
 		else
 			printk(KERN_CRIT
 			       "EXT4-fs error (device %s): %s:%d: inode #%lu: "
 			       "comm %s: path %s: %pV\n",
 			       inode->i_sb->s_id, function, line, inode->i_ino,
-			       current->comm, path, &vaf);
+			       sysiso_current->comm, path, &vaf);
 		va_end(args);
 	}
 	ext4_handle_error(inode->i_sb, false, EFSCORRUPTED, inode->i_ino, block,
@@ -953,7 +953,7 @@ void __ext4_warning_inode(const struct inode *inode, const char *function,
 	vaf.va = &args;
 	printk(KERN_WARNING "EXT4-fs warning (device %s): %s:%d: "
 	       "inode #%lu: comm %s: %pV\n", inode->i_sb->s_id,
-	       function, line, inode->i_ino, current->comm, &vaf);
+	       function, line, inode->i_ino, sysiso_current->comm, &vaf);
 	va_end(args);
 }
 
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index 1e0fc1ed8..bc828af23 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -1467,7 +1467,7 @@ ext4_xattr_inode_cache_find(struct inode *inode, const void *value,
 		return NULL;
 
 	WARN_ON_ONCE(ext4_handle_valid(journal_current_handle()) &&
-		     !(current->flags & PF_MEMALLOC_NOFS));
+		     !(sysiso_current->flags & PF_MEMALLOC_NOFS));
 
 	ea_data = kvmalloc(value_len, GFP_KERNEL);
 	if (!ea_data) {
@@ -2313,7 +2313,7 @@ ext4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,
 			error = -ENOSPC;
 			goto cleanup;
 		}
-		WARN_ON_ONCE(!(current->flags & PF_MEMALLOC_NOFS));
+		WARN_ON_ONCE(!(sysiso_current->flags & PF_MEMALLOC_NOFS));
 	}
 
 	error = ext4_reserve_inode_write(handle, inode, &is.iloc);
diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c
index f4fd6c246..d4acedadd 100644
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@ -2005,7 +2005,7 @@ int f2fs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 
 prep_next:
 	cond_resched();
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		ret = -EINTR;
 	else
 		goto next;
diff --git a/fs/f2fs/dir.c b/fs/f2fs/dir.c
index 1820e9c10..5c7de24b4 100644
--- a/fs/f2fs/dir.c
+++ b/fs/f2fs/dir.c
@@ -1105,7 +1105,7 @@ static int f2fs_readdir(struct file *file, struct dir_context *ctx)
 	for (; n < npages; n++, ctx->pos = n * NR_DENTRY_IN_BLOCK) {
 
 		/* allow readdir() to be interrupted */
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto out_free;
 		}
diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c
index 9c8ef33bd..f266d2a83 100644
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@ -3841,7 +3841,7 @@ static int f2fs_sec_trim_file(struct file *filp, unsigned long arg)
 
 		f2fs_put_dnode(&dn);
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			goto out;
 		}
diff --git a/fs/f2fs/gc.c b/fs/f2fs/gc.c
index 77391e3b7..a9eae3b96 100644
--- a/fs/f2fs/gc.c
+++ b/fs/f2fs/gc.c
@@ -42,7 +42,7 @@ static int gc_thread_func(void *data)
 		bool sync_mode, foreground = false;
 
 		wait_event_interruptible_timeout(*wq,
-				kthread_should_stop() || freezing(current) ||
+				kthread_should_stop() || freezing(sysiso_current) ||
 				waitqueue_active(fggc_wq) ||
 				gc_th->gc_wake,
 				msecs_to_jiffies(wait_ms));
@@ -1886,7 +1886,7 @@ static int free_segment_range(struct f2fs_sb_info *sbi,
 			err = -EAGAIN;
 			goto out;
 		}
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto out;
 		}
diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c
index a135d2247..6dc3c1c5c 100644
--- a/fs/f2fs/segment.c
+++ b/fs/f2fs/segment.c
@@ -1781,7 +1781,7 @@ static int issue_discard_thread(void *data)
 		       wait_ms = dpolicy.max_interval;
 
 		wait_event_interruptible_timeout(*q,
-				kthread_should_stop() || freezing(current) ||
+				kthread_should_stop() || freezing(sysiso_current) ||
 				dcc->discard_wake,
 				msecs_to_jiffies(wait_ms));
 
@@ -3110,7 +3110,7 @@ static unsigned int __issue_discard_cmd_range(struct f2fs_sb_info *sbi,
 			__remove_discard_cmd(sbi, dc);
 		dc = rb_entry_safe(node, struct discard_cmd, rb_node);
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			break;
 	}
 
diff --git a/fs/fat/fatent.c b/fs/fat/fatent.c
index 978ac6751..a5e6084de 100644
--- a/fs/fat/fatent.c
+++ b/fs/fat/fatent.c
@@ -813,7 +813,7 @@ int fat_trim_fs(struct inode *inode, struct fstrim_range *range)
 			}
 		} while (fat_ent_next(sbi, &fatent) && fatent.entry <= ent_end);
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto error;
 		}
diff --git a/fs/fhandle.c b/fs/fhandle.c
index 6630c69c2..743a76424 100644
--- a/fs/fhandle.c
+++ b/fs/fhandle.c
@@ -117,7 +117,7 @@ static struct vfsmount *get_vfsmount_from_fd(int fd)
 	struct vfsmount *mnt;
 
 	if (fd == AT_FDCWD) {
-		struct fs_struct *fs = current->fs;
+		struct fs_struct *fs = sysiso_current->fs;
 		spin_lock(&fs->lock);
 		mnt = mntget(fs->pwd.mnt);
 		spin_unlock(&fs->lock);
diff --git a/fs/file.c b/fs/file.c
index 8627dacfc..1084c1f7d 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -469,7 +469,7 @@ static unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)
  */
 static int alloc_fd(unsigned start, unsigned end, unsigned flags)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	unsigned int fd;
 	int error;
 	struct fdtable *fdt;
@@ -546,7 +546,7 @@ static void __put_unused_fd(struct files_struct *files, unsigned int fd)
 
 void put_unused_fd(unsigned int fd)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	spin_lock(&files->file_lock);
 	__put_unused_fd(files, fd);
 	spin_unlock(&files->file_lock);
@@ -572,7 +572,7 @@ EXPORT_SYMBOL(put_unused_fd);
 
 void fd_install(unsigned int fd, struct file *file)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct fdtable *fdt;
 
 	rcu_read_lock_sched();
@@ -632,7 +632,7 @@ static struct file *pick_file(struct files_struct *files, unsigned fd)
 
 int close_fd(unsigned fd)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct file *file;
 
 	file = pick_file(files, fd);
@@ -701,7 +701,7 @@ static inline void __range_close(struct files_struct *cur_fds, unsigned int fd,
  */
 int __close_range(unsigned fd, unsigned max_fd, unsigned int flags)
 {
-	struct task_struct *me = current;
+	struct task_struct *me = sysiso_current;
 	struct files_struct *cur_fds = me->files, *fds = NULL;
 
 	if (flags & ~(CLOSE_RANGE_UNSHARE | CLOSE_RANGE_CLOEXEC))
@@ -768,7 +768,7 @@ int __close_range(unsigned fd, unsigned max_fd, unsigned int flags)
  */
 int __close_fd_get_file(unsigned int fd, struct file **res)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct file *file;
 	struct fdtable *fdt;
 
@@ -795,7 +795,7 @@ int __close_fd_get_file(unsigned int fd, struct file **res)
  */
 int close_fd_get_file(unsigned int fd, struct file **res)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	int ret;
 
 	spin_lock(&files->file_lock);
@@ -867,7 +867,7 @@ static struct file *__fget_files(struct files_struct *files, unsigned int fd,
 static inline struct file *__fget(unsigned int fd, fmode_t mask,
 				  unsigned int refs)
 {
-	return __fget_files(current->files, fd, mask, refs);
+	return __fget_files(sysiso_current->files, fd, mask, refs);
 }
 
 struct file *fget_many(unsigned int fd, unsigned int refs)
@@ -953,7 +953,7 @@ struct file *task_lookup_next_fd_rcu(struct task_struct *task, unsigned int *ret
  */
 static unsigned long __fget_light(unsigned int fd, fmode_t mask)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct file *file;
 
 	if (atomic_read(&files->count) == 1) {
@@ -1006,7 +1006,7 @@ void __f_unlock_pos(struct file *f)
 
 void set_close_on_exec(unsigned int fd, int flag)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct fdtable *fdt;
 	spin_lock(&files->file_lock);
 	fdt = files_fdtable(files);
@@ -1019,7 +1019,7 @@ void set_close_on_exec(unsigned int fd, int flag)
 
 bool get_close_on_exec(unsigned int fd)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct fdtable *fdt;
 	bool res;
 	rcu_read_lock();
@@ -1076,7 +1076,7 @@ __releases(&files->file_lock)
 int replace_fd(unsigned fd, struct file *file, unsigned flags)
 {
 	int err;
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 
 	if (!file)
 		return close_fd(fd);
@@ -1160,7 +1160,7 @@ static int ksys_dup3(unsigned int oldfd, unsigned int newfd, int flags)
 {
 	int err = -EBADF;
 	struct file *file;
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 
 	if ((flags & ~O_CLOEXEC) != 0)
 		return -EINVAL;
@@ -1198,7 +1198,7 @@ SYSCALL_DEFINE3(dup3, unsigned int, oldfd, unsigned int, newfd, int, flags)
 SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)
 {
 	if (unlikely(newfd == oldfd)) { /* corner case */
-		struct files_struct *files = current->files;
+		struct files_struct *files = sysiso_current->files;
 		int retval = oldfd;
 
 		rcu_read_lock();
diff --git a/fs/file_table.c b/fs/file_table.c
index 45437f8e1..128904649 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -334,7 +334,7 @@ static DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);
 void fput_many(struct file *file, unsigned int refs)
 {
 	if (atomic_long_sub_and_test(refs, &file->f_count)) {
-		struct task_struct *task = current;
+		struct task_struct *task = sysiso_current;
 
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
@@ -368,7 +368,7 @@ void fput(struct file *file)
 void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
-		struct task_struct *task = current;
+		struct task_struct *task = sysiso_current;
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 81ec192ce..a4fd7df8e 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -2223,7 +2223,7 @@ void wb_workfn(struct work_struct *work)
 	long pages_written;
 
 	set_worker_desc("flush-%s", bdi_dev_name(wb->bdi));
-	current->flags |= PF_SWAPWRITE;
+	sysiso_current->flags |= PF_SWAPWRITE;
 
 	if (likely(!current_is_workqueue_rescuer() ||
 		   !test_bit(WB_registered, &wb->state))) {
@@ -2253,7 +2253,7 @@ void wb_workfn(struct work_struct *work)
 	else if (wb_has_dirty_io(wb) && dirty_writeback_interval)
 		wb_wakeup_delayed(wb);
 
-	current->flags &= ~PF_SWAPWRITE;
+	sysiso_current->flags &= ~PF_SWAPWRITE;
 }
 
 /*
diff --git a/fs/fs_context.c b/fs/fs_context.c
index b7e43a780..c4a1bef19 100644
--- a/fs/fs_context.c
+++ b/fs/fs_context.c
@@ -263,7 +263,7 @@ static struct fs_context *alloc_fs_context(struct file_system_type *fs_type,
 	fc->sb_flags_mask = sb_flags_mask;
 	fc->fs_type	= get_filesystem(fs_type);
 	fc->cred	= get_current_cred();
-	fc->net_ns	= get_net(current->nsproxy->net_ns);
+	fc->net_ns	= get_net(sysiso_current->nsproxy->net_ns);
 	fc->log.prefix	= fs_type->name;
 
 	mutex_init(&fc->uapi_mutex);
diff --git a/fs/fs_struct.c b/fs/fs_struct.c
index 04b3f5b9c..e26f2a5a7 100644
--- a/fs/fs_struct.c
+++ b/fs/fs_struct.c
@@ -132,19 +132,19 @@ struct fs_struct *copy_fs_struct(struct fs_struct *old)
 
 int unshare_fs_struct(void)
 {
-	struct fs_struct *fs = current->fs;
+	struct fs_struct *fs = sysiso_current->fs;
 	struct fs_struct *new_fs = copy_fs_struct(fs);
 	int kill;
 
 	if (!new_fs)
 		return -ENOMEM;
 
-	task_lock(current);
+	task_lock(sysiso_current);
 	spin_lock(&fs->lock);
 	kill = !--fs->users;
-	current->fs = new_fs;
+	sysiso_current->fs = new_fs;
 	spin_unlock(&fs->lock);
-	task_unlock(current);
+	task_unlock(sysiso_current);
 
 	if (kill)
 		free_fs_struct(fs);
@@ -155,7 +155,7 @@ EXPORT_SYMBOL_GPL(unshare_fs_struct);
 
 int current_umask(void)
 {
-	return current->fs->umask;
+	return sysiso_current->fs->umask;
 }
 EXPORT_SYMBOL(current_umask);
 
diff --git a/fs/fscache/internal.h b/fs/fscache/internal.h
index c3e4804b8..abf0b31f5 100644
--- a/fs/fscache/internal.h
+++ b/fs/fscache/internal.h
@@ -342,7 +342,7 @@ void fscache_update_aux(struct fscache_cookie *cookie, const void *aux_data)
  * debug tracing
  */
 #define dbgprintk(FMT, ...) \
-	printk(KERN_DEBUG "[%-6.6s] "FMT"\n", current->comm, ##__VA_ARGS__)
+	printk(KERN_DEBUG "[%-6.6s] "FMT"\n", sysiso_current->comm, ##__VA_ARGS__)
 
 #define kenter(FMT, ...) dbgprintk("==> %s("FMT")", __func__, ##__VA_ARGS__)
 #define kleave(FMT, ...) dbgprintk("<== %s()"FMT"", __func__, ##__VA_ARGS__)
diff --git a/fs/fsopen.c b/fs/fsopen.c
index 27a890aa4..e82396d04 100644
--- a/fs/fsopen.c
+++ b/fs/fsopen.c
@@ -119,7 +119,7 @@ SYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)
 	const char *fs_name;
 	int ret;
 
-	if (!ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
+	if (!ns_capable(sysiso_current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
 		return -EPERM;
 
 	if (flags & ~FSOPEN_CLOEXEC)
@@ -162,7 +162,7 @@ SYSCALL_DEFINE3(fspick, int, dfd, const char __user *, path, unsigned int, flags
 	unsigned int lookup_flags;
 	int ret;
 
-	if (!ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
+	if (!ns_capable(sysiso_current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN))
 		return -EPERM;
 
 	if ((flags & ~(FSPICK_CLOEXEC |
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index dde341a63..7f1cd3047 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -137,7 +137,7 @@ static struct fuse_req *fuse_get_req(struct fuse_mount *fm, bool for_background)
 
 	req->in.h.uid = from_kuid(fc->user_ns, current_fsuid());
 	req->in.h.gid = from_kgid(fc->user_ns, current_fsgid());
-	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
+	req->in.h.pid = pid_nr_ns(task_pid(sysiso_current), fc->pid_ns);
 
 	__set_bit(FR_WAITING, &req->flags);
 	if (for_background)
@@ -472,7 +472,7 @@ static void fuse_force_creds(struct fuse_req *req)
 
 	req->in.h.uid = from_kuid_munged(fc->user_ns, current_fsuid());
 	req->in.h.gid = from_kgid_munged(fc->user_ns, current_fsgid());
-	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
+	req->in.h.pid = pid_nr_ns(task_pid(sysiso_current), fc->pid_ns);
 }
 
 static void fuse_args_to_req(struct fuse_req *req, struct fuse_args *args)
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index d9b977c0f..f2f430152 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -1644,7 +1644,8 @@ int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
 	if (attr->ia_valid & ATTR_SIZE) {
 		/* For mandatory locking in truncate */
 		inarg.valid |= FATTR_LOCKOWNER;
-		inarg.lock_owner = fuse_lock_owner_id(fc, current->files);
+		inarg.lock_owner = fuse_lock_owner_id(fc,
+						      sysiso_current->files);
 
 		/* Kill suid/sgid for truncate only if no CAP_FSETID */
 		if (fc->handle_killpriv_v2 && !capable(CAP_FSETID))
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 11404f8c2..0ad1e8f33 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1463,7 +1463,7 @@ ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter *iter,
 	io->should_dirty = !write && iter_is_iovec(iter);
 	while (count) {
 		ssize_t nres;
-		fl_owner_t owner = current->files;
+		fl_owner_t owner = sysiso_current->files;
 		size_t nbytes = min(count, nmax);
 
 		err = fuse_get_user_pages(&ia->ap, iter, &nbytes, write,
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 12d49a191..fdac5204c 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -792,7 +792,7 @@ void fuse_conn_init(struct fuse_conn *fc, struct fuse_mount *fm,
 	fc->connected = 1;
 	atomic64_set(&fc->attr_version, 1);
 	get_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));
-	fc->pid_ns = get_pid_ns(task_active_pid_ns(current));
+	fc->pid_ns = get_pid_ns(task_active_pid_ns(sysiso_current));
 	fc->user_ns = get_user_ns(user_ns);
 	fc->max_pages = FUSE_DEFAULT_MAX_PAGES_PER_REQ;
 	fc->max_pages_limit = FUSE_MAX_MAX_PAGES;
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index e0eaa9cf9..3dfeda2e6 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -1125,7 +1125,7 @@ void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, u16 flags,
 	INIT_LIST_HEAD(&gh->gh_list);
 	gh->gh_gl = gl;
 	gh->gh_ip = _RET_IP_;
-	gh->gh_owner_pid = get_pid(task_pid(current));
+	gh->gh_owner_pid = get_pid(task_pid(sysiso_current));
 	gh->gh_state = state;
 	gh->gh_flags = flags;
 	gh->gh_error = 0;
@@ -1150,7 +1150,7 @@ void gfs2_holder_reinit(unsigned int state, u16 flags, struct gfs2_holder *gh)
 	gh->gh_iflags = 0;
 	gh->gh_ip = _RET_IP_;
 	put_pid(gh->gh_owner_pid);
-	gh->gh_owner_pid = get_pid(task_pid(current));
+	gh->gh_owner_pid = get_pid(task_pid(sysiso_current));
 }
 
 /**
diff --git a/fs/gfs2/lock_dlm.c b/fs/gfs2/lock_dlm.c
index 50578f881..521cb449f 100644
--- a/fs/gfs2/lock_dlm.c
+++ b/fs/gfs2/lock_dlm.c
@@ -818,7 +818,7 @@ static int control_mount(struct gfs2_sbd *sdp)
 	mounted_mode = DLM_LOCK_NL;
 
 restart:
-	if (retries++ && signal_pending(current)) {
+	if (retries++ && signal_pending(sysiso_current)) {
 		error = -EINTR;
 		goto fail;
 	}
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 6e00d15ef..d96cfd890 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -822,7 +822,7 @@ static int gfs2_statfs_slow(struct gfs2_sbd *sdp, struct gfs2_statfs_change_host
 				done = 0;
 			}
 
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				error = -ERESTARTSYS;
 		}
 
@@ -940,7 +940,7 @@ static int gfs2_drop_inode(struct inode *inode)
 	 * calling into DLM under memory pressure, which can deadlock.
 	 */
 	if (!inode->i_nlink &&
-	    unlikely(current->flags & PF_MEMALLOC) &&
+	    unlikely(sysiso_current->flags & PF_MEMALLOC) &&
 	    gfs2_holder_initialized(&ip->i_iopen_gh)) {
 		struct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;
 
@@ -1144,7 +1144,7 @@ static int gfs2_dinode_dealloc(struct gfs2_inode *ip)
 
 static void gfs2_glock_put_eventually(struct gfs2_glock *gl)
 {
-	if (current->flags & PF_MEMALLOC)
+	if (sysiso_current->flags & PF_MEMALLOC)
 		gfs2_glock_queue_put(gl);
 	else
 		gfs2_glock_put(gl);
@@ -1226,7 +1226,7 @@ static enum dinode_demise evict_should_delete(struct inode *inode,
 		return SHOULD_DEFER_EVICTION;
 
 	/* Deletes should never happen under memory pressure anymore.  */
-	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
+	if (WARN_ON_ONCE(sysiso_current->flags & PF_MEMALLOC))
 		return SHOULD_DEFER_EVICTION;
 
 	/* Must not read inode block until block type has been verified */
diff --git a/fs/hpfs/alloc.c b/fs/hpfs/alloc.c
index 66617b155..5783150d4 100644
--- a/fs/hpfs/alloc.c
+++ b/fs/hpfs/alloc.c
@@ -504,7 +504,7 @@ static int do_trim(struct super_block *s, secno start, unsigned len, secno limit
 {
 	int err;
 	secno end;
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 	end = start + len;
 	if (start < limit_start)
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index cdfb1ae78..5823e43e1 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -688,7 +688,7 @@ static long hugetlbfs_fallocate(struct file *file, int mode, loff_t offset,
 		 * fallocate(2) manpage permits EINTR; we may have been
 		 * interrupted because we are using up too much memory.
 		 */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			error = -EINTR;
 			break;
 		}
@@ -1466,10 +1466,10 @@ struct file *hugetlb_file_setup(const char *name, size_t size,
 	if (creat_flags == HUGETLB_SHMFS_INODE && !can_do_hugetlb_shm()) {
 		*ucounts = current_ucounts();
 		if (user_shm_lock(size, *ucounts)) {
-			task_lock(current);
+			task_lock(sysiso_current);
 			pr_warn_once("%s (%d): Using mlock ulimits for SHM_HUGETLB is deprecated\n",
-				current->comm, current->pid);
-			task_unlock(current);
+				sysiso_current->comm, sysiso_current->pid);
+			task_unlock(sysiso_current);
 		} else {
 			*ucounts = NULL;
 			return ERR_PTR(-EPERM);
diff --git a/fs/init.c b/fs/init.c
index 5c36adaa9..82be42385 100644
--- a/fs/init.c
+++ b/fs/init.c
@@ -51,7 +51,7 @@ int __init init_chdir(const char *filename)
 		return error;
 	error = path_permission(&path, MAY_EXEC | MAY_CHDIR);
 	if (!error)
-		set_fs_pwd(current->fs, &path);
+		set_fs_pwd(sysiso_current->fs, &path);
 	path_put(&path);
 	return error;
 }
@@ -73,7 +73,7 @@ int __init init_chroot(const char *filename)
 	error = security_path_chroot(&path);
 	if (error)
 		goto dput_and_out;
-	set_fs_root(current->fs, &path);
+	set_fs_root(sysiso_current->fs, &path);
 dput_and_out:
 	path_put(&path);
 	return error;
diff --git a/fs/inode.c b/fs/inode.c
index ed0cab8a3..d58708f43 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -783,8 +783,8 @@ static enum lru_status inode_lru_isolate(struct list_head *item,
 				__count_vm_events(KSWAPD_INODESTEAL, reap);
 			else
 				__count_vm_events(PGINODESTEAL, reap);
-			if (current->reclaim_state)
-				current->reclaim_state->reclaimed_slab += reap;
+			if (sysiso_current->reclaim_state)
+				sysiso_current->reclaim_state->reclaimed_slab += reap;
 		}
 		iput(inode);
 		spin_lock(lru_lock);
diff --git a/fs/io-wq.c b/fs/io-wq.c
index 422a7ed6a..67bd56c96 100644
--- a/fs/io-wq.c
+++ b/fs/io-wq.c
@@ -189,7 +189,7 @@ static void io_worker_exit(struct io_worker *worker)
 	preempt_disable();
 	io_wqe_dec_running(worker);
 	worker->flags = 0;
-	current->flags &= ~PF_IO_WORKER;
+	sysiso_current->flags &= ~PF_IO_WORKER;
 	preempt_enable();
 	raw_spin_unlock(&wqe->lock);
 
@@ -579,7 +579,7 @@ static int io_wqe_worker(void *data)
 		if (io_flush_signals())
 			continue;
 		ret = schedule_timeout(WORKER_IDLE_TIMEOUT);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			struct ksignal ksig;
 
 			if (!get_signal(&ksig))
diff --git a/fs/io-wq.h b/fs/io-wq.h
index bf5c4c533..74d00039e 100644
--- a/fs/io-wq.h
+++ b/fs/io-wq.h
@@ -154,7 +154,7 @@ static inline void io_wq_worker_running(struct task_struct *tsk)
 
 static inline bool io_wq_current_is_worker(void)
 {
-	return in_task() && (current->flags & PF_IO_WORKER) &&
+	return in_task() && (sysiso_current->flags & PF_IO_WORKER) &&
 		current->pf_io_worker;
 }
 #endif
diff --git a/fs/io_uring.c b/fs/io_uring.c
index bc18af5e0..a1d43a4d7 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -1462,7 +1462,7 @@ static void io_queue_async_work(struct io_kiocb *req, bool *locked)
 	 * procedure rather than attempt to run this request (or create a new
 	 * worker for it).
 	 */
-	if (WARN_ON_ONCE(!same_thread_group(req->task, current)))
+	if (WARN_ON_ONCE(!same_thread_group(req->task, sysiso_current)))
 		req->work.flags |= IO_WQ_WORK_CANCEL;
 
 	trace_io_uring_queue_async_work(ctx, io_wq_is_hashed(&req->work), req,
@@ -2411,7 +2411,7 @@ static inline unsigned int io_put_rw_kbuf(struct io_kiocb *req)
 
 static inline bool io_run_task_work(void)
 {
-	if (test_thread_flag(TIF_NOTIFY_SIGNAL) || current->task_works) {
+	if (test_thread_flag(TIF_NOTIFY_SIGNAL) || sysiso_current->task_works) {
 		__set_current_state(TASK_RUNNING);
 		tracehook_notify_signal();
 		return true;
@@ -2624,7 +2624,7 @@ static bool io_rw_should_reissue(struct io_kiocb *req)
 	 * Play it safe and assume not safe to re-import and reissue if we're
 	 * not in the original thread group (or in task context).
 	 */
-	if (!same_thread_group(req->task, current) || !in_task())
+	if (!same_thread_group(req->task, sysiso_current) || !in_task())
 		return false;
 	return true;
 }
@@ -4601,7 +4601,7 @@ static int io_close_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
 
 static int io_close(struct io_kiocb *req, unsigned int issue_flags)
 {
-	struct files_struct *files = current->files;
+	struct files_struct *files = sysiso_current->files;
 	struct io_close *close = &req->close;
 	struct fdtable *fdt;
 	struct file *file = NULL;
@@ -4640,7 +4640,7 @@ static int io_close(struct io_kiocb *req, unsigned int issue_flags)
 	}
 
 	/* No ->flush() or already async, safely close from here */
-	ret = filp_close(file, current->files);
+	ret = filp_close(file, sysiso_current->files);
 err:
 	if (ret < 0)
 		req_set_fail(req);
@@ -7383,9 +7383,9 @@ static bool io_sqd_handle_event(struct io_sq_data *sqd)
 	struct ksignal ksig;
 
 	if (test_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state) ||
-	    signal_pending(current)) {
+	    signal_pending(sysiso_current)) {
 		mutex_unlock(&sqd->lock);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			did_sig = get_signal(&ksig);
 		cond_resched();
 		mutex_lock(&sqd->lock);
@@ -7408,13 +7408,13 @@ static int io_sq_thread(void *data)
 		set_cpus_allowed_ptr(current, cpumask_of(sqd->sq_cpu));
 	else
 		set_cpus_allowed_ptr(current, cpu_online_mask);
-	current->flags |= PF_NO_SETAFFINITY;
+	sysiso_current->flags |= PF_NO_SETAFFINITY;
 
 	mutex_lock(&sqd->lock);
 	while (1) {
 		bool cap_entries, sqt_spin = false;
 
-		if (io_sqd_events_pending(sqd) || signal_pending(current)) {
+		if (io_sqd_events_pending(sqd) || signal_pending(sysiso_current)) {
 			if (io_sqd_handle_event(sqd))
 				break;
 			timeout = jiffies + sqd->sq_thread_idle;
@@ -7438,7 +7438,7 @@ static int io_sq_thread(void *data)
 		}
 
 		prepare_to_wait(&sqd->wait, &wait, TASK_INTERRUPTIBLE);
-		if (!io_sqd_events_pending(sqd) && !current->task_works) {
+		if (!io_sqd_events_pending(sqd) && !sysiso_current->task_works) {
 			bool needs_sched = true;
 
 			list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {
@@ -7518,7 +7518,7 @@ static int io_run_task_work_sig(void)
 {
 	if (io_run_task_work())
 		return 1;
-	if (!signal_pending(current))
+	if (!signal_pending(sysiso_current))
 		return 0;
 	if (test_thread_flag(TIF_NOTIFY_SIGNAL))
 		return -ERESTARTSYS;
@@ -7960,7 +7960,7 @@ static struct io_sq_data *io_attach_sq_data(struct io_uring_params *p)
 		fdput(f);
 		return ERR_PTR(-EINVAL);
 	}
-	if (sqd->task_tgid != current->tgid) {
+	if (sqd->task_tgid != sysiso_current->tgid) {
 		fdput(f);
 		return ERR_PTR(-EPERM);
 	}
@@ -8662,8 +8662,8 @@ static int io_sq_offload_create(struct io_ring_ctx *ctx,
 			sqd->sq_cpu = -1;
 		}
 
-		sqd->task_pid = current->pid;
-		sqd->task_tgid = current->tgid;
+		sqd->task_pid = sysiso_current->pid;
+		sqd->task_tgid = sysiso_current->tgid;
 		tsk = create_io_thread(io_sq_thread, sqd, NUMA_NO_NODE);
 		if (IS_ERR(tsk)) {
 			ret = PTR_ERR(tsk);
@@ -9895,7 +9895,7 @@ static int io_sqpoll_wait_sq(struct io_ring_ctx *ctx)
 		if (!io_sqring_full(ctx))
 			break;
 		schedule();
-	} while (!signal_pending(current));
+	} while (!signal_pending(sysiso_current));
 
 	finish_wait(&ctx->sqo_sq_wait, &wait);
 	return 0;
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 504e69578..b5696c818 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -79,7 +79,8 @@ static int ioctl_fibmap(struct file *filp, int __user *p)
 	if (block > INT_MAX) {
 		error = -ERANGE;
 		pr_warn_ratelimited("[%s/%d] FS: %s File: %pD4 would truncate fibmap result\n",
-				    current->comm, task_pid_nr(current),
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current),
 				    sb->s_id, filp);
 	}
 
diff --git a/fs/iomap/buffered-io.c b/fs/iomap/buffered-io.c
index 9cc579842..b3bd1c7a2 100644
--- a/fs/iomap/buffered-io.c
+++ b/fs/iomap/buffered-io.c
@@ -603,7 +603,7 @@ static int iomap_write_begin(const struct iomap_iter *iter, loff_t pos,
 	if (srcmap != &iter->iomap)
 		BUG_ON(pos + len > srcmap->offset + srcmap->length);
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 	if (page_ops && page_ops->page_prepare) {
@@ -1404,7 +1404,7 @@ iomap_do_writepage(struct page *page, struct writeback_control *wbc, void *data)
 	 * This should never happen except in the case of a VM regression so
 	 * warn about it.
 	 */
-	if (WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==
+	if (WARN_ON_ONCE((sysiso_current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==
 			PF_MEMALLOC))
 		goto redirty;
 
diff --git a/fs/iomap/direct-io.c b/fs/iomap/direct-io.c
index 4ecd255e0..9a7dc2565 100644
--- a/fs/iomap/direct-io.c
+++ b/fs/iomap/direct-io.c
@@ -429,7 +429,7 @@ static loff_t iomap_dio_iter(const struct iomap_iter *iter,
 		 * DELALLOC block that the page-mkwrite allocated.
 		 */
 		pr_warn_ratelimited("Direct I/O collision with buffered writes! File: %pD4 Comm: %.20s\n",
-				    dio->iocb->ki_filp, current->comm);
+				    dio->iocb->ki_filp, sysiso_current->comm);
 		return -EIO;
 	default:
 		WARN_ON_ONCE(1);
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 35302bc19..39db7b3e4 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -216,7 +216,7 @@ static int kjournald2(void *arg)
 	}
 
 	wake_up(&journal->j_wait_done_commit);
-	if (freezing(current)) {
+	if (freezing(sysiso_current)) {
 		/*
 		 * The simpler the better. Flushing journal isn't a
 		 * good idea, because that depends on threads that may
diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index 6a3caedd2..5ad753871 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -353,7 +353,7 @@ static int start_this_handle(journal_t *journal, handle_t *handle,
 	    (rsv_blocks + blocks > journal->j_max_transaction_buffers)) {
 		printk(KERN_ERR "JBD2: %s wants too many credits "
 		       "credits:%d rsv_credits:%d max:%d\n",
-		       current->comm, blocks, rsv_blocks,
+		       sysiso_current->comm, blocks, rsv_blocks,
 		       journal->j_max_transaction_buffers);
 		WARN_ON(1);
 		return -ENOSPC;
@@ -1866,7 +1866,7 @@ int jbd2_journal_stop(handle_t *handle)
 	 *
 	 * Setting max_batch_time to 0 disables this completely.
 	 */
-	pid = current->pid;
+	pid = sysiso_current->pid;
 	if (handle->h_sync && journal->j_last_sync_writer != pid &&
 	    journal->j_max_batch_time) {
 		u64 commit_time, trans_time;
@@ -1916,7 +1916,7 @@ int jbd2_journal_stop(handle_t *handle)
 		 * Special case: JBD2_SYNC synchronous updates require us
 		 * to wait for the commit to complete.
 		 */
-		if (handle->h_sync && !(current->flags & PF_MEMALLOC))
+		if (handle->h_sync && !(sysiso_current->flags & PF_MEMALLOC))
 			wait_for_commit = 1;
 	}
 
diff --git a/fs/jffs2/background.c b/fs/jffs2/background.c
index 2b4d5013d..9d49373d0 100644
--- a/fs/jffs2/background.c
+++ b/fs/jffs2/background.c
@@ -119,7 +119,7 @@ static int jffs2_garbage_collect_thread(void *_c)
 
 		/* Put_super will send a SIGKILL and then wait on the sem.
 		 */
-		while (signal_pending(current) || freezing(current)) {
+		while (signal_pending(sysiso_current) || freezing(sysiso_current)) {
 			unsigned long signr;
 
 			if (try_to_freeze())
diff --git a/fs/jffs2/nodemgmt.c b/fs/jffs2/nodemgmt.c
index a7bbe879c..e65d25ed1 100644
--- a/fs/jffs2/nodemgmt.c
+++ b/fs/jffs2/nodemgmt.c
@@ -187,7 +187,7 @@ int jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,
 
 			cond_resched();
 
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -EINTR;
 
 			mutex_lock(&c->alloc_sem);
diff --git a/fs/jfs/jfs_logmgr.c b/fs/jfs/jfs_logmgr.c
index 78fd136ac..1a36f4992 100644
--- a/fs/jfs/jfs_logmgr.c
+++ b/fs/jfs/jfs_logmgr.c
@@ -2332,7 +2332,7 @@ int jfsIOWait(void *arg)
 			spin_lock_irq(&log_redrive_lock);
 		}
 
-		if (freezing(current)) {
+		if (freezing(sysiso_current)) {
 			spin_unlock_irq(&log_redrive_lock);
 			try_to_freeze();
 		} else {
diff --git a/fs/jfs/jfs_txnmgr.c b/fs/jfs/jfs_txnmgr.c
index 042bbe6d8..300a6bd4d 100644
--- a/fs/jfs/jfs_txnmgr.c
+++ b/fs/jfs/jfs_txnmgr.c
@@ -2777,7 +2777,7 @@ int jfs_lazycommit(void *arg)
 		/* In case a wakeup came while all threads were active */
 		jfs_commit_thread_waking = 0;
 
-		if (freezing(current)) {
+		if (freezing(sysiso_current)) {
 			LAZY_UNLOCK(flags);
 			try_to_freeze();
 		} else {
@@ -2966,7 +2966,7 @@ int jfs_sync(void *arg)
 		/* Add anon_list2 back to anon_list */
 		list_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);
 
-		if (freezing(current)) {
+		if (freezing(sysiso_current)) {
 			TXN_UNLOCK();
 			try_to_freeze();
 		} else {
diff --git a/fs/ksmbd/smb2pdu.c b/fs/ksmbd/smb2pdu.c
index 7e448df3f..f94b82589 100644
--- a/fs/ksmbd/smb2pdu.c
+++ b/fs/ksmbd/smb2pdu.c
@@ -6612,7 +6612,7 @@ struct file_lock *smb_flock_init(struct file *f)
 	locks_init_lock(fl);
 
 	fl->fl_owner = f;
-	fl->fl_pid = current->tgid;
+	fl->fl_pid = sysiso_current->tgid;
 	fl->fl_file = f;
 	fl->fl_flags = FL_POSIX;
 	fl->fl_ops = NULL;
diff --git a/fs/lockd/procfs.c b/fs/lockd/procfs.c
index a01f08c8c..805e91c3a 100644
--- a/fs/lockd/procfs.c
+++ b/fs/lockd/procfs.c
@@ -22,7 +22,7 @@ nlm_end_grace_write(struct file *file, const char __user *buf, size_t size,
 		    loff_t *pos)
 {
 	char *data;
-	struct lockd_net *ln = net_generic(current->nsproxy->net_ns,
+	struct lockd_net *ln = net_generic(sysiso_current->nsproxy->net_ns,
 					   lockd_net_id);
 
 	if (size < 1)
@@ -49,7 +49,7 @@ static ssize_t
 nlm_end_grace_read(struct file *file, char __user *buf, size_t size,
 		   loff_t *pos)
 {
-	struct lockd_net *ln = net_generic(current->nsproxy->net_ns,
+	struct lockd_net *ln = net_generic(sysiso_current->nsproxy->net_ns,
 					   lockd_net_id);
 	char resp[3];
 
diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.c
index e10ae2c41..cfb23c21f 100644
--- a/fs/lockd/svc4proc.c
+++ b/fs/lockd/svc4proc.c
@@ -49,7 +49,7 @@ nlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,
 
 		/* Set up the missing parts of the file_lock structure */
 		lock->fl.fl_file  = file->f_file[mode];
-		lock->fl.fl_pid = current->tgid;
+		lock->fl.fl_pid = sysiso_current->tgid;
 		lock->fl.fl_lmops = &nlmsvc_lock_operations;
 		nlmsvc_locks_init_private(&lock->fl, host, (pid_t)lock->svid);
 		if (!lock->fl.fl_owner) {
diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.c
index 99696d3f6..453602b37 100644
--- a/fs/lockd/svcproc.c
+++ b/fs/lockd/svcproc.c
@@ -78,7 +78,7 @@ nlmsvc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,
 		/* Set up the missing parts of the file_lock structure */
 		mode = lock_to_openmode(&lock->fl);
 		lock->fl.fl_file  = file->f_file[mode];
-		lock->fl.fl_pid = current->tgid;
+		lock->fl.fl_pid = sysiso_current->tgid;
 		lock->fl.fl_lmops = &nlmsvc_lock_operations;
 		nlmsvc_locks_init_private(&lock->fl, host, (pid_t)lock->svid);
 		if (!lock->fl.fl_owner) {
diff --git a/fs/locks.c b/fs/locks.c
index 3d6fb4ae8..dd59b9015 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -493,7 +493,7 @@ flock_make_lock(struct file *filp, unsigned int cmd, struct file_lock *fl)
 
 	fl->fl_file = filp;
 	fl->fl_owner = filp;
-	fl->fl_pid = current->tgid;
+	fl->fl_pid = sysiso_current->tgid;
 	fl->fl_flags = FL_FLOCK;
 	fl->fl_type = type;
 	fl->fl_end = OFFSET_MAX;
@@ -552,8 +552,8 @@ static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,
 	} else
 		fl->fl_end = OFFSET_MAX;
 
-	fl->fl_owner = current->files;
-	fl->fl_pid = current->tgid;
+	fl->fl_owner = sysiso_current->files;
+	fl->fl_pid = sysiso_current->tgid;
 	fl->fl_file = filp;
 	fl->fl_flags = FL_POSIX;
 	fl->fl_ops = NULL;
@@ -600,7 +600,7 @@ lease_setup(struct file_lock *fl, void **priv)
 	if (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))
 		*priv = NULL;
 
-	__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);
+	__f_setown(filp, task_pid(sysiso_current), PIDTYPE_TGID, 0);
 }
 
 static const struct lock_manager_operations lease_manager_ops = {
@@ -618,7 +618,7 @@ static int lease_init(struct file *filp, long type, struct file_lock *fl)
 		return -EINVAL;
 
 	fl->fl_owner = filp;
-	fl->fl_pid = current->tgid;
+	fl->fl_pid = sysiso_current->tgid;
 
 	fl->fl_file = filp;
 	fl->fl_flags = FL_LEASE;
@@ -2220,7 +2220,8 @@ static pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)
 
 static int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)
 {
-	flock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));
+	flock->l_pid = locks_translate_pid(fl,
+					   task_active_pid_ns(sysiso_current));
 #if BITS_PER_LONG == 32
 	/*
 	 * Make sure we can represent the posix lock via
@@ -2242,7 +2243,8 @@ static int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)
 #if BITS_PER_LONG == 32
 static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)
 {
-	flock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));
+	flock->l_pid = locks_translate_pid(fl,
+					   task_active_pid_ns(sysiso_current));
 	flock->l_start = fl->fl_start;
 	flock->l_len = fl->fl_end == OFFSET_MAX ? 0 :
 		fl->fl_end - fl->fl_start + 1;
@@ -2433,7 +2435,7 @@ int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,
 	 */
 	if (!error && file_lock->fl_type != F_UNLCK &&
 	    !(file_lock->fl_flags & FL_OFDLCK)) {
-		struct files_struct *files = current->files;
+		struct files_struct *files = sysiso_current->files;
 		/*
 		 * We need that spin_lock here - it prevents reordering between
 		 * update of i_flctx->flc_posix and check for it done in
@@ -2556,7 +2558,7 @@ int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,
 	 */
 	if (!error && file_lock->fl_type != F_UNLCK &&
 	    !(file_lock->fl_flags & FL_OFDLCK)) {
-		struct files_struct *files = current->files;
+		struct files_struct *files = sysiso_current->files;
 		/*
 		 * We need that spin_lock here - it prevents reordering between
 		 * update of i_flctx->flc_posix and check for it done in
@@ -2605,7 +2607,7 @@ void locks_remove_posix(struct file *filp, fl_owner_t owner)
 	lock.fl_start = 0;
 	lock.fl_end = OFFSET_MAX;
 	lock.fl_owner = owner;
-	lock.fl_pid = current->tgid;
+	lock.fl_pid = sysiso_current->tgid;
 	lock.fl_file = filp;
 	lock.fl_ops = NULL;
 	lock.fl_lmops = NULL;
diff --git a/fs/mpage.c b/fs/mpage.c
index 334e7d09a..4b87adda1 100644
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@ -78,7 +78,7 @@ mpage_alloc(struct block_device *bdev,
 	gfp_flags &= GFP_KERNEL;
 	bio = bio_alloc(gfp_flags, nr_vecs);
 
-	if (bio == NULL && (current->flags & PF_MEMALLOC)) {
+	if (bio == NULL && (sysiso_current->flags & PF_MEMALLOC)) {
 		while (!bio && (nr_vecs /= 2))
 			bio = bio_alloc(gfp_flags, nr_vecs);
 	}
diff --git a/fs/namei.c b/fs/namei.c
index 1946d9667..c3cb7edb5 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -590,7 +590,7 @@ struct nameidata {
 
 static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)
 {
-	struct nameidata *old = current->nameidata;
+	struct nameidata *old = sysiso_current->nameidata;
 	p->stack = p->internal;
 	p->depth = 0;
 	p->dfd = dfd;
@@ -599,7 +599,7 @@ static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)
 	p->path.dentry = NULL;
 	p->total_link_count = old ? old->total_link_count : 0;
 	p->saved = old;
-	current->nameidata = p;
+	sysiso_current->nameidata = p;
 }
 
 static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name,
@@ -615,9 +615,9 @@ static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *
 
 static void restore_nameidata(void)
 {
-	struct nameidata *now = current->nameidata, *old = now->saved;
+	struct nameidata *now = sysiso_current->nameidata, *old = now->saved;
 
-	current->nameidata = old;
+	sysiso_current->nameidata = old;
 	if (old)
 		old->total_link_count = now->total_link_count;
 	if (now->stack != now->internal)
@@ -923,7 +923,7 @@ static int complete_walk(struct nameidata *nd)
 
 static int set_root(struct nameidata *nd)
 {
-	struct fs_struct *fs = current->fs;
+	struct fs_struct *fs = sysiso_current->fs;
 
 	/*
 	 * Jumping to the real root in a scoped-lookup is a BUG in namei, but we
@@ -987,7 +987,7 @@ static int nd_jump_root(struct nameidata *nd)
 int nd_jump_link(struct path *path)
 {
 	int error = -ELOOP;
-	struct nameidata *nd = current->nameidata;
+	struct nameidata *nd = sysiso_current->nameidata;
 
 	if (unlikely(nd->flags & LOOKUP_NO_MAGICLINKS))
 		goto err;
@@ -2365,7 +2365,7 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
 	/* Relative pathname -- get the starting-point it is relative to. */
 	if (nd->dfd == AT_FDCWD) {
 		if (flags & LOOKUP_RCU) {
-			struct fs_struct *fs = current->fs;
+			struct fs_struct *fs = sysiso_current->fs;
 			unsigned seq;
 
 			do {
@@ -2375,7 +2375,7 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
 				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
 			} while (read_seqcount_retry(&fs->seq, seq));
 		} else {
-			get_fs_pwd(current->fs, &nd->path);
+			get_fs_pwd(sysiso_current->fs, &nd->path);
 			nd->inode = nd->path.dentry->d_inode;
 		}
 	} else {
diff --git a/fs/namespace.c b/fs/namespace.c
index 659a8f39c..74665b47e 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -696,7 +696,7 @@ static inline bool mnt_is_cursor(struct mount *mnt)
  */
 bool __is_local_mountpoint(struct dentry *dentry)
 {
-	struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+	struct mnt_namespace *ns = sysiso_current->nsproxy->mnt_ns;
 	struct mount *mnt;
 	bool is_covered = false;
 
@@ -805,7 +805,7 @@ static void put_mountpoint(struct mountpoint *mp)
 
 static inline int check_mnt(struct mount *mnt)
 {
-	return mnt->mnt_ns == current->nsproxy->mnt_ns;
+	return mnt->mnt_ns == sysiso_current->nsproxy->mnt_ns;
 }
 
 /*
@@ -1592,7 +1592,7 @@ static int do_umount(struct mount *mnt, int flags)
 	 *  (2) the usage count == 1 [parent vfsmount] + 1 [sys_umount]
 	 */
 	if (flags & MNT_EXPIRE) {
-		if (&mnt->mnt == current->fs->root.mnt ||
+		if (&mnt->mnt == sysiso_current->fs->root.mnt ||
 		    flags & (MNT_FORCE | MNT_DETACH))
 			return -EINVAL;
 
@@ -1634,7 +1634,7 @@ static int do_umount(struct mount *mnt, int flags)
 	 * /reboot - static binary that would close all descriptors and
 	 * call reboot(9). Then init(8) could umount root and exec /reboot.
 	 */
-	if (&mnt->mnt == current->fs->root.mnt && !(flags & MNT_DETACH)) {
+	if (&mnt->mnt == sysiso_current->fs->root.mnt && !(flags & MNT_DETACH)) {
 		/*
 		 * Special case for "unmounting" root ...
 		 * we just try to remount it readonly.
@@ -1708,12 +1708,13 @@ void __detach_mounts(struct dentry *dentry)
 	namespace_unlock();
 }
 
-/*
+/*g
  * Is the caller allowed to modify his namespace?
  */
 static inline bool may_mount(void)
 {
-	return ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);
+	return ns_capable(sysiso_current->nsproxy->mnt_ns->user_ns,
+			  CAP_SYS_ADMIN);
 }
 
 static void warn_mandlock(void)
@@ -1820,7 +1821,7 @@ static bool mnt_ns_loop(struct dentry *dentry)
 		return false;
 
 	mnt_ns = to_mnt_ns(get_proc_ns(dentry->d_inode));
-	return current->nsproxy->mnt_ns->seq >= mnt_ns->seq;
+	return sysiso_current->nsproxy->mnt_ns->seq >= mnt_ns->seq;
 }
 
 struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,
@@ -2150,7 +2151,7 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct mountpoint *dest_mp,
 			bool moving)
 {
-	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
+	struct user_namespace *user_ns = sysiso_current->nsproxy->mnt_ns->user_ns;
 	HLIST_HEAD(tree_list);
 	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mountpoint *smp;
@@ -2414,7 +2415,7 @@ static int do_loopback(struct path *path, const char *old_name,
 
 static struct file *open_detached_copy(struct path *path, bool recursive)
 {
-	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
+	struct user_namespace *user_ns = sysiso_current->nsproxy->mnt_ns->user_ns;
 	struct mnt_namespace *ns = alloc_mnt_ns(user_ns, true);
 	struct mount *mnt, *p;
 	struct file *file;
@@ -3664,7 +3665,7 @@ SYSCALL_DEFINE3(fsmount, int, fs_fd, unsigned int, flags,
 	 */
 	vfs_clean_context(fc);
 
-	ns = alloc_mnt_ns(current->nsproxy->mnt_ns->user_ns, true);
+	ns = alloc_mnt_ns(sysiso_current->nsproxy->mnt_ns->user_ns, true);
 	if (IS_ERR(ns)) {
 		ret = PTR_ERR(ns);
 		goto err_path;
@@ -3838,7 +3839,7 @@ SYSCALL_DEFINE2(pivot_root, const char __user *, new_root,
 	if (error)
 		goto out2;
 
-	get_fs_root(current->fs, &root);
+	get_fs_root(sysiso_current->fs, &root);
 	old_mp = lock_mount(&old);
 	error = PTR_ERR(old_mp);
 	if (IS_ERR(old_mp))
@@ -4298,8 +4299,8 @@ static void __init init_mount_tree(void)
 	root.dentry = mnt->mnt_root;
 	mnt->mnt_flags |= MNT_LOCKED;
 
-	set_fs_pwd(current->fs, &root);
-	set_fs_root(current->fs, &root);
+	set_fs_pwd(sysiso_current->fs, &root);
+	set_fs_root(sysiso_current->fs, &root);
 }
 
 void __init mnt_init(void)
@@ -4397,13 +4398,13 @@ bool current_chrooted(void)
 	bool chrooted;
 
 	/* Find the namespace root */
-	ns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;
+	ns_root.mnt = &sysiso_current->nsproxy->mnt_ns->root->mnt;
 	ns_root.dentry = ns_root.mnt->mnt_root;
 	path_get(&ns_root);
 	while (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))
 		;
 
-	get_fs_root(current->fs, &fs_root);
+	get_fs_root(sysiso_current->fs, &fs_root);
 
 	chrooted = !path_equal(&fs_root, &ns_root);
 
@@ -4485,7 +4486,7 @@ static bool mnt_already_visible(struct mnt_namespace *ns,
 static bool mount_too_revealing(const struct super_block *sb, int *new_mnt_flags)
 {
 	const unsigned long required_iflags = SB_I_NOEXEC | SB_I_NODEV;
-	struct mnt_namespace *ns = current->nsproxy->mnt_ns;
+	struct mnt_namespace *ns = sysiso_current->nsproxy->mnt_ns;
 	unsigned long s_iflags;
 
 	if (ns->user_ns == &init_user_ns)
diff --git a/fs/netfs/internal.h b/fs/netfs/internal.h
index b7f2c4459..e6e66b090 100644
--- a/fs/netfs/internal.h
+++ b/fs/netfs/internal.h
@@ -60,7 +60,7 @@ static inline void netfs_stat_d(atomic_t *stat)
  * debug tracing
  */
 #define dbgprintk(FMT, ...) \
-	printk("[%-6.6s] "FMT"\n", current->comm, ##__VA_ARGS__)
+	printk("[%-6.6s] "FMT"\n", sysiso_current->comm, ##__VA_ARGS__)
 
 #define kenter(FMT, ...) dbgprintk("==> %s("FMT")", __func__, ##__VA_ARGS__)
 #define kleave(FMT, ...) dbgprintk("<== %s()"FMT"", __func__, ##__VA_ARGS__)
diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c
index 86d856de1..6ccee5b2e 100644
--- a/fs/nfs/callback.c
+++ b/fs/nfs/callback.c
@@ -82,7 +82,7 @@ nfs4_callback_svc(void *vrqstp)
 
 	while (!kthread_freezable_should_stop(NULL)) {
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			flush_signals(current);
 		/*
 		 * Listen for a request on the socket
@@ -114,7 +114,7 @@ nfs41_callback_svc(void *vrqstp)
 
 	while (!kthread_freezable_should_stop(NULL)) {
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			flush_signals(current);
 
 		prepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_INTERRUPTIBLE);
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index 853213b3a..4e1e504ee 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -75,7 +75,7 @@ nfs_fattr_to_ino_t(struct nfs_fattr *fattr)
 static int nfs_wait_killable(int mode)
 {
 	freezable_schedule_unsafe();
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -ERESTARTSYS;
 	return 0;
 }
@@ -910,7 +910,7 @@ EXPORT_SYMBOL_GPL(nfs_getattr);
 static void nfs_init_lock_context(struct nfs_lock_context *l_ctx)
 {
 	refcount_set(&l_ctx->count, 1);
-	l_ctx->lockowner = current->files;
+	l_ctx->lockowner = sysiso_current->files;
 	INIT_LIST_HEAD(&l_ctx->list);
 	atomic_set(&l_ctx->io_count, 0);
 }
@@ -920,7 +920,7 @@ static struct nfs_lock_context *__nfs_find_lock_context(struct nfs_open_context
 	struct nfs_lock_context *pos;
 
 	list_for_each_entry_rcu(pos, &ctx->lock_context.list, list) {
-		if (pos->lockowner != current->files)
+		if (pos->lockowner != sysiso_current->files)
 			continue;
 		if (refcount_inc_not_zero(&pos->count))
 			return pos;
diff --git a/fs/nfs/nfs3proc.c b/fs/nfs/nfs3proc.c
index f7524310d..f750eb41b 100644
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@ -38,7 +38,7 @@ nfs3_rpc_wrapper(struct rpc_clnt *clnt, struct rpc_message *msg, int flags)
 			break;
 		freezable_schedule_timeout_killable_unsafe(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
-	} while (!fatal_signal_pending(current));
+	} while (!fatal_signal_pending(sysiso_current));
 	return res;
 }
 
@@ -359,7 +359,7 @@ nfs3_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,
 	if (flags & O_EXCL) {
 		data->arg.create.createmode  = NFS3_CREATE_EXCLUSIVE;
 		data->arg.create.verifier[0] = cpu_to_be32(jiffies);
-		data->arg.create.verifier[1] = cpu_to_be32(current->pid);
+		data->arg.create.verifier[1] = cpu_to_be32(sysiso_current->pid);
 	}
 
 	status = posix_acl_create(dir, &sattr->ia_mode, &default_acl, &acl);
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index e1214bb6b..def711680 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -413,7 +413,7 @@ static int nfs4_delay_killable(long *timeout)
 
 	freezable_schedule_timeout_killable_unsafe(
 		nfs4_update_delay(timeout));
-	if (!__fatal_signal_pending(current))
+	if (!__fatal_signal_pending(sysiso_current))
 		return 0;
 	return -EINTR;
 }
@@ -423,9 +423,9 @@ static int nfs4_delay_interruptible(long *timeout)
 	might_sleep();
 
 	freezable_schedule_timeout_interruptible_unsafe(nfs4_update_delay(timeout));
-	if (!signal_pending(current))
+	if (!signal_pending(sysiso_current))
 		return 0;
-	return __fatal_signal_pending(current) ? -EINTR :-ERESTARTSYS;
+	return __fatal_signal_pending(sysiso_current) ? -EINTR :-ERESTARTSYS;
 }
 
 static int nfs4_delay(long *timeout, bool interruptible)
@@ -1711,7 +1711,7 @@ static void nfs_set_open_stateid_locked(struct nfs4_state *state,
 		rcu_read_unlock();
 		trace_nfs4_open_stateid_update_wait(state->inode, stateid, 0);
 
-		if (!fatal_signal_pending(current)) {
+		if (!fatal_signal_pending(sysiso_current)) {
 			if (schedule_timeout(5*HZ) == 0)
 				status = -EAGAIN;
 			else
@@ -3236,7 +3236,7 @@ static struct nfs4_state *nfs4_do_open(struct inode *dir,
 		.sattr = sattr,
 		.verf = {
 			[0] = (__u32)jiffies,
-			[1] = (__u32)current->pid,
+			[1] = (__u32) sysiso_current->pid,
 		},
 	};
 	int status;
@@ -3495,7 +3495,7 @@ static bool nfs4_refresh_open_old_stateid(nfs4_stateid *dst,
 		write_sequnlock(&state->seqlock);
 		trace_nfs4_close_stateid_update_wait(state->inode, dst, 0);
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			status = -EINTR;
 		else
 			if (schedule_timeout(5*HZ) != 0)
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index eae9bf114..28fbdcab5 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -1220,7 +1220,7 @@ int nfs_flush_incompatible(struct file *file, struct page *page)
 		if (l_ctx && flctx &&
 		    !(list_empty_careful(&flctx->flc_posix) &&
 		      list_empty_careful(&flctx->flc_flock))) {
-			do_flush |= l_ctx->lockowner != current->files;
+			do_flush |= l_ctx->lockowner != sysiso_current->files;
 		}
 		nfs_release_request(req);
 		if (!do_flush)
diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index 9421dae22..9e86b5f31 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -250,7 +250,7 @@ static void expkey_flush(void)
 	 * destroyed while we're in the middle of flushing.
 	 */
 	mutex_lock(&nfsd_mutex);
-	nfsd_file_cache_purge(current->nsproxy->net_ns);
+	nfsd_file_cache_purge(sysiso_current->nsproxy->net_ns);
 	mutex_unlock(&nfsd_mutex);
 }
 
diff --git a/fs/nfsd/fault_inject.c b/fs/nfsd/fault_inject.c
index 76bee0a0d..fe5aaa6d3 100644
--- a/fs/nfsd/fault_inject.c
+++ b/fs/nfsd/fault_inject.c
@@ -47,7 +47,7 @@ static ssize_t fault_inject_write(struct file *file, const char __user *buf,
 {
 	char write_buf[INET6_ADDRSTRLEN];
 	size_t size = min(sizeof(write_buf) - 1, len);
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct sockaddr_storage sa;
 	struct nfsd_fault_inject_op *op = file_inode(file)->i_private;
 	u64 val;
diff --git a/fs/nfsd/nfs4layouts.c b/fs/nfsd/nfs4layouts.c
index a97873f2d..2ca4d1cf8 100644
--- a/fs/nfsd/nfs4layouts.c
+++ b/fs/nfsd/nfs4layouts.c
@@ -196,7 +196,7 @@ nfsd4_layout_setlease(struct nfs4_layout_stateid *ls)
 	fl->fl_type = F_RDLCK;
 	fl->fl_end = OFFSET_MAX;
 	fl->fl_owner = ls;
-	fl->fl_pid = current->tgid;
+	fl->fl_pid = sysiso_current->tgid;
 	fl->fl_file = ls->ls_file->nf_file;
 
 	status = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 486c5dba4..5de8238b6 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -268,13 +268,13 @@ do_open_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, stru
 		 * Note: create modes (UNCHECKED,GUARDED...) are the same
 		 * in NFSv4 as in v3 except EXCLUSIVE4_1.
 		 */
-		current->fs->umask = open->op_umask;
+		sysiso_current->fs->umask = open->op_umask;
 		status = do_nfsd_create(rqstp, current_fh, open->op_fname,
 					open->op_fnamelen, &open->op_iattr,
 					*resfh, open->op_createmode,
 					(u32 *)open->op_verf.data,
 					&open->op_truncate, &open->op_created);
-		current->fs->umask = 0;
+		sysiso_current->fs->umask = 0;
 
 		if (!status && open->op_label.len)
 			nfsd4_security_inode_setsecctx(*resfh, &open->op_label, open->op_bmval);
@@ -632,7 +632,7 @@ nfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	if (status)
 		return status;
 
-	current->fs->umask = create->cr_umask;
+	sysiso_current->fs->umask = create->cr_umask;
 	switch (create->cr_type) {
 	case NF4LNK:
 		status = nfsd_symlink(rqstp, &cstate->current_fh,
@@ -701,7 +701,7 @@ nfsd4_create(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 out:
 	fh_put(&resfh);
 out_umask:
-	current->fs->umask = 0;
+	sysiso_current->fs->umask = 0;
 	return status;
 }
 
@@ -1199,7 +1199,7 @@ static __be32 nfsd4_ssc_setup_dul(struct nfsd_net *nn, char *ipaddr,
 			spin_unlock(&nn->nfsd_ssc_lock);
 
 			/* allow 20secs for mount/unmount for now - revisit */
-			if (signal_pending(current) ||
+			if (signal_pending(sysiso_current) ||
 					(schedule_timeout(20*HZ) == 0)) {
 				kfree(work);
 				return nfserr_eagain;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 3f4027a5d..501dccf9c 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -5036,7 +5036,7 @@ static struct file_lock *nfs4_alloc_init_lease(struct nfs4_delegation *dp,
 	fl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;
 	fl->fl_end = OFFSET_MAX;
 	fl->fl_owner = (fl_owner_t)dp;
-	fl->fl_pid = current->tgid;
+	fl->fl_pid = sysiso_current->tgid;
 	fl->fl_file = dp->dl_stid.sc_file->fi_deleg_file->nf_file;
 	return fl;
 }
@@ -6950,7 +6950,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	file_lock = &nbl->nbl_lock;
 	file_lock->fl_type = fl_type;
 	file_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));
-	file_lock->fl_pid = current->tgid;
+	file_lock->fl_pid = sysiso_current->tgid;
 	file_lock->fl_file = nf->nf_file;
 	file_lock->fl_flags = fl_flags;
 	file_lock->fl_lmops = &nfsd_posix_mng_ops;
@@ -7116,7 +7116,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	lo = find_lockowner_str(cstate->clp, &lockt->lt_owner);
 	if (lo)
 		file_lock->fl_owner = (fl_owner_t)lo;
-	file_lock->fl_pid = current->tgid;
+	file_lock->fl_pid = sysiso_current->tgid;
 	file_lock->fl_flags = FL_POSIX;
 
 	file_lock->fl_start = lockt->lt_offset;
@@ -7178,7 +7178,7 @@ nfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 
 	file_lock->fl_type = F_UNLCK;
 	file_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));
-	file_lock->fl_pid = current->tgid;
+	file_lock->fl_pid = sysiso_current->tgid;
 	file_lock->fl_file = nf->nf_file;
 	file_lock->fl_flags = FL_POSIX;
 	file_lock->fl_lmops = &nfsd_posix_mng_ops;
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 070e5dd03..82dd93b14 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -155,7 +155,7 @@ static int exports_net_open(struct net *net, struct file *file)
 
 static int exports_proc_open(struct inode *inode, struct file *file)
 {
-	return exports_net_open(current->nsproxy->net_ns, file);
+	return exports_net_open(sysiso_current->nsproxy->net_ns, file);
 }
 
 static const struct proc_ops exports_proc_ops = {
@@ -1348,7 +1348,7 @@ void nfsd_client_rmdir(struct dentry *dentry)
 
 static int nfsd_fill_super(struct super_block *sb, struct fs_context *fc)
 {
-	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
+	struct nfsd_net *nn = net_generic(sysiso_current->nsproxy->net_ns,
 							nfsd_net_id);
 	struct dentry *dentry;
 	int ret;
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index ccb59e910..5b2ac6dff 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -926,7 +926,7 @@ nfsd(void *vrqstp)
 	/* Lock module and set up kernel thread */
 	mutex_lock(&nfsd_mutex);
 
-	/* At this point, the thread shares current->fs
+	/* At this point, the thread shares sysiso_current->fs
 	 * with the init process. We need to create files with the
 	 * umask as defined by the client instead of init's umask. */
 	if (unshare_fs_struct() < 0) {
@@ -934,7 +934,7 @@ nfsd(void *vrqstp)
 		goto out;
 	}
 
-	current->fs->umask = 0;
+	sysiso_current->fs->umask = 0;
 
 	/*
 	 * thread is spawned with all signals set to SIG_IGN, re-enable
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 738d564ca..ef5c2bcb4 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -926,13 +926,14 @@ static int wait_for_concurrent_writes(struct file *file)
 
 	if (atomic_read(&inode->i_writecount) > 1
 	    || (last_ino == inode->i_ino && last_dev == inode->i_sb->s_dev)) {
-		dprintk("nfsd: write defer %d\n", task_pid_nr(current));
+		dprintk("nfsd: write defer %d\n", task_pid_nr(sysiso_current));
 		msleep(10);
-		dprintk("nfsd: write resume %d\n", task_pid_nr(current));
+		dprintk("nfsd: write resume %d\n",
+			task_pid_nr(sysiso_current));
 	}
 
 	if (inode->i_state & I_DIRTY) {
-		dprintk("nfsd: write sync %d\n", task_pid_nr(current));
+		dprintk("nfsd: write sync %d\n", task_pid_nr(sysiso_current));
 		err = vfs_fsync(file, 0);
 	}
 	last_ino = inode->i_ino;
@@ -955,7 +956,7 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfsd_file *nf,
 	int			use_wgather;
 	loff_t			pos = offset;
 	unsigned long		exp_op_flags = 0;
-	unsigned int		pflags = current->flags;
+	unsigned int		pflags = sysiso_current->flags;
 	rwf_t			flags = 0;
 	bool			restore_flags = false;
 
@@ -973,7 +974,7 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfsd_file *nf,
 		 * localhost doesn't cause nfsd to lock up due to all
 		 * the client's dirty pages or its congested queue.
 		 */
-		current->flags |= PF_LOCAL_THROTTLE;
+		sysiso_current->flags |= PF_LOCAL_THROTTLE;
 		restore_flags = true;
 	}
 
diff --git a/fs/nilfs2/segment.c b/fs/nilfs2/segment.c
index 686c8ee7b..845394a1e 100644
--- a/fs/nilfs2/segment.c
+++ b/fs/nilfs2/segment.c
@@ -2178,7 +2178,7 @@ static int nilfs_segctor_sync(struct nilfs_sc_info *sci)
 			err = wait_req.err;
 			break;
 		}
-		if (!signal_pending(current)) {
+		if (!signal_pending(sysiso_current)) {
 			schedule();
 			continue;
 		}
@@ -2566,7 +2566,7 @@ static int nilfs_segctor_thread(void *arg)
 	}
 
 
-	if (freezing(current)) {
+	if (freezing(sysiso_current)) {
 		spin_unlock(&sci->sc_state_lock);
 		try_to_freeze();
 		spin_lock(&sci->sc_state_lock);
diff --git a/fs/notify/dnotify/dnotify.c b/fs/notify/dnotify/dnotify.c
index e85e13c50..416881a58 100644
--- a/fs/notify/dnotify/dnotify.c
+++ b/fs/notify/dnotify/dnotify.c
@@ -246,7 +246,7 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
 	struct fsnotify_mark *new_fsn_mark, *fsn_mark;
 	struct dnotify_struct *dn;
 	struct inode *inode;
-	fl_owner_t id = current->files;
+	fl_owner_t id = sysiso_current->files;
 	struct file *f;
 	int destroy = 0, error = 0;
 	__u32 mask;
@@ -348,7 +348,7 @@ int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)
 		goto out;
 	}
 
-	__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);
+	__f_setown(filp, task_pid(sysiso_current), PIDTYPE_TGID, 0);
 
 	error = attach_dn(dn, dn_mark, id, fd, filp, mask);
 	/* !error means that we attached the dn to the dn_mark, so don't free it */
diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c
index 057abd2cf..64607598e 100644
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -643,7 +643,7 @@ static struct fanotify_event *fanotify_alloc_event(struct fsnotify_group *group,
 		goto out;
 
 	if (FAN_GROUP_FLAG(group, FAN_REPORT_TID))
-		pid = get_pid(task_pid(current));
+		pid = get_pid(task_pid(sysiso_current));
 	else
 		pid = get_pid(task_tgid(current));
 
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 6facdf476..59613005f 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -683,7 +683,7 @@ static ssize_t fanotify_read(struct file *file, char __user *buf,
 				break;
 
 			ret = -ERESTARTSYS;
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				break;
 
 			if (start != buf)
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 62051247f..d55b06d6d 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -261,7 +261,7 @@ static ssize_t inotify_read(struct file *file, char __user *buf,
 		if (file->f_flags & O_NONBLOCK)
 			break;
 		ret = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		if (start != buf)
diff --git a/fs/ntfs/file.c b/fs/ntfs/file.c
index ab4f33624..a45d05eca 100644
--- a/fs/ntfs/file.c
+++ b/fs/ntfs/file.c
@@ -1884,7 +1884,7 @@ static ssize_t ntfs_perform_write(struct file *file, struct iov_iter *i,
 		pos += copied;
 		written += copied;
 		balance_dirty_pages_ratelimited(mapping);
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			status = -EINTR;
 			break;
 		}
diff --git a/fs/ntfs3/fsntfs.c b/fs/ntfs3/fsntfs.c
index 4de9acb16..40396ef21 100644
--- a/fs/ntfs3/fsntfs.c
+++ b/fs/ntfs3/fsntfs.c
@@ -1447,7 +1447,7 @@ static inline struct bio *ntfs_alloc_bio(u32 nr_vecs)
 {
 	struct bio *bio = bio_alloc(GFP_NOFS | __GFP_HIGH, nr_vecs);
 
-	if (!bio && (current->flags & PF_MEMALLOC)) {
+	if (!bio && (sysiso_current->flags & PF_MEMALLOC)) {
 		while (!bio && (nr_vecs /= 2))
 			bio = bio_alloc(GFP_NOFS | __GFP_HIGH, nr_vecs);
 	}
diff --git a/fs/ocfs2/alloc.c b/fs/ocfs2/alloc.c
index 5d9ae17bd..f98eb5e06 100644
--- a/fs/ocfs2/alloc.c
+++ b/fs/ocfs2/alloc.c
@@ -7500,7 +7500,7 @@ static int ocfs2_trim_group(struct super_block *sb,
 		}
 		start = next + 1;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			count = -ERESTARTSYS;
 			break;
 		}
diff --git a/fs/ocfs2/aops.c b/fs/ocfs2/aops.c
index 68d11c295..39b6aef7e 100644
--- a/fs/ocfs2/aops.c
+++ b/fs/ocfs2/aops.c
@@ -2098,7 +2098,7 @@ ocfs2_dio_alloc_write_ctx(struct buffer_head *bh, int *alloc)
 	INIT_LIST_HEAD(&dwc->dw_zero_list);
 	dwc->dw_zero_count = 0;
 	dwc->dw_orphaned = 0;
-	dwc->dw_writer_pid = task_pid_nr(current);
+	dwc->dw_writer_pid = task_pid_nr(sysiso_current);
 	bh->b_private = dwc;
 	*alloc = 1;
 
@@ -2313,7 +2313,7 @@ static int ocfs2_dio_end_io_write(struct inode *inode,
 
 	/* Delete orphan before acquire i_mutex. */
 	if (dwc->dw_orphaned) {
-		BUG_ON(dwc->dw_writer_pid != task_pid_nr(current));
+		BUG_ON(dwc->dw_writer_pid != task_pid_nr(sysiso_current));
 
 		end = end > i_size_read(inode) ? end : 0;
 
diff --git a/fs/ocfs2/cluster/masklog.c b/fs/ocfs2/cluster/masklog.c
index 810d32815..9c8487f79 100644
--- a/fs/ocfs2/cluster/masklog.c
+++ b/fs/ocfs2/cluster/masklog.c
@@ -75,7 +75,7 @@ void __mlog_printk(const u64 *mask, const char *func, int line,
 	vaf.va = &args;
 
 	printk("%s(%s,%u,%u):%s:%d %s%pV",
-	       level, current->comm, task_pid_nr(current),
+	       level, sysiso_current->comm, task_pid_nr(sysiso_current),
 	       raw_smp_processor_id(), func, line, prefix, &vaf);
 
 	va_end(args);
diff --git a/fs/ocfs2/dlm/dlmdomain.c b/fs/ocfs2/dlm/dlmdomain.c
index 9f90fc955..e70be8c3a 100644
--- a/fs/ocfs2/dlm/dlmdomain.c
+++ b/fs/ocfs2/dlm/dlmdomain.c
@@ -1896,7 +1896,7 @@ static int dlm_join_domain(struct dlm_ctxt *dlm)
 		 * complete. */
 #define	DLM_JOIN_TIMEOUT_MSECS	90000
 		if (status == -EAGAIN) {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				status = -ERESTARTSYS;
 				goto bail;
 			}
@@ -2116,7 +2116,7 @@ struct dlm_ctxt * dlm_register_domain(const char *domain,
 
 retry:
 	dlm = NULL;
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		ret = -ERESTARTSYS;
 		mlog_errno(ret);
 		goto leave;
diff --git a/fs/ocfs2/dlmfs/userdlm.c b/fs/ocfs2/dlmfs/userdlm.c
index 29f183a15..72aaec1dc 100644
--- a/fs/ocfs2/dlmfs/userdlm.c
+++ b/fs/ocfs2/dlmfs/userdlm.c
@@ -427,7 +427,7 @@ int user_dlm_cluster_lock(struct user_lock_res *lockres,
 	     lockres->l_namelen, lockres->l_name, level, lkm_flags);
 
 again:
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		status = -ERESTARTSYS;
 		goto bail;
 	}
diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c
index 801e60bab..bd7190e45 100644
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -800,7 +800,7 @@ static inline void ocfs2_add_holder(struct ocfs2_lock_res *lockres,
 				   struct ocfs2_lock_holder *oh)
 {
 	INIT_LIST_HEAD(&oh->oh_list);
-	oh->oh_owner_pid = get_pid(task_pid(current));
+	oh->oh_owner_pid = get_pid(task_pid(sysiso_current));
 
 	spin_lock(&lockres->l_lock);
 	list_add_tail(&oh->oh_list, &lockres->l_holders);
@@ -1497,7 +1497,7 @@ static int __ocfs2_cluster_lock(struct ocfs2_super *osb,
 
 	spin_lock_irqsave(&lockres->l_lock, flags);
 
-	if (catch_signals && signal_pending(current)) {
+	if (catch_signals && signal_pending(sysiso_current)) {
 		ret = -ERESTARTSYS;
 		goto unlock;
 	}
@@ -2676,7 +2676,7 @@ int ocfs2_inode_lock_tracker(struct inode *inode,
 	int status = 0;
 	struct ocfs2_lock_res *lockres;
 	struct ocfs2_lock_holder *tmp_oh;
-	struct pid *pid = task_pid(current);
+	struct pid *pid = task_pid(sysiso_current);
 
 
 	lockres = &OCFS2_I(inode)->ip_inode_lockres;
diff --git a/fs/ocfs2/refcounttree.c b/fs/ocfs2/refcounttree.c
index 7f6355cbb..9ee40fe38 100644
--- a/fs/ocfs2/refcounttree.c
+++ b/fs/ocfs2/refcounttree.c
@@ -4528,7 +4528,7 @@ static loff_t ocfs2_reflink_remap_extent(struct inode *s_inode,
 	slast = ocfs2_clusters_for_bytes(s_inode->i_sb, pos_in + len);
 
 	while (spos < slast) {
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			goto out;
 		}
diff --git a/fs/open.c b/fs/open.c
index daa324606..dcae32063 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -494,7 +494,7 @@ SYSCALL_DEFINE1(chdir, const char __user *, filename)
 	if (error)
 		goto dput_and_out;
 
-	set_fs_pwd(current->fs, &path);
+	set_fs_pwd(sysiso_current->fs, &path);
 
 dput_and_out:
 	path_put(&path);
@@ -521,7 +521,7 @@ SYSCALL_DEFINE1(fchdir, unsigned int, fd)
 
 	error = file_permission(f.file, MAY_EXEC | MAY_CHDIR);
 	if (!error)
-		set_fs_pwd(current->fs, &f.file->f_path);
+		set_fs_pwd(sysiso_current->fs, &f.file->f_path);
 out_putf:
 	fdput(f);
 out:
@@ -549,7 +549,7 @@ SYSCALL_DEFINE1(chroot, const char __user *, filename)
 	if (error)
 		goto dput_and_out;
 
-	set_fs_root(current->fs, &path);
+	set_fs_root(sysiso_current->fs, &path);
 	error = 0;
 dput_and_out:
 	path_put(&path);
@@ -1192,6 +1192,10 @@ static long do_sys_openat2(int dfd, const char __user *filename,
 		return fd;
 
 	tmp = getname(filename);
+
+	if (!tmp)
+		BUG();
+
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
 
diff --git a/fs/orangefs/devorangefs-req.c b/fs/orangefs/devorangefs-req.c
index 33ee8cb32..f4456f8b7 100644
--- a/fs/orangefs/devorangefs-req.c
+++ b/fs/orangefs/devorangefs-req.c
@@ -314,7 +314,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 		     __func__,
 		     get_opname_string(cur_op),
 		     cur_op->op_state,
-		     current->comm);
+		     sysiso_current->comm);
 	orangefs_devreq_add_op(cur_op);
 	spin_unlock(&cur_op->lock);
 	spin_unlock(&orangefs_htable_ops_in_progress_lock);
@@ -337,7 +337,7 @@ static ssize_t orangefs_devreq_read(struct file *file,
 			     __func__,
 			     get_opname_string(cur_op),
 			     cur_op->op_state,
-			     current->comm);
+			     sysiso_current->comm);
 		list_add(&cur_op->list, &orangefs_request_list);
 		spin_unlock(&cur_op->lock);
 	} else {
@@ -496,7 +496,7 @@ static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 			     __func__,
 			     get_opname_string(op),
 			     op->op_state,
-			     current->comm);
+			     sysiso_current->comm);
 		spin_unlock(&op->lock);
 	}
 	return ret;
diff --git a/fs/orangefs/orangefs-bufmap.c b/fs/orangefs/orangefs-bufmap.c
index 538e83959..ced82671e 100644
--- a/fs/orangefs/orangefs-bufmap.c
+++ b/fs/orangefs/orangefs-bufmap.c
@@ -105,7 +105,7 @@ static int wait_for_free(struct slot_map *m)
 			left = t;
 		else
 			left = t + (left - n);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			left = -EINTR;
 	} while (left > 0);
 
diff --git a/fs/orangefs/orangefs-mod.c b/fs/orangefs/orangefs-mod.c
index cd7297815..d4d6ef5ee 100644
--- a/fs/orangefs/orangefs-mod.c
+++ b/fs/orangefs/orangefs-mod.c
@@ -221,7 +221,7 @@ void purge_inprogress_ops(void)
 				     __func__,
 				     get_opname_string(op),
 				     op->op_state,
-				     current->comm);
+				     sysiso_current->comm);
 		}
 		spin_unlock(&orangefs_htable_ops_in_progress_lock);
 	}
diff --git a/fs/orangefs/waitqueue.c b/fs/orangefs/waitqueue.c
index beafc33d5..36fd92081 100644
--- a/fs/orangefs/waitqueue.c
+++ b/fs/orangefs/waitqueue.c
@@ -47,7 +47,7 @@ void purge_waiting_ops(void)
 			     __func__,
 			     get_opname_string(op),
 			     op->op_state,
-			     current->comm);
+			     sysiso_current->comm);
 	}
 	spin_unlock(&orangefs_request_list_lock);
 }
@@ -71,8 +71,8 @@ int service_operation(struct orangefs_kernel_op_s *op,
 
 	DEFINE_WAIT(wait_entry);
 
-	op->upcall.tgid = current->tgid;
-	op->upcall.pid = current->pid;
+	op->upcall.tgid = sysiso_current->tgid;
+	op->upcall.pid = sysiso_current->pid;
 
 retry_servicing:
 	op->downcall.status = 0;
@@ -81,8 +81,8 @@ int service_operation(struct orangefs_kernel_op_s *op,
 		     __func__,
 		     op_name,
 		     op,
-		     current->comm,
-		     current->pid);
+		     sysiso_current->comm,
+		     sysiso_current->pid);
 
 	/*
 	 * If ORANGEFS_OP_NO_MUTEX was set in flags, we need to avoid
@@ -117,7 +117,7 @@ int service_operation(struct orangefs_kernel_op_s *op,
 		     __func__,
 		     get_opname_string(op),
 		     op->op_state,
-		     current->comm);
+		     sysiso_current->comm);
 	/* add high priority remount op to the front of the line. */
 	if (flags & ORANGEFS_OP_PRIORITY)
 		list_add(&op->list, &orangefs_request_list);
@@ -232,7 +232,7 @@ bool orangefs_cancel_op_in_progress(struct orangefs_kernel_op_s *op)
 		     __func__,
 		     get_opname_string(op),
 		     op->op_state,
-		     current->comm);
+		     sysiso_current->comm);
 	list_add(&op->list, &orangefs_request_list);
 	spin_unlock(&op->lock);
 	spin_unlock(&orangefs_request_list_lock);
diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c
index 4e7d5bfa2..9a1d66952 100644
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@ -214,7 +214,7 @@ static int ovl_copy_up_data(struct ovl_fs *ofs, struct path *old,
 		if (len < this_len)
 			this_len = len;
 
-		if (signal_pending_state(TASK_KILLABLE, current)) {
+		if (signal_pending_state(TASK_KILLABLE, sysiso_current)) {
 			error = -EINTR;
 			break;
 		}
diff --git a/fs/pipe.c b/fs/pipe.c
index 6d4342bad..1e7bbab01 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -550,7 +550,7 @@ pipe_write(struct kiocb *iocb, struct iov_iter *from)
 				ret = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			if (!ret)
 				ret = -ERESTARTSYS;
 			break;
@@ -1075,7 +1075,7 @@ static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)
 		schedule();
 		finish_wait(&pipe->rd_wait, &rdwait);
 		pipe_lock(pipe);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 	return cur == *cnt ? -ERESTARTSYS : 0;
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 533d5836e..0c9627f3f 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1077,7 +1077,8 @@ static int __set_oom_adj(struct file *file, int oom_adj, bool legacy)
 		 * /proc/pid/oom_score_adj instead.
 		 */
 		pr_warn_once("%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\n",
-			  current->comm, task_pid_nr(current), task_pid_nr(task),
+			  sysiso_current->comm, task_pid_nr(sysiso_current),
+			  task_pid_nr(task),
 			  task_pid_nr(task));
 	} else {
 		if ((short)oom_adj < task->signal->oom_score_adj_min &&
@@ -1271,7 +1272,7 @@ static ssize_t proc_loginuid_write(struct file * file, const char __user * buf,
 	int rv;
 
 	/* Don't let kthreads write their own loginuid */
-	if (current->flags & PF_KTHREAD)
+	if (sysiso_current->flags & PF_KTHREAD)
 		return -EPERM;
 
 	rcu_read_lock();
@@ -1675,7 +1676,7 @@ static ssize_t comm_write(struct file *file, const char __user *buf,
 	if (!p)
 		return -ESRCH;
 
-	if (same_thread_group(current, p)) {
+	if (same_thread_group(sysiso_current, p)) {
 		set_task_comm(p, buffer);
 		proc_comm_connector(p);
 	}
@@ -2749,14 +2750,14 @@ static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,
 	}
 
 	/* Guard against adverse ptrace interaction */
-	rv = mutex_lock_interruptible(&current->signal->cred_guard_mutex);
+	rv = mutex_lock_interruptible(&sysiso_current->signal->cred_guard_mutex);
 	if (rv < 0)
 		goto out_free;
 
 	rv = security_setprocattr(PROC_I(inode)->op.lsm,
 				  file->f_path.dentry->d_name.name, page,
 				  count);
-	mutex_unlock(&current->signal->cred_guard_mutex);
+	mutex_unlock(&sysiso_current->signal->cred_guard_mutex);
 out_free:
 	kfree(page);
 out:
@@ -3497,7 +3498,7 @@ static int proc_tid_comm_permission(struct user_namespace *mnt_userns,
 	task = get_proc_task(inode);
 	if (!task)
 		return -ESRCH;
-	is_same_tgroup = same_thread_group(current, task);
+	is_same_tgroup = same_thread_group(sysiso_current, task);
 	put_task_struct(task);
 
 	if (likely(is_same_tgroup && !(mask & MAY_EXEC))) {
diff --git a/fs/proc/fd.c b/fs/proc/fd.c
index 172c86270..5084c5c40 100644
--- a/fs/proc/fd.c
+++ b/fs/proc/fd.c
@@ -302,7 +302,7 @@ int proc_fd_permission(struct user_namespace *mnt_userns,
 
 	rcu_read_lock();
 	p = pid_task(proc_pid(inode), PIDTYPE_PID);
-	if (p && same_thread_group(p, current))
+	if (p && same_thread_group(p, sysiso_current))
 		rv = 0;
 	rcu_read_unlock();
 
diff --git a/fs/proc/loadavg.c b/fs/proc/loadavg.c
index f32878d9a..d382391f5 100644
--- a/fs/proc/loadavg.c
+++ b/fs/proc/loadavg.c
@@ -21,7 +21,7 @@ static int loadavg_proc_show(struct seq_file *m, void *v)
 		LOAD_INT(avnrun[1]), LOAD_FRAC(avnrun[1]),
 		LOAD_INT(avnrun[2]), LOAD_FRAC(avnrun[2]),
 		nr_running(), nr_threads,
-		idr_get_cursor(&task_active_pid_ns(current)->idr) - 1);
+		idr_get_cursor(&task_active_pid_ns(sysiso_current)->idr) - 1);
 	return 0;
 }
 
diff --git a/fs/proc/proc_net.c b/fs/proc/proc_net.c
index 15c2e55d2..22283cbd0 100644
--- a/fs/proc/proc_net.c
+++ b/fs/proc/proc_net.c
@@ -87,7 +87,7 @@ int bpf_iter_init_seq_net(void *priv_data, struct bpf_iter_aux_info *aux)
 #ifdef CONFIG_NET_NS
 	struct seq_net_private *p = priv_data;
 
-	p->net = get_net(current->nsproxy->net_ns);
+	p->net = get_net(sysiso_current->nsproxy->net_ns);
 #endif
 	return 0;
 }
diff --git a/fs/proc/root.c b/fs/proc/root.c
index c7e3b1350..def4af18f 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -252,7 +252,7 @@ static int proc_init_fs_context(struct fs_context *fc)
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->pid_ns = get_pid_ns(task_active_pid_ns(current));
+	ctx->pid_ns = get_pid_ns(task_active_pid_ns(sysiso_current));
 	put_user_ns(fc->user_ns);
 	fc->user_ns = get_user_ns(ctx->pid_ns->user_ns);
 	fc->fs_private = ctx;
diff --git a/fs/proc/self.c b/fs/proc/self.c
index 72cd69bca..55f0c4742 100644
--- a/fs/proc/self.c
+++ b/fs/proc/self.c
@@ -13,7 +13,7 @@ static const char *proc_self_get_link(struct dentry *dentry,
 				      struct delayed_call *done)
 {
 	struct pid_namespace *ns = proc_pid_ns(inode->i_sb);
-	pid_t tgid = task_tgid_nr_ns(current, ns);
+	pid_t tgid = task_tgid_nr_ns(sysiso_current, ns);
 	char *name;
 
 	if (!tgid)
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index a6d21fc00..843f89800 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -54,20 +54,20 @@ void task_mem(struct seq_file *m, struct mm_struct *mm)
 	else
 		bytes += kobjsize(mm);
 	
-	if (current->fs && current->fs->users > 1)
-		sbytes += kobjsize(current->fs);
+	if (sysiso_current->fs && sysiso_current->fs->users > 1)
+		sbytes += kobjsize(sysiso_current->fs);
 	else
-		bytes += kobjsize(current->fs);
+		bytes += kobjsize(sysiso_current->fs);
 
-	if (current->files && atomic_read(&current->files->count) > 1)
-		sbytes += kobjsize(current->files);
+	if (sysiso_current->files && atomic_read(&sysiso_current->files->count) > 1)
+		sbytes += kobjsize(sysiso_current->files);
 	else
-		bytes += kobjsize(current->files);
+		bytes += kobjsize(sysiso_current->files);
 
-	if (current->sighand && refcount_read(&current->sighand->count) > 1)
-		sbytes += kobjsize(current->sighand);
+	if (sysiso_current->sighand && refcount_read(&current->sighand->count) > 1)
+		sbytes += kobjsize(sysiso_current->sighand);
 	else
-		bytes += kobjsize(current->sighand);
+		bytes += kobjsize(sysiso_current->sighand);
 
 	bytes += kobjsize(current); /* includes kernel stack */
 
diff --git a/fs/proc/thread_self.c b/fs/proc/thread_self.c
index a553273fb..27dacf328 100644
--- a/fs/proc/thread_self.c
+++ b/fs/proc/thread_self.c
@@ -13,8 +13,8 @@ static const char *proc_thread_self_get_link(struct dentry *dentry,
 					     struct delayed_call *done)
 {
 	struct pid_namespace *ns = proc_pid_ns(inode->i_sb);
-	pid_t tgid = task_tgid_nr_ns(current, ns);
-	pid_t pid = task_pid_nr_ns(current, ns);
+	pid_t tgid = task_tgid_nr_ns(sysiso_current, ns);
+	pid_t pid = task_pid_nr_ns(sysiso_current, ns);
 	char *name;
 
 	if (!pid)
diff --git a/fs/read_write.c b/fs/read_write.c
index af057c57b..4cfd6b259 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -412,7 +412,7 @@ static int warn_unsupported(struct file *file, const char *op)
 {
 	pr_warn_ratelimited(
 		"kernel %s not supported for file %pD4 (pid: %d comm: %.20s)\n",
-		op, file, current->pid, current->comm);
+		op, file, sysiso_current->pid, sysiso_current->comm);
 	return -EINVAL;
 }
 
diff --git a/fs/readdir.c b/fs/readdir.c
index 09e8ed7d4..940fd1545 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -242,7 +242,7 @@ static int filldir(struct dir_context *ctx, const char *name, int namlen,
 		return -EOVERFLOW;
 	}
 	prev_reclen = buf->prev_reclen;
-	if (prev_reclen && signal_pending(current))
+	if (prev_reclen && signal_pending(sysiso_current))
 		return -EINTR;
 	dirent = buf->current_dir;
 	prev = (void __user *) dirent - prev_reclen;
@@ -324,7 +324,7 @@ static int filldir64(struct dir_context *ctx, const char *name, int namlen,
 	if (reclen > buf->count)
 		return -EINVAL;
 	prev_reclen = buf->prev_reclen;
-	if (prev_reclen && signal_pending(current))
+	if (prev_reclen && signal_pending(sysiso_current))
 		return -EINTR;
 	dirent = buf->current_dir;
 	prev = (void __user *)dirent - prev_reclen;
@@ -494,7 +494,7 @@ static int compat_filldir(struct dir_context *ctx, const char *name, int namlen,
 		return -EOVERFLOW;
 	}
 	prev_reclen = buf->prev_reclen;
-	if (prev_reclen && signal_pending(current))
+	if (prev_reclen && signal_pending(sysiso_current))
 		return -EINTR;
 	dirent = buf->current_dir;
 	prev = (void __user *) dirent - prev_reclen;
diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
index f49b72cca..2d1156dc2 100644
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -1780,7 +1780,7 @@ int reiserfs_write_inode(struct inode *inode, struct writeback_control *wbc)
 	 * inode needs to reach disk for safety, and they can safely be
 	 * ignored because the altered inode has already been logged.
 	 */
-	if (wbc->sync_mode == WB_SYNC_ALL && !(current->flags & PF_MEMALLOC)) {
+	if (wbc->sync_mode == WB_SYNC_ALL && !(sysiso_current->flags & PF_MEMALLOC)) {
 		reiserfs_write_lock(inode->i_sb);
 		if (!journal_begin(&th, inode->i_sb, jbegin_count)) {
 			reiserfs_update_sd(&th, inode);
@@ -2537,7 +2537,7 @@ static int reiserfs_write_full_page(struct page *page,
 	th.t_trans_id = 0;
 
 	/* no logging allowed when nonblocking or from PF_MEMALLOC */
-	if (checked && (current->flags & PF_MEMALLOC)) {
+	if (checked && (sysiso_current->flags & PF_MEMALLOC)) {
 		redirty_page_for_writepage(wbc, page);
 		unlock_page(page);
 		return 0;
diff --git a/fs/reiserfs/stree.c b/fs/reiserfs/stree.c
index ef4272921..d2a0d6d94 100644
--- a/fs/reiserfs/stree.c
+++ b/fs/reiserfs/stree.c
@@ -654,7 +654,7 @@ int search_by_key(struct super_block *sb, const struct cpu_key *key,
 			reiserfs_warning(sb, "PAP-5100",
 					 "%s: there were %d iterations of "
 					 "while loop looking for key %K",
-					 current->comm, repeat_counter,
+					 sysiso_current->comm, repeat_counter,
 					 key);
 #endif
 
diff --git a/fs/remap_range.c b/fs/remap_range.c
index 6d4a9beaa..b81b1c888 100644
--- a/fs/remap_range.c
+++ b/fs/remap_range.c
@@ -562,7 +562,7 @@ int vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)
 next_fdput:
 		fdput(dst_fd);
 next_loop:
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			break;
 	}
 	return ret;
diff --git a/fs/select.c b/fs/select.c
index 945896d0a..dd09afff4 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -11,7 +11,7 @@
  *     parameter to reflect time remaining.
  *
  *  24 January 2000
- *     Changed sys_poll()/do_poll() to use PAGE_SIZE chunk-based allocation 
+ *     Changed sys_poll()/do_poll() to use PAGE_SIZE chunk-based allocation
  *     of fds to overcome nfds < 16390 descriptors limit (Tigran Aivazian).
  */
 
@@ -87,8 +87,8 @@ u64 select_estimate_accuracy(struct timespec64 *tv)
 	ktime_get_ts64(&now);
 	now = timespec64_sub(*tv, now);
 	ret = __estimate_accuracy(&now);
-	if (ret < current->timer_slack_ns)
-		return current->timer_slack_ns;
+	if (ret < sysiso_current->timer_slack_ns)
+		return sysiso_current->timer_slack_ns;
 	return ret;
 }
 
@@ -305,7 +305,7 @@ static int poll_select_finish(struct timespec64 *end_time,
 	if (!p)
 		return ret;
 
-	if (current->personality & STICKY_TIMEOUTS)
+	if (sysiso_current->personality & STICKY_TIMEOUTS)
 		goto sticky;
 
 	/* No update for zero timeout */
@@ -426,7 +426,7 @@ static int max_select_fd(unsigned long n, fd_set_bits *fds)
 	/* handle last in-complete long-word first */
 	set = ~(~0UL << (n & (BITS_PER_LONG-1)));
 	n /= BITS_PER_LONG;
-	fdt = files_fdtable(current->files);
+	fdt = files_fdtable(sysiso_current->files);
 	open_fds = fdt->open_fds + n;
 	max = 0;
 	if (set) {
@@ -572,7 +572,7 @@ static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)
 			cond_resched();
 		}
 		wait->_qproc = NULL;
-		if (retval || timed_out || signal_pending(current))
+		if (retval || timed_out || signal_pending(sysiso_current))
 			break;
 		if (table.error) {
 			retval = table.error;
@@ -635,7 +635,7 @@ int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,
 
 	/* max_fds can increase, so grab it once to avoid race */
 	rcu_read_lock();
-	fdt = files_fdtable(current->files);
+	fdt = files_fdtable(sysiso_current->files);
 	max_fds = fdt->max_fds;
 	rcu_read_unlock();
 	if (n > max_fds)
@@ -644,7 +644,7 @@ int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,
 	/*
 	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),
 	 * since we used fdset we need to allocate memory in units of
-	 * long-words. 
+	 * long-words.
 	 */
 	size = FDS_BYTES(n);
 	bits = stack_fds;
@@ -680,7 +680,7 @@ int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,
 		goto out;
 	if (!ret) {
 		ret = -ERESTARTNOHAND;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out;
 		ret = 0;
 	}
@@ -931,7 +931,7 @@ static int do_poll(struct poll_list *list, struct poll_wqueues *wait,
 		pt->_qproc = NULL;
 		if (!count) {
 			count = wait->error;
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				count = -ERESTARTNOHAND;
 		}
 		if (count || timed_out)
@@ -1078,7 +1078,7 @@ SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,
 	if (ret == -ERESTARTNOHAND) {
 		struct restart_block *restart_block;
 
-		restart_block = &current->restart_block;
+		restart_block = &sysiso_current->restart_block;
 		restart_block->poll.ufds = ufds;
 		restart_block->poll.nfds = nfds;
 
@@ -1202,7 +1202,7 @@ static int compat_core_sys_select(int n, compat_ulong_t __user *inp,
 
 	/* max_fds can increase, so grab it once to avoid race */
 	rcu_read_lock();
-	fdt = files_fdtable(current->files);
+	fdt = files_fdtable(sysiso_current->files);
 	max_fds = fdt->max_fds;
 	rcu_read_unlock();
 	if (n > max_fds)
@@ -1242,7 +1242,7 @@ static int compat_core_sys_select(int n, compat_ulong_t __user *inp,
 		goto out;
 	if (!ret) {
 		ret = -ERESTARTNOHAND;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out;
 		ret = 0;
 	}
diff --git a/fs/signalfd.c b/fs/signalfd.c
index 040e1cf90..143a470a8 100644
--- a/fs/signalfd.c
+++ b/fs/signalfd.c
@@ -63,14 +63,14 @@ static __poll_t signalfd_poll(struct file *file, poll_table *wait)
 	struct signalfd_ctx *ctx = file->private_data;
 	__poll_t events = 0;
 
-	poll_wait(file, &current->sighand->signalfd_wqh, wait);
+	poll_wait(file, &sysiso_current->sighand->signalfd_wqh, wait);
 
-	spin_lock_irq(&current->sighand->siglock);
-	if (next_signal(&current->pending, &ctx->sigmask) ||
-	    next_signal(&current->signal->shared_pending,
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	if (next_signal(&sysiso_current->pending, &ctx->sigmask) ||
+	    next_signal(&sysiso_current->signal->shared_pending,
 			&ctx->sigmask))
 		events |= EPOLLIN;
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	return events;
 }
@@ -166,10 +166,10 @@ static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info
 				int nonblock)
 {
 	ssize_t ret;
-	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_WAITQUEUE(wait, sysiso_current);
 
-	spin_lock_irq(&current->sighand->siglock);
-	ret = dequeue_signal(current, &ctx->sigmask, info);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	ret = dequeue_signal(sysiso_current, &ctx->sigmask, info);
 	switch (ret) {
 	case 0:
 		if (!nonblock)
@@ -177,27 +177,27 @@ static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info
 		ret = -EAGAIN;
 		fallthrough;
 	default:
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 		return ret;
 	}
 
-	add_wait_queue(&current->sighand->signalfd_wqh, &wait);
+	add_wait_queue(&sysiso_current->sighand->signalfd_wqh, &wait);
 	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		ret = dequeue_signal(current, &ctx->sigmask, info);
+		ret = dequeue_signal(sysiso_current, &ctx->sigmask, info);
 		if (ret != 0)
 			break;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 		schedule();
-		spin_lock_irq(&current->sighand->siglock);
+		spin_lock_irq(&sysiso_current->sighand->siglock);
 	}
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
-	remove_wait_queue(&current->sighand->signalfd_wqh, &wait);
+	remove_wait_queue(&sysiso_current->sighand->signalfd_wqh, &wait);
 	__set_current_state(TASK_RUNNING);
 
 	return ret;
@@ -297,11 +297,11 @@ static int do_signalfd4(int ufd, sigset_t *mask, int flags)
 			fdput(f);
 			return -EINVAL;
 		}
-		spin_lock_irq(&current->sighand->siglock);
+		spin_lock_irq(&sysiso_current->sighand->siglock);
 		ctx->sigmask = *mask;
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 
-		wake_up(&current->sighand->signalfd_wqh);
+		wake_up(&sysiso_current->sighand->signalfd_wqh);
 		fdput(f);
 	}
 
diff --git a/fs/splice.c b/fs/splice.c
index 5dbce4dcc..ebe9df02f 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -474,7 +474,7 @@ static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_des
 	 * Check for signal early to make process killable when there are
 	 * always buffers available
 	 */
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 repeat:
@@ -488,7 +488,7 @@ static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_des
 		if (sd->flags & SPLICE_F_NONBLOCK)
 			return -EAGAIN;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 
 		if (sd->need_wakeup) {
@@ -752,7 +752,7 @@ static int warn_unsupported(struct file *file, const char *op)
 {
 	pr_debug_ratelimited(
 		"splice %s not supported for file %pD4 (pid: %d comm: %.20s)\n",
-		op, file, current->pid, current->comm);
+		op, file, sysiso_current->pid, sysiso_current->comm);
 	return -EINVAL;
 }
 
@@ -831,7 +831,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 	 * neither in nor out is a pipe, setup an internal pipe attached to
 	 * 'out' and transfer the wanted data from 'in' to 'out' through that
 	 */
-	pipe = current->splice_pipe;
+	pipe = sysiso_current->splice_pipe;
 	if (unlikely(!pipe)) {
 		pipe = alloc_pipe_info();
 		if (!pipe)
@@ -844,7 +844,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 		 */
 		pipe->readers = 1;
 
-		current->splice_pipe = pipe;
+		sysiso_current->splice_pipe = pipe;
 	}
 
 	/*
@@ -995,7 +995,7 @@ static int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)
 			return 0;
 		if (flags & SPLICE_F_NONBLOCK)
 			return -EAGAIN;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		pipe_wait_writable(pipe);
 	}
@@ -1375,7 +1375,7 @@ static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)
 	pipe_lock(pipe);
 
 	while (pipe_empty(pipe->head, pipe->tail)) {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
@@ -1420,7 +1420,7 @@ static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)
 			ret = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/fs/stat.c b/fs/stat.c
index 28d2020ba..183b014e3 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -258,7 +258,7 @@ static int cp_old_stat(struct kstat *stat, struct __old_kernel_stat __user * sta
 	if (warncount > 0) {
 		warncount--;
 		printk(KERN_WARNING "VFS: Warning: %s using old stat() call. Recompile your binary.\n",
-			current->comm);
+			sysiso_current->comm);
 	} else if (warncount < 0) {
 		/* it's laughable, but... */
 		warncount = 0;
diff --git a/fs/ubifs/commit.c b/fs/ubifs/commit.c
index c4fc1047f..551120cc7 100644
--- a/fs/ubifs/commit.c
+++ b/fs/ubifs/commit.c
@@ -278,7 +278,7 @@ int ubifs_bg_thread(void *info)
 	struct ubifs_info *c = info;
 
 	ubifs_msg(c, "background thread \"%s\" started, PID %d",
-		  c->bgt_name, current->pid);
+		  c->bgt_name, sysiso_current->pid);
 	set_freezable();
 
 	while (1) {
@@ -374,7 +374,7 @@ void ubifs_request_bg_commit(struct ubifs_info *c)
  */
 static int wait_for_commit(struct ubifs_info *c)
 {
-	dbg_cmt("pid %d goes sleep", current->pid);
+	dbg_cmt("pid %d goes sleep", sysiso_current->pid);
 
 	/*
 	 * The following sleeps if the condition is false, and will be woken
@@ -385,7 +385,7 @@ static int wait_for_commit(struct ubifs_info *c)
 	 */
 	wait_event(c->cmt_wq, c->cmt_state != COMMIT_RUNNING_BACKGROUND &&
 			      c->cmt_state != COMMIT_RUNNING_REQUIRED);
-	dbg_cmt("commit finished, pid %d woke up", current->pid);
+	dbg_cmt("commit finished, pid %d woke up", sysiso_current->pid);
 	return 0;
 }
 
diff --git a/fs/ubifs/compress.c b/fs/ubifs/compress.c
index 3a92e6af6..9d5193db3 100644
--- a/fs/ubifs/compress.c
+++ b/fs/ubifs/compress.c
@@ -200,7 +200,8 @@ static int __init compr_init(struct ubifs_compressor *compr)
 		compr->cc = crypto_alloc_comp(compr->capi_name, 0, 0);
 		if (IS_ERR(compr->cc)) {
 			pr_err("UBIFS error (pid %d): cannot initialize compressor %s, error %ld",
-			       current->pid, compr->name, PTR_ERR(compr->cc));
+			       sysiso_current->pid, compr->name,
+			       PTR_ERR(compr->cc));
 			return PTR_ERR(compr->cc);
 		}
 	}
diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
index fc718f617..c5cddd10a 100644
--- a/fs/ubifs/debug.c
+++ b/fs/ubifs/debug.c
@@ -601,7 +601,7 @@ void ubifs_dump_lstats(const struct ubifs_lp_stats *lst)
 {
 	spin_lock(&dbg_lock);
 	pr_err("(pid %d) Lprops statistics: empty_lebs %d, idx_lebs  %d\n",
-	       current->pid, lst->empty_lebs, lst->idx_lebs);
+	       sysiso_current->pid, lst->empty_lebs, lst->idx_lebs);
 	pr_err("\ttaken_empty_lebs %d, total_free %lld, total_dirty %lld\n",
 	       lst->taken_empty_lebs, lst->total_free, lst->total_dirty);
 	pr_err("\ttotal_used %lld, total_dark %lld, total_dead %lld\n",
@@ -620,7 +620,7 @@ void ubifs_dump_budg(struct ubifs_info *c, const struct ubifs_budg_info *bi)
 	spin_lock(&c->space_lock);
 	spin_lock(&dbg_lock);
 	pr_err("(pid %d) Budgeting info: data budget sum %lld, total budget sum %lld\n",
-	       current->pid, bi->data_growth + bi->dd_growth,
+	       sysiso_current->pid, bi->data_growth + bi->dd_growth,
 	       bi->data_growth + bi->dd_growth + bi->idx_growth);
 	pr_err("\tbudg_data_growth %lld, budg_dd_growth %lld, budg_idx_growth %lld\n",
 	       bi->data_growth, bi->dd_growth, bi->idx_growth);
@@ -774,7 +774,7 @@ void ubifs_dump_lprops(struct ubifs_info *c)
 	struct ubifs_lprops lp;
 	struct ubifs_lp_stats lst;
 
-	pr_err("(pid %d) start dumping LEB properties\n", current->pid);
+	pr_err("(pid %d) start dumping LEB properties\n", sysiso_current->pid);
 	ubifs_get_lp_stats(c, &lst);
 	ubifs_dump_lstats(&lst);
 
@@ -787,7 +787,8 @@ void ubifs_dump_lprops(struct ubifs_info *c)
 
 		ubifs_dump_lprop(c, &lp);
 	}
-	pr_err("(pid %d) finish dumping LEB properties\n", current->pid);
+	pr_err("(pid %d) finish dumping LEB properties\n",
+	       sysiso_current->pid);
 }
 
 void ubifs_dump_lpt_info(struct ubifs_info *c)
@@ -795,7 +796,7 @@ void ubifs_dump_lpt_info(struct ubifs_info *c)
 	int i;
 
 	spin_lock(&dbg_lock);
-	pr_err("(pid %d) dumping LPT information\n", current->pid);
+	pr_err("(pid %d) dumping LPT information\n", sysiso_current->pid);
 	pr_err("\tlpt_sz:        %lld\n", c->lpt_sz);
 	pr_err("\tpnode_sz:      %d\n", c->pnode_sz);
 	pr_err("\tnnode_sz:      %d\n", c->nnode_sz);
@@ -834,7 +835,7 @@ void ubifs_dump_leb(const struct ubifs_info *c, int lnum)
 	struct ubifs_scan_node *snod;
 	void *buf;
 
-	pr_err("(pid %d) start dumping LEB %d\n", current->pid, lnum);
+	pr_err("(pid %d) start dumping LEB %d\n", sysiso_current->pid, lnum);
 
 	buf = __vmalloc(c->leb_size, GFP_NOFS);
 	if (!buf) {
@@ -858,7 +859,7 @@ void ubifs_dump_leb(const struct ubifs_info *c, int lnum)
 		ubifs_dump_node(c, snod->node, c->leb_size - snod->offs);
 	}
 
-	pr_err("(pid %d) finish dumping LEB %d\n", current->pid, lnum);
+	pr_err("(pid %d) finish dumping LEB %d\n", sysiso_current->pid, lnum);
 	ubifs_scan_destroy(sleb);
 
 out:
@@ -910,7 +911,7 @@ void ubifs_dump_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat)
 	int i;
 
 	pr_err("(pid %d) start dumping heap cat %d (%d elements)\n",
-	       current->pid, cat, heap->cnt);
+	       sysiso_current->pid, cat, heap->cnt);
 	for (i = 0; i < heap->cnt; i++) {
 		struct ubifs_lprops *lprops = heap->arr[i];
 
@@ -918,7 +919,7 @@ void ubifs_dump_heap(struct ubifs_info *c, struct ubifs_lpt_heap *heap, int cat)
 		       i, lprops->lnum, lprops->hpos, lprops->free,
 		       lprops->dirty, lprops->flags);
 	}
-	pr_err("(pid %d) finish dumping heap\n", current->pid);
+	pr_err("(pid %d) finish dumping heap\n", sysiso_current->pid);
 }
 
 void ubifs_dump_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,
@@ -926,7 +927,7 @@ void ubifs_dump_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,
 {
 	int i;
 
-	pr_err("(pid %d) dumping pnode:\n", current->pid);
+	pr_err("(pid %d) dumping pnode:\n", sysiso_current->pid);
 	pr_err("\taddress %zx parent %zx cnext %zx\n",
 	       (size_t)pnode, (size_t)parent, (size_t)pnode->cnext);
 	pr_err("\tflags %lu iip %d level %d num %d\n",
@@ -945,7 +946,7 @@ void ubifs_dump_tnc(struct ubifs_info *c)
 	int level;
 
 	pr_err("\n");
-	pr_err("(pid %d) start dumping TNC tree\n", current->pid);
+	pr_err("(pid %d) start dumping TNC tree\n", sysiso_current->pid);
 	znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
 	level = znode->level;
 	pr_err("== Level %d ==\n", level);
@@ -957,7 +958,7 @@ void ubifs_dump_tnc(struct ubifs_info *c)
 		ubifs_dump_znode(c, znode);
 		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
 	}
-	pr_err("(pid %d) finish dumping TNC tree\n", current->pid);
+	pr_err("(pid %d) finish dumping TNC tree\n", sysiso_current->pid);
 }
 
 static int dump_znode(struct ubifs_info *c, struct ubifs_znode *znode,
diff --git a/fs/ubifs/lpt_commit.c b/fs/ubifs/lpt_commit.c
index d76a19e46..b34f887cc 100644
--- a/fs/ubifs/lpt_commit.c
+++ b/fs/ubifs/lpt_commit.c
@@ -1844,7 +1844,7 @@ static void dump_lpt_leb(const struct ubifs_info *c, int lnum)
 	int err, len = c->leb_size, node_type, node_num, node_len, offs;
 	void *buf, *p;
 
-	pr_err("(pid %d) start dumping LEB %d\n", current->pid, lnum);
+	pr_err("(pid %d) start dumping LEB %d\n", sysiso_current->pid, lnum);
 	buf = p = __vmalloc(c->leb_size, GFP_NOFS);
 	if (!buf) {
 		ubifs_err(c, "cannot allocate memory to dump LPT");
@@ -1930,7 +1930,7 @@ static void dump_lpt_leb(const struct ubifs_info *c, int lnum)
 		len -= node_len;
 	}
 
-	pr_err("(pid %d) finish dumping LEB %d\n", current->pid, lnum);
+	pr_err("(pid %d) finish dumping LEB %d\n", sysiso_current->pid, lnum);
 out:
 	vfree(buf);
 	return;
@@ -1947,10 +1947,10 @@ void ubifs_dump_lpt_lebs(const struct ubifs_info *c)
 {
 	int i;
 
-	pr_err("(pid %d) start dumping all LPT LEBs\n", current->pid);
+	pr_err("(pid %d) start dumping all LPT LEBs\n", sysiso_current->pid);
 	for (i = 0; i < c->lpt_lebs; i++)
 		dump_lpt_leb(c, i + c->lpt_first);
-	pr_err("(pid %d) finish dumping all LPT LEBs\n", current->pid);
+	pr_err("(pid %d) finish dumping all LPT LEBs\n", sysiso_current->pid);
 }
 
 /**
diff --git a/fs/ubifs/misc.c b/fs/ubifs/misc.c
index cd23de0f2..42b18d806 100644
--- a/fs/ubifs/misc.c
+++ b/fs/ubifs/misc.c
@@ -31,7 +31,7 @@ void ubifs_err(const struct ubifs_info *c, const char *fmt, ...)
 	vaf.va = &args;
 
 	pr_err("UBIFS error (ubi%d:%d pid %d): %ps: %pV\n",
-	       c->vi.ubi_num, c->vi.vol_id, current->pid,
+	       c->vi.ubi_num, c->vi.vol_id, sysiso_current->pid,
 	       __builtin_return_address(0),
 	       &vaf);
 
@@ -50,7 +50,7 @@ void ubifs_warn(const struct ubifs_info *c, const char *fmt, ...)
 	vaf.va = &args;
 
 	pr_warn("UBIFS warning (ubi%d:%d pid %d): %ps: %pV\n",
-		c->vi.ubi_num, c->vi.vol_id, current->pid,
+		c->vi.ubi_num, c->vi.vol_id, sysiso_current->pid,
 		__builtin_return_address(0),
 		&vaf);
 
diff --git a/fs/ubifs/super.c b/fs/ubifs/super.c
index f0fb25727..1e2bed24b 100644
--- a/fs/ubifs/super.c
+++ b/fs/ubifs/super.c
@@ -2282,7 +2282,7 @@ static struct dentry *ubifs_mount(struct file_system_type *fs_type, int flags,
 	if (IS_ERR(ubi)) {
 		if (!(flags & SB_SILENT))
 			pr_err("UBIFS error (pid: %d): cannot open \"%s\", error %d",
-			       current->pid, name, (int)PTR_ERR(ubi));
+			       sysiso_current->pid, name, (int)PTR_ERR(ubi));
 		return ERR_CAST(ubi);
 	}
 
@@ -2415,7 +2415,7 @@ static int __init ubifs_init(void)
 	 */
 	if (PAGE_SIZE < UBIFS_BLOCK_SIZE) {
 		pr_err("UBIFS error (pid %d): VFS page cache size is %u bytes, but UBIFS requires at least 4096 bytes",
-		       current->pid, (unsigned int)PAGE_SIZE);
+		       sysiso_current->pid, (unsigned int)PAGE_SIZE);
 		return -EINVAL;
 	}
 
@@ -2439,7 +2439,7 @@ static int __init ubifs_init(void)
 	err = register_filesystem(&ubifs_fs_type);
 	if (err) {
 		pr_err("UBIFS error (pid %d): cannot register file system, error %d",
-		       current->pid, err);
+		       sysiso_current->pid, err);
 		goto out_dbg;
 	}
 	return 0;
diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c
index 22bf14ab2..2fc1a9f92 100644
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@ -214,7 +214,7 @@ static inline struct uffd_msg userfault_msg(unsigned long address,
 	if (reason & VM_UFFD_MINOR)
 		msg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_MINOR;
 	if (features & UFFD_FEATURE_THREAD_ID)
-		msg.arg.pagefault.feat.ptid = task_pid_vnr(current);
+		msg.arg.pagefault.feat.ptid = task_pid_vnr(sysiso_current);
 	return msg;
 }
 
@@ -384,7 +384,7 @@ vm_fault_t handle_userfault(struct vm_fault *vmf, unsigned long reason)
 	 * shmem_vm_ops->fault method is invoked even during
 	 * coredumping without mmap_lock and it ends up here.
 	 */
-	if (current->flags & (PF_EXITING|PF_DUMPCORE))
+	if (sysiso_current->flags & (PF_EXITING|PF_DUMPCORE))
 		goto out;
 
 	/*
@@ -556,7 +556,7 @@ static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
 {
 	struct userfaultfd_ctx *release_new_ctx;
 
-	if (WARN_ON_ONCE(current->flags & PF_EXITING))
+	if (WARN_ON_ONCE(sysiso_current->flags & PF_EXITING))
 		goto out;
 
 	ewq->ctx = ctx;
@@ -574,7 +574,7 @@ static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
 		if (ewq->msg.event == 0)
 			break;
 		if (READ_ONCE(ctx->released) ||
-		    fatal_signal_pending(current)) {
+		    fatal_signal_pending(sysiso_current)) {
 			/*
 			 * &ewq->wq may be queued in fork_event, but
 			 * __remove_wait_queue ignores the head
@@ -1086,7 +1086,7 @@ static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,
 		}
 		spin_unlock(&ctx->event_wqh.lock);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/fs/verity/enable.c b/fs/verity/enable.c
index 60a4372aa..e645f4079 100644
--- a/fs/verity/enable.c
+++ b/fs/verity/enable.c
@@ -133,7 +133,7 @@ static int build_merkle_tree_level(struct file *filp, unsigned int level,
 			pending_size = 0;
 		}
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return -EINTR;
 		cond_resched();
 	}
diff --git a/fs/verity/read_metadata.c b/fs/verity/read_metadata.c
index 7e2d0c7bd..65afd3b9d 100644
--- a/fs/verity/read_metadata.c
+++ b/fs/verity/read_metadata.c
@@ -67,7 +67,7 @@ static int fsverity_read_merkle_tree(struct inode *inode,
 		buf += bytes_to_copy;
 		offset += bytes_to_copy;
 
-		if (fatal_signal_pending(current))  {
+		if (fatal_signal_pending(sysiso_current))  {
 			err = -EINTR;
 			break;
 		}
diff --git a/fs/xfs/kmem.c b/fs/xfs/kmem.c
index 6f49bf391..4ce5bd130 100644
--- a/fs/xfs/kmem.c
+++ b/fs/xfs/kmem.c
@@ -24,7 +24,7 @@ kmem_alloc(size_t size, xfs_km_flags_t flags)
 		if (!(++retries % 100))
 			xfs_err(NULL,
 	"%s(%u) possible memory allocation deadlock size %u in %s (mode:0x%x)",
-				current->comm, current->pid,
+				sysiso_current->comm, sysiso_current->pid,
 				(unsigned int)size, __func__, lflags);
 		congestion_wait(BLK_RW_ASYNC, HZ/50);
 	} while (1);
diff --git a/fs/xfs/scrub/common.h b/fs/xfs/scrub/common.h
index 454145db1..041fbfd7c 100644
--- a/fs/xfs/scrub/common.h
+++ b/fs/xfs/scrub/common.h
@@ -23,7 +23,7 @@ xchk_should_terminate(
 	 */
 	cond_resched();
 
-	if (fatal_signal_pending(current)) {
+	if (fatal_signal_pending(sysiso_current)) {
 		if (*error == 0)
 			*error = -EAGAIN;
 		return true;
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 5fa6cd947..efb0f6b48 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -284,8 +284,8 @@ xfs_buf_free_pages(
 		if (bp->b_pages[i])
 			__free_page(bp->b_pages[i]);
 	}
-	if (current->reclaim_state)
-		current->reclaim_state->reclaimed_slab += bp->b_page_count;
+	if (sysiso_current->reclaim_state)
+		sysiso_current->reclaim_state->reclaimed_slab += bp->b_page_count;
 
 	if (bp->b_pages != bp->b_page_array)
 		kmem_free(bp->b_pages);
diff --git a/fs/xfs/xfs_discard.c b/fs/xfs/xfs_discard.c
index 0191de8ce..108def84d 100644
--- a/fs/xfs/xfs_discard.c
+++ b/fs/xfs/xfs_discard.c
@@ -124,7 +124,7 @@ xfs_trim_extents(
 		if (error)
 			goto out_del_cursor;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			error = -ERESTARTSYS;
 			goto out_del_cursor;
 		}
diff --git a/fs/xfs/xfs_fsmap.c b/fs/xfs/xfs_fsmap.c
index 48287caad..e4b85fc1d 100644
--- a/fs/xfs/xfs_fsmap.c
+++ b/fs/xfs/xfs_fsmap.c
@@ -253,7 +253,7 @@ xfs_getfsmap_helper(
 	bool				shared;
 	int				error;
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 	/*
diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h
index c174262a0..d1ff55929 100644
--- a/fs/xfs/xfs_linux.h
+++ b/fs/xfs/xfs_linux.h
@@ -102,9 +102,9 @@ typedef __u32			xfs_nlink_t;
 
 #define current_cpu()		(raw_smp_processor_id())
 #define current_set_flags_nested(sp, f)		\
-		(*(sp) = current->flags, current->flags |= (f))
+		(*(sp) = sysiso_current->flags, sysiso_current->flags |= (f))
 #define current_restore_flags_nested(sp, f)	\
-		(current->flags = ((current->flags & ~(f)) | (*(sp) & (f))))
+		(sysiso_current->flags = ((sysiso_current->flags & ~(f)) | (*(sp) & (f))))
 
 #define NBBY		8		/* number of bits per byte */
 
diff --git a/fs/xfs/xfs_pwork.c b/fs/xfs/xfs_pwork.c
index c283b801c..ae2417173 100644
--- a/fs/xfs/xfs_pwork.c
+++ b/fs/xfs/xfs_pwork.c
@@ -69,11 +69,11 @@ xfs_pwork_init(
 	if (xfs_globals.pwork_threads >= 0)
 		nr_threads = xfs_globals.pwork_threads;
 #endif
-	trace_xfs_pwork_init(mp, nr_threads, current->pid);
+	trace_xfs_pwork_init(mp, nr_threads, sysiso_current->pid);
 
 	pctl->wq = alloc_workqueue("%s-%d",
 			WQ_UNBOUND | WQ_SYSFS | WQ_FREEZABLE, nr_threads, tag,
-			current->pid);
+			sysiso_current->pid);
 	if (!pctl->wq)
 		return -ENOMEM;
 	pctl->work_fn = work_fn;
diff --git a/fs/xfs/xfs_reflink.c b/fs/xfs/xfs_reflink.c
index 76355f293..06e6dff71 100644
--- a/fs/xfs/xfs_reflink.c
+++ b/fs/xfs/xfs_reflink.c
@@ -1234,7 +1234,7 @@ xfs_reflink_remap_blocks(
 		if (error)
 			break;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			error = -EINTR;
 			break;
 		}
diff --git a/include/asm-generic/uaccess.h b/include/asm-generic/uaccess.h
index 10ffa8b5c..40ad020be 100644
--- a/include/asm-generic/uaccess.h
+++ b/include/asm-generic/uaccess.h
@@ -108,11 +108,11 @@ raw_copy_to_user(void __user *to, const void *from, unsigned long n)
 #endif
 
 #ifndef get_fs
-#define get_fs()	(current_thread_info()->addr_limit)
+#define get_fs()	(sysiso_current->thread_info()->addr_limit)
 
 static inline void set_fs(mm_segment_t fs)
 {
-	current_thread_info()->addr_limit = fs;
+	sysiso_current->thread_info()->addr_limit = fs;
 }
 #endif
 
diff --git a/include/linux/audit.h b/include/linux/audit.h
index 82b7c1116..6f3120403 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -310,7 +310,7 @@ static inline void audit_set_context(struct task_struct *task, struct audit_cont
 
 static inline struct audit_context *audit_context(void)
 {
-	return current->audit_context;
+	return sysiso_current->audit_context;
 }
 
 static inline bool audit_dummy_context(void)
diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h
index ac7f231b8..354423e06 100644
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@ -250,7 +250,7 @@ wb_get_create_current(struct backing_dev_info *bdi, gfp_t gfp)
 	if (unlikely(!wb)) {
 		struct cgroup_subsys_state *memcg_css;
 
-		memcg_css = task_get_css(current, memory_cgrp_id);
+		memcg_css = task_get_css(sysiso_current, memory_cgrp_id);
 		wb = wb_get_create(bdi, memcg_css, gfp);
 		css_put(memcg_css);
 	}
diff --git a/include/linux/blk-cgroup.h b/include/linux/blk-cgroup.h
index b4de2010f..925b97782 100644
--- a/include/linux/blk-cgroup.h
+++ b/include/linux/blk-cgroup.h
@@ -226,7 +226,7 @@ static inline struct cgroup_subsys_state *blkcg_css(void)
 	css = kthread_blkcg();
 	if (css)
 		return css;
-	return task_css(current, io_cgrp_id);
+	return task_css(sysiso_current, io_cgrp_id);
 }
 
 static inline struct blkcg *css_to_blkcg(struct cgroup_subsys_state *css)
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 1c758b0e0..f6342a9b1 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -515,7 +515,7 @@ int compat_restore_altstack(const compat_stack_t __user *uss);
 int __compat_save_altstack(compat_stack_t __user *, unsigned long);
 #define unsafe_compat_save_altstack(uss, sp, label) do { \
 	compat_stack_t __user *__uss = uss; \
-	struct task_struct *t = current; \
+	struct task_struct *t = sysiso_current;			    \
 	unsafe_put_user(ptr_to_compat((void __user *)t->sas_ss_sp), \
 			&__uss->ss_sp, label); \
 	unsafe_put_user(t->sas_ss_flags, &__uss->ss_flags, label); \
diff --git a/include/linux/cred.h b/include/linux/cred.h
index fcbc6885c..412b42ca0 100644
--- a/include/linux/cred.h
+++ b/include/linux/cred.h
@@ -196,7 +196,7 @@ do {							\
 
 #define validate_process_creds()				\
 do {								\
-	__validate_process_creds(current, __FILE__, __LINE__);	\
+	__validate_process_creds(sysiso_current, __FILE__, __LINE__);	\
 } while(0)
 
 extern void validate_creds_for_do_exit(struct task_struct *);
@@ -296,7 +296,7 @@ static inline void put_cred(const struct cred *_cred)
  * since nobody else can modify it.
  */
 #define current_cred() \
-	rcu_dereference_protected(current->cred, 1)
+	rcu_dereference_protected(sysiso_current->cred, 1)
 
 /**
  * current_real_cred - Access the current task's objective credentials
@@ -305,7 +305,7 @@ static inline void put_cred(const struct cred *_cred)
  * since nobody else can modify it.
  */
 #define current_real_cred() \
-	rcu_dereference_protected(current->real_cred, 1)
+	rcu_dereference_protected(sysiso_current->real_cred, 1)
 
 /**
  * __task_cred - Access a task's objective credentials
diff --git a/include/linux/elf.h b/include/linux/elf.h
index c9a46c4e1..6d663ca6b 100644
--- a/include/linux/elf.h
+++ b/include/linux/elf.h
@@ -14,7 +14,7 @@
 #endif
 #ifndef SET_PERSONALITY
 #define SET_PERSONALITY(ex) \
-	set_personality(PER_LINUX | (current->personality & (~PER_MASK)))
+	set_personality(PER_LINUX | (sysiso_current->personality & (~PER_MASK)))
 #endif
 
 #ifndef SET_PERSONALITY2
diff --git a/include/linux/eventfd.h b/include/linux/eventfd.h
index 305d5f190..f4cb8570f 100644
--- a/include/linux/eventfd.h
+++ b/include/linux/eventfd.h
@@ -46,7 +46,7 @@ void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt);
 
 static inline bool eventfd_signal_allowed(void)
 {
-	return !current->in_eventfd_signal;
+	return !sysiso_current->in_eventfd_signal;
 }
 
 #else /* CONFIG_EVENTFD */
diff --git a/include/linux/fdtable.h b/include/linux/fdtable.h
index d0e781748..2bcee2901 100644
--- a/include/linux/fdtable.h
+++ b/include/linux/fdtable.h
@@ -107,7 +107,7 @@ static inline struct file *files_lookup_fd_rcu(struct files_struct *files, unsig
 
 static inline struct file *lookup_fd_rcu(unsigned int fd)
 {
-	return files_lookup_fd_rcu(current->files, fd);
+	return files_lookup_fd_rcu(sysiso_current->files, fd);
 }
 
 struct file *task_lookup_fd_rcu(struct task_struct *task, unsigned int fd);
@@ -115,6 +115,7 @@ struct file *task_lookup_next_fd_rcu(struct task_struct *task, unsigned int *fd)
 
 struct task_struct;
 
+void get_files_struct(struct task_struct *task);
 void put_files_struct(struct files_struct *fs);
 int unshare_files(void);
 struct files_struct *dup_fd(struct files_struct *, unsigned, int *) __latent_entropy;
diff --git a/include/linux/filter.h b/include/linux/filter.h
index ef03ff342..7dd99e30f 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -1079,7 +1079,7 @@ static inline void bpf_jit_dump(unsigned int flen, unsigned int proglen,
 				u32 pass, void *image)
 {
 	pr_err("flen=%u proglen=%u pass=%u image=%pK from=%s pid=%d\n", flen,
-	       proglen, pass, image, current->comm, task_pid_nr(current));
+	       proglen, pass, image, sysiso_current->comm, task_pid_nr(current));
 
 	if (image)
 		print_hex_dump(KERN_ERR, "JIT code: ", DUMP_PREFIX_OFFSET,
diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index 0621c5f86..1cee2b8b6 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -55,14 +55,14 @@ extern void thaw_kernel_threads(void);
 static inline bool try_to_freeze_unsafe(void)
 {
 	might_sleep();
-	if (likely(!freezing(current)))
+	if (likely(!freezing(sysiso_current)))
 		return false;
 	return __refrigerator(false);
 }
 
 static inline bool try_to_freeze(void)
 {
-	if (!(current->flags & PF_NOFREEZE))
+	if (!(sysiso_current->flags & PF_NOFREEZE))
 		debug_check_no_locks_held();
 	return try_to_freeze_unsafe();
 }
@@ -106,7 +106,7 @@ static inline bool cgroup_freezing(struct task_struct *task)
  */
 static inline void freezer_do_not_count(void)
 {
-	current->flags |= PF_FREEZER_SKIP;
+	sysiso_current->flags |= PF_FREEZER_SKIP;
 }
 
 /**
@@ -118,7 +118,7 @@ static inline void freezer_do_not_count(void)
  */
 static inline void freezer_count(void)
 {
-	current->flags &= ~PF_FREEZER_SKIP;
+	sysiso_current->flags &= ~PF_FREEZER_SKIP;
 	/*
 	 * If freezing is in progress, the following paired with smp_mb()
 	 * in freezer_should_skip() ensures that either we see %true
@@ -131,7 +131,7 @@ static inline void freezer_count(void)
 /* DO NOT ADD ANY NEW CALLERS OF THIS FUNCTION */
 static inline void freezer_count_unsafe(void)
 {
-	current->flags &= ~PF_FREEZER_SKIP;
+	sysiso_current->flags &= ~PF_FREEZER_SKIP;
 	smp_mb();
 	try_to_freeze_unsafe();
 }
diff --git a/include/linux/kthread.h b/include/linux/kthread.h
index 346b0f269..7f1c56213 100644
--- a/include/linux/kthread.h
+++ b/include/linux/kthread.h
@@ -40,7 +40,7 @@ bool kthread_is_per_cpu(struct task_struct *k);
 
 /**
  * kthread_run - create and wake a thread.
- * @threadfn: the function to run until signal_pending(current).
+ * @threadfn: the function to run until signal_pending(sysiso_current).
  * @data: data ptr for @threadfn.
  * @namefmt: printf-style name for the thread.
  *
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 73a52aba4..2110c1b97 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -378,7 +378,7 @@ extern unsigned int kobjsize(const void *objp);
 /* Bits set in the VMA until the stack is in its final location */
 #define VM_STACK_INCOMPLETE_SETUP	(VM_RAND_READ | VM_SEQ_READ)
 
-#define TASK_EXEC ((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0)
+#define TASK_EXEC ((sysiso_current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0)
 
 /* Common data flag combinations */
 #define VM_DATA_FLAGS_TSK_EXEC	(VM_READ | VM_WRITE | TASK_EXEC | \
diff --git a/include/linux/personality.h b/include/linux/personality.h
index fc16fbc65..7d595272e 100644
--- a/include/linux/personality.h
+++ b/include/linux/personality.h
@@ -12,6 +12,6 @@
 /*
  * Change personality of the currently running process.
  */
-#define set_personality(pers)	(current->personality = (pers))
+#define set_personality(pers)	(sysiso_current->personality = (pers))
 
 #endif /* _LINUX_PERSONALITY_H */
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index b5ebf6c01..14d95940e 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -398,7 +398,7 @@ static inline void user_single_step_report(struct pt_regs *regs)
 #endif
 
 #ifndef current_pt_regs
-#define current_pt_regs() task_pt_regs(current)
+#define current_pt_regs() task_pt_regs(sysiso_current)
 #endif
 
 /*
@@ -407,7 +407,7 @@ static inline void user_single_step_report(struct pt_regs *regs)
  * is optimisation.
  */
 #ifndef signal_pt_regs
-#define signal_pt_regs() task_pt_regs(current)
+#define signal_pt_regs() task_pt_regs(sysiso_current)
 #endif
 
 #ifndef current_user_stack_pointer
diff --git a/include/linux/ratelimit.h b/include/linux/ratelimit.h
index b17e0cd0a..f7fdc2509 100644
--- a/include/linux/ratelimit.h
+++ b/include/linux/ratelimit.h
@@ -29,7 +29,7 @@ static inline void ratelimit_state_exit(struct ratelimit_state *rs)
 
 	if (rs->missed) {
 		pr_warn("%s: %d output lines suppressed due to ratelimiting\n",
-			current->comm, rs->missed);
+			sysiso_current->comm, rs->missed);
 		rs->missed = 0;
 	}
 }
diff --git a/include/linux/rcupdate.h b/include/linux/rcupdate.h
index 434d12fe2..ceb6b77c0 100644
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@ -53,7 +53,7 @@ void __rcu_read_unlock(void);
  * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other
  * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.
  */
-#define rcu_preempt_depth() READ_ONCE(current->rcu_read_lock_nesting)
+#define rcu_preempt_depth() READ_ONCE(sysiso_current->rcu_read_lock_nesting)
 
 #else /* #ifdef CONFIG_PREEMPT_RCU */
 
@@ -212,7 +212,7 @@ static inline void exit_tasks_rcu_finish(void) { }
  */
 #define cond_resched_tasks_rcu_qs() \
 do { \
-	rcu_tasks_qs(current, false); \
+	rcu_tasks_qs(sysiso_current, false); \
 	cond_resched(); \
 } while (0)
 
diff --git a/include/linux/rcuwait.h b/include/linux/rcuwait.h
index 61c56cca9..a851ac8fe 100644
--- a/include/linux/rcuwait.h
+++ b/include/linux/rcuwait.h
@@ -66,7 +66,7 @@ static inline void finish_rcuwait(struct rcuwait *w)
 		if (condition)						\
 			break;						\
 									\
-		if (signal_pending_state(state, current)) {		\
+		if (signal_pending_state(state, sysiso_current)) {		\
 			__ret = -EINTR;					\
 			break;						\
 		}							\
diff --git a/include/linux/sched.h b/include/linux/sched.h
index c1a927dde..2acc27569 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -36,6 +36,8 @@
 #include <linux/kcsan.h>
 #include <asm/kmap_size.h>
 
+#include <linux/sysiso.h>
+
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
 struct backing_dev_info;
@@ -199,18 +201,25 @@ struct task_group;
  *
  * Also see the comments of try_to_wake_up().
  */
-#define __set_current_state(state_value)				\
+#define __set_current_state_linux(state_value)				\
 	do {								\
 		debug_normal_state_change((state_value));		\
 		WRITE_ONCE(current->__state, (state_value));		\
 	} while (0)
 
-#define set_current_state(state_value)					\
+#define set_current_state_linux(state_value)					\
 	do {								\
 		debug_normal_state_change((state_value));		\
 		smp_store_mb(current->__state, (state_value));		\
 	} while (0)
 
+#ifdef CONFIG_SYSISO
+  #define __set_current_state(state_value) sysiso___set_current_state(state_value)
+  #define set_current_state(state_value) sysiso_set_current_state(state_value)
+#else
+  #define __set_current_state(state_value) __set_current_state_linux(state_value)
+  #define set_current_state(state_value) set_current_state_linux(state_value)
+#endif
 /*
  * set_special_state() should be used for those states when the blocking task
  * can not use the regular condition based wait-loop. In that case we must
@@ -221,10 +230,10 @@ struct task_group;
 	do {								\
 		unsigned long flags; /* may shadow */			\
 									\
-		raw_spin_lock_irqsave(&current->pi_lock, flags);	\
+		raw_spin_lock_irqsave(&sysiso_current->pi_lock, flags);	\
 		debug_special_state_change((state_value));		\
 		WRITE_ONCE(current->__state, (state_value));		\
-		raw_spin_unlock_irqrestore(&current->pi_lock, flags);	\
+		raw_spin_unlock_irqrestore(&sysiso_current->pi_lock, flags);	\
 	} while (0)
 
 /*
@@ -255,21 +264,21 @@ struct task_group;
 #define current_save_and_set_rtlock_wait_state()			\
 	do {								\
 		lockdep_assert_irqs_disabled();				\
-		raw_spin_lock(&current->pi_lock);			\
+		raw_spin_lock(&sysiso_current->pi_lock);			\
 		current->saved_state = current->__state;		\
 		debug_rtlock_wait_set_state();				\
 		WRITE_ONCE(current->__state, TASK_RTLOCK_WAIT);		\
-		raw_spin_unlock(&current->pi_lock);			\
+		raw_spin_unlock(&sysiso_current->pi_lock);			\
 	} while (0);
 
 #define current_restore_rtlock_saved_state()				\
 	do {								\
 		lockdep_assert_irqs_disabled();				\
-		raw_spin_lock(&current->pi_lock);			\
+		raw_spin_lock(&sysiso_current->pi_lock);			\
 		debug_rtlock_wait_restore_state();			\
 		WRITE_ONCE(current->__state, current->saved_state);	\
 		current->saved_state = TASK_RUNNING;			\
-		raw_spin_unlock(&current->pi_lock);			\
+		raw_spin_unlock(&sysiso_current->pi_lock);			\
 	} while (0);
 
 #define get_current_state()	READ_ONCE(current->__state)
@@ -287,6 +296,7 @@ extern long schedule_timeout_killable(long timeout);
 extern long schedule_timeout_uninterruptible(long timeout);
 extern long schedule_timeout_idle(long timeout);
 asmlinkage void schedule(void);
+asmlinkage void schedule_linux(void);
 extern void schedule_preempt_disabled(void);
 asmlinkage void preempt_schedule_irq(void);
 #ifdef CONFIG_PREEMPT_RT
@@ -1488,6 +1498,10 @@ struct task_struct {
 	struct callback_head		l1d_flush_kill;
 #endif
 
+#ifdef CONFIG_SYSISO
+	struct sysiso_task		*sysiso_task;
+#endif
+
 	/*
 	 * New fields for task_struct should be added above here, so that
 	 * they are included in the randomized portion of task_struct.
@@ -1714,7 +1728,7 @@ extern struct pid *cad_pid;
 #define conditional_used_math(condition)	conditional_stopped_child_used_math(condition, current)
 
 #define copy_to_stopped_child_used_math(child) \
-	do { (child)->flags &= ~PF_USED_MATH, (child)->flags |= current->flags & PF_USED_MATH; } while (0)
+	do { (child)->flags &= ~PF_USED_MATH, (child)->flags |= sysiso_current->flags & PF_USED_MATH; } while (0)
 
 /* NOTE: this will return 0 or PF_USED_MATH, it will never return 1 */
 #define tsk_used_math(p)			((p)->flags & PF_USED_MATH)
@@ -1723,7 +1737,7 @@ extern struct pid *cad_pid;
 static __always_inline bool is_percpu_thread(void)
 {
 #ifdef CONFIG_SMP
-	return (current->flags & PF_NO_SETAFFINITY) &&
+	return (sysiso_current->flags & PF_NO_SETAFFINITY) &&
 		(current->nr_cpus_allowed  == 1);
 #else
 	return true;
@@ -1784,8 +1798,8 @@ TASK_PFA_SET(SPEC_IB_FORCE_DISABLE, spec_ib_force_disable)
 static inline void
 current_restore_flags(unsigned long orig_flags, unsigned long flags)
 {
-	current->flags &= ~flags;
-	current->flags |= orig_flags & flags;
+	sysiso_current->flags &= ~flags;
+	sysiso_current->flags |= orig_flags & flags;
 }
 
 extern int cpuset_cpumask_can_shrink(const struct cpumask *cur, const struct cpumask *trial);
diff --git a/include/linux/sched/mm.h b/include/linux/sched/mm.h
index 5561486fd..a65394268 100644
--- a/include/linux/sched/mm.h
+++ b/include/linux/sched/mm.h
@@ -155,7 +155,7 @@ static inline bool in_vfork(struct task_struct *tsk)
  */
 static inline gfp_t current_gfp_context(gfp_t flags)
 {
-	unsigned int pflags = READ_ONCE(current->flags);
+	unsigned int pflags = READ_ONCE(sysiso_current->flags);
 
 	if (unlikely(pflags & (PF_MEMALLOC_NOIO | PF_MEMALLOC_NOFS | PF_MEMALLOC_PIN))) {
 		/*
@@ -214,8 +214,8 @@ static inline void might_alloc(gfp_t gfp_mask)
  */
 static inline unsigned int memalloc_noio_save(void)
 {
-	unsigned int flags = current->flags & PF_MEMALLOC_NOIO;
-	current->flags |= PF_MEMALLOC_NOIO;
+	unsigned int flags = sysiso_current->flags & PF_MEMALLOC_NOIO;
+	sysiso_current->flags |= PF_MEMALLOC_NOIO;
 	return flags;
 }
 
@@ -229,7 +229,7 @@ static inline unsigned int memalloc_noio_save(void)
  */
 static inline void memalloc_noio_restore(unsigned int flags)
 {
-	current->flags = (current->flags & ~PF_MEMALLOC_NOIO) | flags;
+	sysiso_current->flags = (sysiso_current->flags & ~PF_MEMALLOC_NOIO) | flags;
 }
 
 /**
@@ -245,8 +245,8 @@ static inline void memalloc_noio_restore(unsigned int flags)
  */
 static inline unsigned int memalloc_nofs_save(void)
 {
-	unsigned int flags = current->flags & PF_MEMALLOC_NOFS;
-	current->flags |= PF_MEMALLOC_NOFS;
+	unsigned int flags = sysiso_current->flags & PF_MEMALLOC_NOFS;
+	sysiso_current->flags |= PF_MEMALLOC_NOFS;
 	return flags;
 }
 
@@ -260,32 +260,32 @@ static inline unsigned int memalloc_nofs_save(void)
  */
 static inline void memalloc_nofs_restore(unsigned int flags)
 {
-	current->flags = (current->flags & ~PF_MEMALLOC_NOFS) | flags;
+	sysiso_current->flags = (sysiso_current->flags & ~PF_MEMALLOC_NOFS) | flags;
 }
 
 static inline unsigned int memalloc_noreclaim_save(void)
 {
-	unsigned int flags = current->flags & PF_MEMALLOC;
-	current->flags |= PF_MEMALLOC;
+	unsigned int flags = sysiso_current->flags & PF_MEMALLOC;
+	sysiso_current->flags |= PF_MEMALLOC;
 	return flags;
 }
 
 static inline void memalloc_noreclaim_restore(unsigned int flags)
 {
-	current->flags = (current->flags & ~PF_MEMALLOC) | flags;
+	sysiso_current->flags = (sysiso_current->flags & ~PF_MEMALLOC) | flags;
 }
 
 static inline unsigned int memalloc_pin_save(void)
 {
-	unsigned int flags = current->flags & PF_MEMALLOC_PIN;
+	unsigned int flags = sysiso_current->flags & PF_MEMALLOC_PIN;
 
-	current->flags |= PF_MEMALLOC_PIN;
+	sysiso_current->flags |= PF_MEMALLOC_PIN;
 	return flags;
 }
 
 static inline void memalloc_pin_restore(unsigned int flags)
 {
-	current->flags = (current->flags & ~PF_MEMALLOC_PIN) | flags;
+	sysiso_current->flags = (sysiso_current->flags & ~PF_MEMALLOC_PIN) | flags;
 }
 
 #ifdef CONFIG_MEMCG
diff --git a/include/linux/sched/signal.h b/include/linux/sched/signal.h
index e5f4ce622..070877497 100644
--- a/include/linux/sched/signal.h
+++ b/include/linux/sched/signal.h
@@ -278,7 +278,7 @@ extern int dequeue_signal(struct task_struct *task,
 
 static inline int kernel_dequeue_signal(void)
 {
-	struct task_struct *task = current;
+	struct task_struct *task = sysiso_current;
 	kernel_siginfo_t __info;
 	int ret;
 
@@ -291,10 +291,10 @@ static inline int kernel_dequeue_signal(void)
 
 static inline void kernel_signal_stop(void)
 {
-	spin_lock_irq(&current->sighand->siglock);
-	if (current->jobctl & JOBCTL_STOP_DEQUEUED)
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	if (sysiso_current->jobctl & JOBCTL_STOP_DEQUEUED)
 		set_special_state(TASK_STOPPED);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	schedule();
 }
@@ -347,7 +347,7 @@ extern int do_sigaction(int, struct k_sigaction *, struct k_sigaction *);
 
 static inline int restart_syscall(void)
 {
-	set_tsk_thread_flag(current, TIF_SIGPENDING);
+	set_tsk_thread_flag(sysiso_current, TIF_SIGPENDING);
 	return -ERESTARTNOINTR;
 }
 
@@ -398,8 +398,8 @@ static inline bool fault_signal_pending(vm_fault_t fault_flags,
 					struct pt_regs *regs)
 {
 	return unlikely((fault_flags & VM_FAULT_RETRY) &&
-			(fatal_signal_pending(current) ||
-			 (user_mode(regs) && signal_pending(current))));
+			(fatal_signal_pending(sysiso_current) ||
+			 (user_mode(regs) && signal_pending(sysiso_current))));
 }
 
 /*
@@ -474,7 +474,7 @@ static inline bool test_and_clear_restore_sigmask(void)
 /* Higher-quality implementation, used if TIF_RESTORE_SIGMASK doesn't exist. */
 static inline void set_restore_sigmask(void)
 {
-	current->restore_sigmask = true;
+	sysiso_current->restore_sigmask = true;
 }
 static inline void clear_tsk_restore_sigmask(struct task_struct *task)
 {
@@ -482,11 +482,11 @@ static inline void clear_tsk_restore_sigmask(struct task_struct *task)
 }
 static inline void clear_restore_sigmask(void)
 {
-	current->restore_sigmask = false;
+	sysiso_current->restore_sigmask = false;
 }
 static inline bool test_restore_sigmask(void)
 {
-	return current->restore_sigmask;
+	return sysiso_current->restore_sigmask;
 }
 static inline bool test_tsk_restore_sigmask(struct task_struct *task)
 {
@@ -494,9 +494,9 @@ static inline bool test_tsk_restore_sigmask(struct task_struct *task)
 }
 static inline bool test_and_clear_restore_sigmask(void)
 {
-	if (!current->restore_sigmask)
+	if (!sysiso_current->restore_sigmask)
 		return false;
-	current->restore_sigmask = false;
+	sysiso_current->restore_sigmask = false;
 	return true;
 }
 #endif
@@ -504,7 +504,7 @@ static inline bool test_and_clear_restore_sigmask(void)
 static inline void restore_saved_sigmask(void)
 {
 	if (test_and_clear_restore_sigmask())
-		__set_current_blocked(&current->saved_sigmask);
+		__set_current_blocked(&sysiso_current->saved_sigmask);
 }
 
 extern int set_user_sigmask(const sigset_t __user *umask, size_t sigsetsize);
@@ -512,16 +512,16 @@ extern int set_user_sigmask(const sigset_t __user *umask, size_t sigsetsize);
 static inline void restore_saved_sigmask_unless(bool interrupted)
 {
 	if (interrupted)
-		WARN_ON(!signal_pending(current));
+		WARN_ON(!signal_pending(sysiso_current));
 	else
 		restore_saved_sigmask();
 }
 
 static inline sigset_t *sigmask_to_save(void)
 {
-	sigset_t *res = &current->blocked;
+	sigset_t *res = &sysiso_current->blocked;
 	if (unlikely(test_restore_sigmask()))
-		res = &current->saved_sigmask;
+		res = &sysiso_current->saved_sigmask;
 	return res;
 }
 
@@ -537,11 +537,11 @@ static inline int kill_cad_pid(int sig, int priv)
 static inline int __on_sig_stack(unsigned long sp)
 {
 #ifdef CONFIG_STACK_GROWSUP
-	return sp >= current->sas_ss_sp &&
-		sp - current->sas_ss_sp < current->sas_ss_size;
+	return sp >= sysiso_current->sas_ss_sp &&
+		sp - sysiso_current->sas_ss_sp < sysiso_current->sas_ss_size;
 #else
-	return sp > current->sas_ss_sp &&
-		sp - current->sas_ss_sp <= current->sas_ss_size;
+	return sp > sysiso_current->sas_ss_sp &&
+		sp - sysiso_current->sas_ss_sp <= sysiso_current->sas_ss_size;
 #endif
 }
 
@@ -559,7 +559,7 @@ static inline int on_sig_stack(unsigned long sp)
 	 * the stack pointer points very close to the end of the signal stack,
 	 * then this check will enable the signal to be handled anyway.
 	 */
-	if (current->sas_ss_flags & SS_AUTODISARM)
+	if (sysiso_current->sas_ss_flags & SS_AUTODISARM)
 		return 0;
 
 	return __on_sig_stack(sp);
@@ -567,7 +567,7 @@ static inline int on_sig_stack(unsigned long sp)
 
 static inline int sas_ss_flags(unsigned long sp)
 {
-	if (!current->sas_ss_size)
+	if (!sysiso_current->sas_ss_size)
 		return SS_DISABLE;
 
 	return on_sig_stack(sp) ? SS_ONSTACK : 0;
@@ -584,9 +584,9 @@ static inline unsigned long sigsp(unsigned long sp, struct ksignal *ksig)
 {
 	if (unlikely((ksig->ka.sa.sa_flags & SA_ONSTACK)) && ! sas_ss_flags(sp))
 #ifdef CONFIG_STACK_GROWSUP
-		return current->sas_ss_sp;
+		return sysiso_current->sas_ss_sp;
 #else
-		return current->sas_ss_sp + current->sas_ss_size;
+		return sysiso_current->sas_ss_sp + sysiso_current->sas_ss_size;
 #endif
 	return sp;
 }
@@ -646,7 +646,7 @@ static inline struct pid *task_tgid(struct task_struct *task)
 
 /*
  * Without tasklist or RCU lock it is not safe to dereference
- * the result of task_pgrp/task_session even if task == current,
+ * the result of task_pgrp/task_session even if task == sysiso_current,
  * we can race with another thread doing sys_setsid/sys_setpgid.
  */
 static inline struct pid *task_pgrp(struct task_struct *task)
@@ -730,12 +730,12 @@ static inline unsigned long task_rlimit_max(const struct task_struct *task,
 
 static inline unsigned long rlimit(unsigned int limit)
 {
-	return task_rlimit(current, limit);
+	return task_rlimit(sysiso_current, limit);
 }
 
 static inline unsigned long rlimit_max(unsigned int limit)
 {
-	return task_rlimit_max(current, limit);
+	return task_rlimit_max(sysiso_current, limit);
 }
 
 #endif /* _LINUX_SCHED_SIGNAL_H */
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 3f96a6374..9a48dd48a 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -458,7 +458,7 @@ int __save_altstack(stack_t __user *, unsigned long);
 
 #define unsafe_save_altstack(uss, sp, label) do { \
 	stack_t __user *__uss = uss; \
-	struct task_struct *t = current; \
+	struct task_struct *t = sysiso_current; \
 	unsafe_put_user((void __user *)t->sas_ss_sp, &__uss->ss_sp, label); \
 	unsafe_put_user(t->sas_ss_flags, &__uss->ss_flags, label); \
 	unsafe_put_user(t->sas_ss_size, &__uss->ss_size, label); \
diff --git a/include/linux/sunrpc/types.h b/include/linux/sunrpc/types.h
index bd3c8e056..f9fdba4ea 100644
--- a/include/linux/sunrpc/types.h
+++ b/include/linux/sunrpc/types.h
@@ -19,6 +19,6 @@
 /*
  * Shorthands
  */
-#define signalled()		(signal_pending(current))
+#define signalled()		(signal_pending(sysiso_current))
 
 #endif /* _LINUX_SUNRPC_TYPES_H_ */
diff --git a/include/linux/swap.h b/include/linux/swap.h
index ba52f3a34..18a54fdb1 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -36,7 +36,7 @@ struct pagevec;
 
 static inline int current_is_kswapd(void)
 {
-	return current->flags & PF_KSWAPD;
+	return sysiso_current->flags & PF_KSWAPD;
 }
 
 /*
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 252243c77..f1958b6d2 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -1347,7 +1347,7 @@ static inline long ksys_truncate(const char __user *pathname, loff_t length)
 
 static inline unsigned int ksys_personality(unsigned int personality)
 {
-	unsigned int old = current->personality;
+	unsigned int old = sysiso_current->personality;
 
 	if (personality != 0xffffffff)
 		set_personality(personality);
@@ -1382,3 +1382,5 @@ int __sys_getsockopt(int fd, int level, int optname, char __user *optval,
 int __sys_setsockopt(int fd, int level, int optname, char __user *optval,
 		int optlen);
 #endif
+
+asmlinkage long sys_sysiso_test(int type);
diff --git a/include/linux/sysiso.h b/include/linux/sysiso.h
new file mode 100644
index 000000000..65054dc43
--- /dev/null
+++ b/include/linux/sysiso.h
@@ -0,0 +1,94 @@
+#ifndef __SYSISO_H__
+#define __SYSISO_H__
+
+#ifdef CONFIG_SYSISO
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+void sysiso_init(void);
+unsigned long sysiso_syscall_client(unsigned long nr, struct pt_regs *regs);
+int sysiso_client_enable_prctl(void);
+void sysiso_client_enable(struct task_struct *client);
+void sysiso_client_disable(struct task_struct * tsk);
+void sysiso_disable_tick(void);
+/*
+ * This is intentionally a macro and not a function. sysiso_server_schedule()
+ * saves the hardware state of the function that called schedule(). Probably we
+ * could use __always_inline instead. But for now let's not tempt GCC to play
+ * funny tricks.
+ */
+#define sysiso_current_is_server() (IS_ENABLED(CONFIG_SYSISO) &&	\
+				    test_tsk_thread_flag(current, TIF_SYSISO_SERVER))
+
+/* Don't trust gcc about asmlinkage! Hence, strictly NO arguments here */
+void sysiso_schedule(void);
+
+bool sysiso_cpumask_is_server(const struct cpumask *mask);
+bool sysiso_cpu_is_server(int cpu);
+void sysiso_pre_sched_init(void);
+
+bool sysiso_try_to_wake_up(struct task_struct *task);
+
+/* wait queues */
+void sysiso_init_wait_entry(struct wait_queue_entry *wq_entry);
+void sysiso__wake_up_common(struct wait_queue_entry *wq_entry);
+void sysiso_prepare_wait(struct wait_queue_entry *wq_entry);
+void sysiso__queue_work(struct work_struct *work);
+
+/* to avoid circular header dependencies with sched.h, this is also a macro */
+#define sysiso_current_is_client()					\
+	(IS_ENABLED(CONFIG_SYSISO) &&					\
+	 test_tsk_thread_flag(current, TIF_SYSISO_CLIENT))
+
+void sysiso_set_current_state(unsigned int state);
+void sysiso___set_current_state(unsigned int state);
+
+#define sysiso_task_is_client(task)					\
+	(IS_ENABLED(CONFIG_SYSISO) &&					\
+	 test_tsk_thread_flag(task, TIF_SYSISO_CLIENT))
+
+#define sysiso_task_is_server(task)					\
+	(IS_ENABLED(CONFIG_SYSISO) &&					\
+	 test_tsk_thread_flag(task, TIF_SYSISO_SERVER))
+
+struct hrtimer_sleeper *sysiso_get_hrtimer_sleeper(struct task_struct *client);
+void sysiso___hrtimer_init(void);
+void sysiso_hrtimer_wakeup(struct task_struct *client);
+
+/* struct sysisod_stackpointers { */
+/* 	unsigned long client; */
+/* 	unsigned long server; */
+/* }; */
+
+#else
+static inline void sysiso_init(void) { }
+static inline unsigned long sysiso_syscall_client(unsigned long nr, struct pt_regs *regs) { return 0; }
+static inline int sysiso_client_enable_prctl(void) { return -EINVAL; }
+static inline void sysiso_client_disable(struct task_struct * tsk) { }
+static inline bool sysiso_current_is_server(void) { return false; }
+static inline void sysiso_server_schedule(void) { }
+static inline bool sysiso_cpumask_is_server(const struct cpumask *mask) { return false; }
+static inline bool sysiso_cpu_is_server(int cpu) { return false; }
+static inline void sysiso_pre_sched_init(void) { }
+static inline void sysisod_schedule_asm(void) { }
+static inline bool sysiso_current_is_client(void) { return false; }
+static inline void sysiso_set_current_state(long state) { }
+static inline void sysiso_schedule(void) { }
+static inline bool sysiso_try_to_wake_up(struct task_struct *task) { return false; }
+static inline void sysiso_schedule_work(struct work_struct *work) { };
+static inline void sysiso_set_deferred_work_ctx(struct work_struct *work) { };
+static inline void sysiso_unset_deferred_work_ctx(struct work_struct *work) { };
+static inline void sysiso_init_wait_entry(struct wait_queue_entry *wq_entry) { };
+static inline void sysiso__wake_up_common(struct wait_queue_entry *wq_entry) { };
+static inline void sysiso_prepare_wait(struct wait_queue_entry *wq_entry) { };
+
+static inline void sysiso__queue_work(struct work_struct *work) { };
+
+static inline struct hrtimer_sleeper *sysiso_get_hrtimer_sleeper(struct task_struct *client) { return NULL; }
+static inline sysiso___hrtimer_init(void) { }
+static inline void sysiso_hrtimer_wakeup(struct task_struct *client) { }
+
+#endif /* CONFIG_SYSISO */
+
+#endif
diff --git a/include/linux/time_namespace.h b/include/linux/time_namespace.h
index 3146f1c05..b921134fe 100644
--- a/include/linux/time_namespace.h
+++ b/include/linux/time_namespace.h
@@ -64,28 +64,28 @@ int proc_timens_set_offset(struct file *file, struct task_struct *p,
 
 static inline void timens_add_monotonic(struct timespec64 *ts)
 {
-	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;
+	struct timens_offsets *ns_offsets = &sysiso_current->nsproxy->time_ns->offsets;
 
 	*ts = timespec64_add(*ts, ns_offsets->monotonic);
 }
 
 static inline void timens_add_boottime(struct timespec64 *ts)
 {
-	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;
+	struct timens_offsets *ns_offsets = &sysiso_current->nsproxy->time_ns->offsets;
 
 	*ts = timespec64_add(*ts, ns_offsets->boottime);
 }
 
 static inline u64 timens_add_boottime_ns(u64 nsec)
 {
-	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;
+	struct timens_offsets *ns_offsets = &sysiso_current->nsproxy->time_ns->offsets;
 
 	return nsec + timespec64_to_ns(&ns_offsets->boottime);
 }
 
 static inline void timens_sub_boottime(struct timespec64 *ts)
 {
-	struct timens_offsets *ns_offsets = &current->nsproxy->time_ns->offsets;
+	struct timens_offsets *ns_offsets = &sysiso_current->nsproxy->time_ns->offsets;
 
 	*ts = timespec64_sub(*ts, ns_offsets->boottime);
 }
@@ -95,7 +95,7 @@ ktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,
 
 static inline ktime_t timens_ktime_to_host(clockid_t clockid, ktime_t tim)
 {
-	struct time_namespace *ns = current->nsproxy->time_ns;
+	struct time_namespace *ns = sysiso_current->nsproxy->time_ns;
 
 	if (likely(ns == &init_time_ns))
 		return tim;
diff --git a/include/linux/tracehook.h b/include/linux/tracehook.h
index 2564b7434..4c499508b 100644
--- a/include/linux/tracehook.h
+++ b/include/linux/tracehook.h
@@ -76,7 +76,7 @@ static inline int ptrace_report_syscall(struct pt_regs *regs,
 	}
 
 	current->ptrace_message = 0;
-	return fatal_signal_pending(current);
+	return fatal_signal_pending(sysiso_current);
 }
 
 /**
@@ -185,7 +185,7 @@ static inline void tracehook_notify_resume(struct pt_regs *regs)
 	 * hlist_add_head(task->task_works);
 	 */
 	smp_mb__after_atomic();
-	if (unlikely(current->task_works))
+	if (unlikely(sysiso_current->task_works))
 		task_work_run();
 
 #ifdef CONFIG_KEYS_REQUEST_CACHE
@@ -210,7 +210,7 @@ static inline void tracehook_notify_signal(void)
 {
 	clear_thread_flag(TIF_NOTIFY_SIGNAL);
 	smp_mb__after_atomic();
-	if (current->task_works)
+	if (sysiso_current->task_works)
 		task_work_run();
 }
 
diff --git a/include/linux/utsname.h b/include/linux/utsname.h
index 2b1737c9b..3d99feb01 100644
--- a/include/linux/utsname.h
+++ b/include/linux/utsname.h
@@ -78,7 +78,7 @@ static inline void uts_proc_notify(enum uts_proc proc)
 
 static inline struct new_utsname *utsname(void)
 {
-	return &current->nsproxy->uts_ns->name;
+	return &sysiso_current->nsproxy->uts_ns->name;
 }
 
 static inline struct new_utsname *init_utsname(void)
diff --git a/include/linux/vtime.h b/include/linux/vtime.h
index 3684487d0..79707c7ce 100644
--- a/include/linux/vtime.h
+++ b/include/linux/vtime.h
@@ -55,13 +55,13 @@ extern void vtime_task_switch(struct task_struct *prev);
 static __always_inline void vtime_account_guest_enter(void)
 {
 	vtime_account_kernel(current);
-	current->flags |= PF_VCPU;
+	sysiso_current->flags |= PF_VCPU;
 }
 
 static __always_inline void vtime_account_guest_exit(void)
 {
 	vtime_account_kernel(current);
-	current->flags &= ~PF_VCPU;
+	sysiso_current->flags &= ~PF_VCPU;
 }
 
 #elif defined(CONFIG_VIRT_CPU_ACCOUNTING_GEN)
@@ -100,7 +100,7 @@ static __always_inline void vtime_account_guest_enter(void)
 	if (vtime_accounting_enabled_this_cpu())
 		vtime_guest_enter(current);
 	else
-		current->flags |= PF_VCPU;
+		sysiso_current->flags |= PF_VCPU;
 }
 
 static __always_inline void vtime_account_guest_exit(void)
@@ -108,7 +108,7 @@ static __always_inline void vtime_account_guest_exit(void)
 	if (vtime_accounting_enabled_this_cpu())
 		vtime_guest_exit(current);
 	else
-		current->flags &= ~PF_VCPU;
+		sysiso_current->flags &= ~PF_VCPU;
 }
 
 #else /* !CONFIG_VIRT_CPU_ACCOUNTING */
@@ -118,12 +118,12 @@ static inline void vtime_task_switch(struct task_struct *prev) { }
 
 static __always_inline void vtime_account_guest_enter(void)
 {
-	current->flags |= PF_VCPU;
+	sysiso_current->flags |= PF_VCPU;
 }
 
 static __always_inline void vtime_account_guest_exit(void)
 {
-	current->flags &= ~PF_VCPU;
+	sysiso_current->flags &= ~PF_VCPU;
 }
 
 #endif
diff --git a/include/linux/wait.h b/include/linux/wait.h
index 93dab0e95..26378e4d4 100644
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@ -31,6 +31,9 @@ struct wait_queue_entry {
 	unsigned int		flags;
 	void			*private;
 	wait_queue_func_t	func;
+#ifdef CONFIG_SYSISO
+	struct sysiso_task	*sysiso_task;
+#endif
 	struct list_head	entry;
 };
 
@@ -46,10 +49,18 @@ struct task_struct;
  * Macros for declaration and initialisaton of the datatypes
  */
 
+#ifndef CONFIG_SYSISO
 #define __WAITQUEUE_INITIALIZER(name, tsk) {					\
 	.private	= tsk,							\
 	.func		= default_wake_function,				\
 	.entry		= { NULL, NULL } }
+#else
+#define __WAITQUEUE_INITIALIZER(name, tsk) {					\
+	.private	= tsk,							\
+	.func		= default_wake_function,				\
+	.sysiso_task	= NULL,							\
+	.entry		= { NULL, NULL } }
+#endif
 
 #define DECLARE_WAITQUEUE(name, tsk)						\
 	struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)
@@ -83,6 +94,9 @@ static inline void init_waitqueue_entry(struct wait_queue_entry *wq_entry, struc
 {
 	wq_entry->flags		= 0;
 	wq_entry->private	= p;
+#ifdef CONFIG_SYSISO
+	wq_entry->sysiso_task   = NULL;
+#endif
 	wq_entry->func		= default_wake_function;
 }
 
@@ -91,6 +105,9 @@ init_waitqueue_func_entry(struct wait_queue_entry *wq_entry, wait_queue_func_t f
 {
 	wq_entry->flags		= 0;
 	wq_entry->private	= NULL;
+#ifdef CONFIG_SYSISO
+	wq_entry->sysiso_task   = NULL;
+#endif
 	wq_entry->func		= func;
 }
 
@@ -520,7 +537,7 @@ do {										\
 				      HRTIMER_MODE_REL);			\
 	if ((timeout) != KTIME_MAX)						\
 		hrtimer_start_range_ns(&__t.timer, timeout,			\
-				       current->timer_slack_ns,			\
+				       sysiso_current->timer_slack_ns,			\
 				       HRTIMER_MODE_REL);			\
 										\
 	__ret = ___wait_event(wq_head, condition, state, 0, 0,			\
@@ -1143,15 +1160,26 @@ long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout);
 int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
 int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
 
+#ifndef CONFIG_SYSISO
 #define DEFINE_WAIT_FUNC(name, function)					\
 	struct wait_queue_entry name = {					\
 		.private	= current,					\
 		.func		= function,					\
 		.entry		= LIST_HEAD_INIT((name).entry),			\
 	}
+#else
+#define DEFINE_WAIT_FUNC(name, function)					\
+	struct wait_queue_entry name = {					\
+		.private	= current,					\
+		.func		= function,					\
+		.sysiso_task	= NULL,						\
+		.entry		= LIST_HEAD_INIT((name).entry),			\
+	}
+#endif
 
 #define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)
 
+#ifndef CONFIG_SYSISO
 #define init_wait(wait)								\
 	do {									\
 		(wait)->private = current;					\
@@ -1159,7 +1187,16 @@ int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, i
 		INIT_LIST_HEAD(&(wait)->entry);					\
 		(wait)->flags = 0;						\
 	} while (0)
-
+#else
+#define init_wait(wait)								\
+	do {									\
+		(wait)->private = current;					\
+		(wait)->func = autoremove_wake_function;			\
+		INIT_LIST_HEAD(&(wait)->entry);					\
+		(wait)->sysiso_task = NULL;					\
+		(wait)->flags = 0;						\
+	} while (0)
+#endif
 bool try_invoke_on_locked_down_task(struct task_struct *p, bool (*func)(struct task_struct *t, void *arg), void *arg);
 
 #endif /* _LINUX_WAIT_H */
diff --git a/include/linux/wait_bit.h b/include/linux/wait_bit.h
index 7dec36aec..d5e5bbbcd 100644
--- a/include/linux/wait_bit.h
+++ b/include/linux/wait_bit.h
@@ -35,6 +35,7 @@ extern void __init wait_bit_init(void);
 
 int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key);
 
+#ifndef CONFIG_SYSISO
 #define DEFINE_WAIT_BIT(name, word, bit)					\
 	struct wait_bit_queue_entry name = {					\
 		.key = __WAIT_BIT_KEY_INITIALIZER(word, bit),			\
@@ -45,6 +46,19 @@ int wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync
 				LIST_HEAD_INIT((name).wq_entry.entry),		\
 		},								\
 	}
+#else
+#define DEFINE_WAIT_BIT(name, word, bit)					\
+	struct wait_bit_queue_entry name = {					\
+		.key = __WAIT_BIT_KEY_INITIALIZER(word, bit),			\
+		.wq_entry = {							\
+			.private	= current,				\
+			.func		= wake_bit_function,			\
+			.sysiso_task	= NULL,					\
+			.entry		=					\
+				LIST_HEAD_INIT((name).wq_entry.entry),		\
+		},								\
+	}
+#endif
 
 extern int bit_wait(struct wait_bit_key *key, int mode);
 extern int bit_wait_io(struct wait_bit_key *key, int mode);
diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h
index 74d3c1efd..7d1df61d2 100644
--- a/include/linux/workqueue.h
+++ b/include/linux/workqueue.h
@@ -21,6 +21,10 @@ struct work_struct;
 typedef void (*work_func_t)(struct work_struct *work);
 void delayed_work_timer_fn(struct timer_list *t);
 
+#ifdef CONFIG_SYSISO
+void sysiso_schedule_work(struct work_struct *work);
+#endif
+
 /*
  * The first word is the work queue pointer and the flags rolled into
  * one
@@ -94,6 +98,8 @@ enum {
 	WORKER_DESC_LEN		= 24,
 };
 
+struct sysiso_task;
+
 struct work_struct {
 	atomic_long_t data;
 	struct list_head entry;
@@ -101,6 +107,9 @@ struct work_struct {
 #ifdef CONFIG_LOCKDEP
 	struct lockdep_map lockdep_map;
 #endif
+#ifdef CONFIG_SYSISO
+	struct sysiso_task *sysiso_task;
+#endif
 };
 
 #define WORK_DATA_INIT()	ATOMIC_LONG_INIT((unsigned long)WORK_STRUCT_NO_POOL)
@@ -220,6 +229,7 @@ static inline unsigned int work_static(struct work_struct *work) { return 0; }
  * assignment of the work data initializer allows the compiler
  * to generate better code.
  */
+#ifndef CONFIG_SYSISO
 #ifdef CONFIG_LOCKDEP
 #define __INIT_WORK(_work, _func, _onstack)				\
 	do {								\
@@ -241,6 +251,33 @@ static inline unsigned int work_static(struct work_struct *work) { return 0; }
 	} while (0)
 #endif
 
+#else  /* CONFIG_SYSISO */
+
+#ifdef CONFIG_LOCKDEP
+#define __INIT_WORK(_work, _func, _onstack)				\
+	do {								\
+		static struct lock_class_key __key;			\
+									\
+		__init_work((_work), _onstack);				\
+		(_work)->data = (atomic_long_t) WORK_DATA_INIT();	\
+		lockdep_init_map(&(_work)->lockdep_map, "(work_completion)"#_work, &__key, 0); \
+		INIT_LIST_HEAD(&(_work)->entry);			\
+		(_work)->func = (_func);				\
+		(_work)->sysiso_task = NULL;				\
+	} while (0)
+#else
+#define __INIT_WORK(_work, _func, _onstack)				\
+	do {								\
+		__init_work((_work), _onstack);				\
+		(_work)->data = (atomic_long_t) WORK_DATA_INIT();	\
+		INIT_LIST_HEAD(&(_work)->entry);			\
+		(_work)->func = (_func);				\
+		(_work)->sysiso_task = NULL;				\
+	} while (0)
+#endif
+#endif	/* CONFIG_SYSISO */
+
+
 #define INIT_WORK(_work, _func)						\
 	__INIT_WORK((_work), (_func), 0)
 
diff --git a/include/net/busy_poll.h b/include/net/busy_poll.h
index 40296ed97..afab87c2a 100644
--- a/include/net/busy_poll.h
+++ b/include/net/busy_poll.h
@@ -38,7 +38,7 @@ static inline bool net_busy_loop_on(void)
 
 static inline bool sk_can_busy_loop(const struct sock *sk)
 {
-	return READ_ONCE(sk->sk_ll_usec) && !signal_pending(current);
+	return READ_ONCE(sk->sk_ll_usec) && !signal_pending(sysiso_current);
 }
 
 bool sk_busy_loop_end(void *p, unsigned long start_time);
diff --git a/include/trace/events/block.h b/include/trace/events/block.h
index cc5ab96a7..1ee18c465 100644
--- a/include/trace/events/block.h
+++ b/include/trace/events/block.h
@@ -168,7 +168,7 @@ DECLARE_EVENT_CLASS(block_rq,
 
 		blk_fill_rwbs(__entry->rwbs, rq->cmd_flags);
 		__get_str(cmd)[0] = '\0';
-		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
+		memcpy(__entry->comm, sysiso_current->comm, TASK_COMM_LEN);
 	),
 
 	TP_printk("%d,%d %s %u (%s) %llu + %u [%s]",
@@ -277,7 +277,7 @@ DECLARE_EVENT_CLASS(block_bio,
 		__entry->sector		= bio->bi_iter.bi_sector;
 		__entry->nr_sector	= bio_sectors(bio);
 		blk_fill_rwbs(__entry->rwbs, bio->bi_opf);
-		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
+		memcpy(__entry->comm, sysiso_current->comm, TASK_COMM_LEN);
 	),
 
 	TP_printk("%d,%d %s %llu + %u [%s]",
@@ -364,7 +364,7 @@ TRACE_EVENT(block_plug,
 	),
 
 	TP_fast_assign(
-		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
+		memcpy(__entry->comm, sysiso_current->comm, TASK_COMM_LEN);
 	),
 
 	TP_printk("[%s]", __entry->comm)
@@ -383,7 +383,7 @@ DECLARE_EVENT_CLASS(block_unplug,
 
 	TP_fast_assign(
 		__entry->nr_rq = depth;
-		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
+		memcpy(__entry->comm, sysiso_current->comm, TASK_COMM_LEN);
 	),
 
 	TP_printk("[%s] %d", __entry->comm, __entry->nr_rq)
@@ -434,7 +434,7 @@ TRACE_EVENT(block_split,
 		__entry->sector		= bio->bi_iter.bi_sector;
 		__entry->new_sector	= new_sector;
 		blk_fill_rwbs(__entry->rwbs, bio->bi_opf);
-		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
+		memcpy(__entry->comm, sysiso_current->comm, TASK_COMM_LEN);
 	),
 
 	TP_printk("%d,%d %s %llu / %llu [%s]",
diff --git a/include/trace/events/sched.h b/include/trace/events/sched.h
index 94640482c..f020f310d 100644
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@ -354,7 +354,7 @@ TRACE_EVENT(sched_process_wait,
 	),
 
 	TP_fast_assign(
-		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
+		memcpy(__entry->comm, sysiso_current->comm, TASK_COMM_LEN);
 		__entry->pid		= pid_nr(pid);
 		__entry->prio		= current->prio; /* XXX SCHED_DEADLINE */
 	),
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 1c5fb86d4..9f33cd055 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -880,8 +880,13 @@ __SYSCALL(__NR_memfd_secret, sys_memfd_secret)
 #define __NR_process_mrelease 448
 __SYSCALL(__NR_process_mrelease, sys_process_mrelease)
 
+#ifdef CONFIG_SYSISO
+#define __NR_sysiso_test  449
+__SYSCALL(__NR_sysiso_test, sys_sysiso_test)
+#endif
+
 #undef __NR_syscalls
-#define __NR_syscalls 449
+#define __NR_syscalls 450
 
 /*
  * 32 bit systems traditionally used different
diff --git a/include/uapi/linux/prctl.h b/include/uapi/linux/prctl.h
index 43bd7f713..ada6d9ba0 100644
--- a/include/uapi/linux/prctl.h
+++ b/include/uapi/linux/prctl.h
@@ -269,4 +269,7 @@ struct prctl_mm_map {
 # define PR_SCHED_CORE_SHARE_FROM	3 /* pull core_sched cookie to pid */
 # define PR_SCHED_CORE_MAX		4
 
+#define PR_SET_SYSISO                  63
+#define PR_GET_SYSISO                  64
+
 #endif /* _LINUX_PRCTL_H */
diff --git a/init/do_mounts.c b/init/do_mounts.c
index 762b53497..80b981b15 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -378,7 +378,7 @@ static int __init do_mount_root(const char *name, const char *fs,
 		goto out;
 
 	init_chdir("/root");
-	s = current->fs->pwd.dentry->d_sb;
+	s = sysiso_current->fs->pwd.dentry->d_sb;
 	ROOT_DEV = s->s_dev;
 	printk(KERN_INFO
 	       "VFS: Mounted root (%s filesystem)%s on device %u:%u.\n",
diff --git a/init/do_mounts_initrd.c b/init/do_mounts_initrd.c
index 533d81ed7..9f4935f82 100644
--- a/init/do_mounts_initrd.c
+++ b/init/do_mounts_initrd.c
@@ -83,7 +83,7 @@ static void __init handle_initrd(void)
 	 * In case that a resume from disk is carried out by linuxrc or one of
 	 * its children, we need to tell the freezer not to wait for us.
 	 */
-	current->flags |= PF_FREEZER_SKIP;
+	sysiso_current->flags |= PF_FREEZER_SKIP;
 
 	info = call_usermodehelper_setup("/linuxrc", argv, envp_init,
 					 GFP_KERNEL, init_linuxrc, NULL, NULL);
@@ -91,7 +91,7 @@ static void __init handle_initrd(void)
 		return;
 	call_usermodehelper_exec(info, UMH_WAIT_PROC);
 
-	current->flags &= ~PF_FREEZER_SKIP;
+	sysiso_current->flags &= ~PF_FREEZER_SKIP;
 
 	/* move initrd to rootfs' /old */
 	init_mount("..", ".", NULL, MS_MOVE, NULL);
diff --git a/init/main.c b/init/main.c
index 3c4054a95..2761807dd 100644
--- a/init/main.c
+++ b/init/main.c
@@ -112,6 +112,8 @@
 
 #include <kunit/test.h>
 
+#include <linux/sysiso.h>
+
 static int kernel_init(void *);
 
 extern void init_IRQ(void);
@@ -993,6 +995,9 @@ asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
 	/* trace_printk can be enabled here */
 	early_trace_init();
 
+	/* Must happen before the scheduler is running */
+	sysiso_pre_sched_init();
+
 	/*
 	 * Set up the scheduler prior starting any interrupts (such as the
 	 * timer interrupt). Full topology setup happens at smp_init()
@@ -1243,7 +1248,8 @@ trace_initcall_start_cb(void *data, initcall_t fn)
 {
 	ktime_t *calltime = (ktime_t *)data;
 
-	printk(KERN_DEBUG "calling  %pS @ %i\n", fn, task_pid_nr(current));
+	printk(KERN_DEBUG "calling  %pS @ %i\n", fn,
+	       task_pid_nr(sysiso_current));
 	*calltime = ktime_get();
 }
 
@@ -1513,6 +1519,8 @@ static int __ref kernel_init(void *unused)
 	free_initmem();
 	mark_readonly();
 
+	sysiso_init();
+
 	/*
 	 * Kernel mappings are now finalized - update the userspace page-table
 	 * to finalize PTI.
@@ -1592,7 +1600,7 @@ static noinline void __init kernel_init_freeable(void)
 	 */
 	set_mems_allowed(node_states[N_MEMORY]);
 
-	cad_pid = get_pid(task_pid(current));
+	cad_pid = get_pid(task_pid(sysiso_current));
 
 	smp_prepare_cpus(setup_max_cpus);
 
diff --git a/ipc/ipc_sysctl.c b/ipc/ipc_sysctl.c
index 3f312bf2b..be5ac3184 100644
--- a/ipc/ipc_sysctl.c
+++ b/ipc/ipc_sysctl.c
@@ -17,7 +17,7 @@
 static void *get_ipc(struct ctl_table *table)
 {
 	char *which = table->data;
-	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
+	struct ipc_namespace *ipc_ns = sysiso_current->nsproxy->ipc_ns;
 	which = (which - (char *)&init_ipc_ns) + (char *)ipc_ns;
 	return which;
 }
@@ -48,7 +48,7 @@ static int proc_ipc_dointvec_minmax(struct ctl_table *table, int write,
 static int proc_ipc_dointvec_minmax_orphans(struct ctl_table *table, int write,
 		void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct ipc_namespace *ns = current->nsproxy->ipc_ns;
+	struct ipc_namespace *ns = sysiso_current->nsproxy->ipc_ns;
 	int err = proc_ipc_dointvec_minmax(table, write, buffer, lenp, ppos);
 
 	if (err < 0)
@@ -88,13 +88,13 @@ static int proc_ipc_sem_dointvec(struct ctl_table *table, int write,
 	void *buffer, size_t *lenp, loff_t *ppos)
 {
 	int ret, semmni;
-	struct ipc_namespace *ns = current->nsproxy->ipc_ns;
+	struct ipc_namespace *ns = sysiso_current->nsproxy->ipc_ns;
 
 	semmni = ns->sem_ctls[3];
 	ret = proc_ipc_dointvec(table, write, buffer, lenp, ppos);
 
 	if (!ret)
-		ret = sem_check_semmni(current->nsproxy->ipc_ns);
+		ret = sem_check_semmni(sysiso_current->nsproxy->ipc_ns);
 
 	/*
 	 * Reset the semmni value if an error happens.
diff --git a/ipc/mq_sysctl.c b/ipc/mq_sysctl.c
index 72a92a08c..b6db879ec 100644
--- a/ipc/mq_sysctl.c
+++ b/ipc/mq_sysctl.c
@@ -13,7 +13,7 @@
 static void *get_mq(struct ctl_table *table)
 {
 	char *which = table->data;
-	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
+	struct ipc_namespace *ipc_ns = sysiso_current->nsproxy->ipc_ns;
 	which = (which - (char *)&init_ipc_ns) + (char *)ipc_ns;
 	return which;
 }
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index 5becca9be..3182f18b9 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -446,7 +446,7 @@ static int mqueue_init_fs_context(struct fs_context *fc)
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->ipc_ns = get_ipc_ns(current->nsproxy->ipc_ns);
+	ctx->ipc_ns = get_ipc_ns(sysiso_current->nsproxy->ipc_ns);
 	put_user_ns(fc->user_ns);
 	fc->user_ns = get_user_ns(ctx->ipc_ns->user_ns);
 	fc->fs_private = ctx;
@@ -728,7 +728,7 @@ static int wq_sleep(struct mqueue_inode_info *info, int sr,
 			retval = 0;
 			goto out_unlock;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			retval = -ERESTARTSYS;
 			break;
 		}
@@ -881,7 +881,7 @@ static int prepare_open(struct dentry *dentry, int oflag, int ro,
 static int do_mq_open(const char __user *u_name, int oflag, umode_t mode,
 		      struct mq_attr *attr)
 {
-	struct vfsmount *mnt = current->nsproxy->ipc_ns->mq_mnt;
+	struct vfsmount *mnt = sysiso_current->nsproxy->ipc_ns->mq_mnt;
 	struct dentry *root = mnt->mnt_root;
 	struct filename *name;
 	struct path path;
diff --git a/ipc/msg.c b/ipc/msg.c
index a0d05775a..c5740ed72 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -303,7 +303,7 @@ long ksys_msgget(key_t key, int msgflg)
 	};
 	struct ipc_params msg_params;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	msg_params.key = key;
 	msg_params.flg = msgflg;
@@ -597,7 +597,7 @@ static long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf, int ver
 	if (msqid < 0 || cmd < 0)
 		return -EINVAL;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	switch (cmd) {
 	case IPC_INFO:
@@ -729,7 +729,7 @@ static long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr, int versio
 	int err;
 	struct msqid64_ds msqid64;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	if (msqid < 0 || cmd < 0)
 		return -EINVAL;
@@ -848,7 +848,7 @@ static long do_msgsnd(int msqid, long mtype, void __user *mtext,
 	struct ipc_namespace *ns;
 	DEFINE_WAKE_Q(wake_q);
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	if (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0)
 		return -EINVAL;
@@ -920,7 +920,7 @@ static long do_msgsnd(int msqid, long mtype, void __user *mtext,
 		}
 		ss_del(&s);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTNOHAND;
 			goto out_unlock0;
 		}
@@ -1098,7 +1098,7 @@ static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, in
 	struct msg_msg *msg, *copy = NULL;
 	DEFINE_WAKE_Q(wake_q);
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	if (msqid < 0 || (long) bufsz < 0)
 		return -EINVAL;
@@ -1231,7 +1231,7 @@ static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, in
 			goto out_unlock0;
 
 		list_del(&msr_d.r_list);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			msg = ERR_PTR(-ERESTARTNOHAND);
 			goto out_unlock0;
 		}
diff --git a/ipc/sem.c b/ipc/sem.c
index 6693daf4f..9783a2eae 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -609,7 +609,7 @@ long ksys_semget(key_t key, int nsems, int semflg)
 	};
 	struct ipc_params sem_params;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	if (nsems < 0 || nsems > ns->sc_semmsl)
 		return -EINVAL;
@@ -1084,7 +1084,7 @@ static int check_qop(struct sem_array *sma, int semnum, struct sem_queue *q,
 	 */
 	pr_info_once("semctl(GETNCNT/GETZCNT) is since 3.16 Single Unix Specification compliant.\n"
 			"The task %s (%d) triggered the difference, watch for misbehavior.\n",
-			current->comm, task_pid_nr(current));
+			sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	if (sop->sem_num != semnum)
 		return 0;
@@ -1660,7 +1660,7 @@ static long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg, int v
 	if (semid < 0)
 		return -EINVAL;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	switch (cmd) {
 	case IPC_INFO:
@@ -1780,7 +1780,7 @@ static long compat_ksys_semctl(int semid, int semnum, int cmd, int arg, int vers
 	struct semid64_ds semid64;
 	int err;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	if (semid < 0)
 		return -EINVAL;
@@ -1853,7 +1853,7 @@ static inline int get_undo_list(struct sem_undo_list **undo_listp)
 {
 	struct sem_undo_list *undo_list;
 
-	undo_list = current->sysvsem.undo_list;
+	undo_list = sysiso_current->sysvsem.undo_list;
 	if (!undo_list) {
 		undo_list = kzalloc(sizeof(*undo_list), GFP_KERNEL_ACCOUNT);
 		if (undo_list == NULL)
@@ -1862,7 +1862,7 @@ static inline int get_undo_list(struct sem_undo_list **undo_listp)
 		refcount_set(&undo_list->refcnt, 1);
 		INIT_LIST_HEAD(&undo_list->list_proc);
 
-		current->sysvsem.undo_list = undo_list;
+		sysiso_current->sysvsem.undo_list = undo_list;
 	}
 	*undo_listp = undo_list;
 	return 0;
@@ -2212,7 +2212,7 @@ long __do_semtimedop(int semid, struct sembuf *sops,
 		 */
 		if (timeout && jiffies_left == 0)
 			error = -EAGAIN;
-	} while (error == -EINTR && !signal_pending(current)); /* spurious */
+	} while (error == -EINTR && !signal_pending(sysiso_current)); /* spurious */
 
 	unlink_queue(sma, &queue);
 
@@ -2231,7 +2231,7 @@ static long do_semtimedop(int semid, struct sembuf __user *tsops,
 	struct ipc_namespace *ns;
 	int ret;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 	if (nsops > ns->sc_semopm)
 		return -E2BIG;
 	if (nsops < 1)
diff --git a/ipc/shm.c b/ipc/shm.c
index ab749be6d..6135ea9d9 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -680,7 +680,7 @@ static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 	if (error < 0)
 		goto no_id;
 
-	list_add(&shp->shm_clist, &current->sysvshm.shm_clist);
+	list_add(&shp->shm_clist, &sysiso_current->sysvshm.shm_clist);
 
 	/*
 	 * shmid gets reported as "inode#" in /proc/pid/maps.
@@ -732,7 +732,7 @@ long ksys_shmget(key_t key, size_t size, int shmflg)
 	};
 	struct ipc_params shm_params;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	shm_params.key = key;
 	shm_params.flg = shmflg;
@@ -1145,7 +1145,7 @@ static long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf, int ver
 	if (cmd < 0 || shmid < 0)
 		return -EINVAL;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	switch (cmd) {
 	case IPC_INFO: {
@@ -1337,7 +1337,7 @@ static long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr, int versio
 	struct shmid64_ds sem64;
 	int err;
 
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 
 	if (cmd < 0 || shmid < 0)
 		return -EINVAL;
@@ -1474,7 +1474,7 @@ long do_shmat(int shmid, char __user *shmaddr, int shmflg,
 	 * We cannot rely on the fs check since SYSV IPC does have an
 	 * additional creator id...
 	 */
-	ns = current->nsproxy->ipc_ns;
+	ns = sysiso_current->nsproxy->ipc_ns;
 	rcu_read_lock();
 	shp = shm_obtain_object_check(ns, shmid);
 	if (IS_ERR(shp)) {
diff --git a/ipc/util.c b/ipc/util.c
index d48d8cfa1..f4e8ce0cb 100644
--- a/ipc/util.c
+++ b/ipc/util.c
@@ -895,8 +895,8 @@ static int sysvipc_proc_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	iter->iface = PDE_DATA(inode);
-	iter->ns    = get_ipc_ns(current->nsproxy->ipc_ns);
-	iter->pid_ns = get_pid_ns(task_active_pid_ns(current));
+	iter->ns    = get_ipc_ns(sysiso_current->nsproxy->ipc_ns);
+	iter->pid_ns = get_pid_ns(task_active_pid_ns(sysiso_current));
 
 	return 0;
 }
diff --git a/kernel/acct.c b/kernel/acct.c
index 23a7ab8e6..fb9d7c5d6 100644
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@ -194,7 +194,7 @@ static int acct_on(struct filename *pathname)
 {
 	struct file *file;
 	struct vfsmount *mnt, *internal;
-	struct pid_namespace *ns = task_active_pid_ns(current);
+	struct pid_namespace *ns = task_active_pid_ns(sysiso_current);
 	struct bsd_acct_struct *acct;
 	struct fs_pin *old;
 	int err;
@@ -412,7 +412,7 @@ static u32 encode_float(u64 value)
 
 static void fill_ac(acct_t *ac)
 {
-	struct pacct_struct *pacct = &current->signal->pacct;
+	struct pacct_struct *pacct = &sysiso_current->signal->pacct;
 	u64 elapsed, run_time;
 	time64_t btime;
 	struct tty_struct *tty;
@@ -424,11 +424,11 @@ static void fill_ac(acct_t *ac)
 	memset(ac, 0, sizeof(acct_t));
 
 	ac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;
-	strlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));
+	strlcpy(ac->ac_comm, sysiso_current->comm, sizeof(ac->ac_comm));
 
 	/* calculate run_time in nsec*/
 	run_time = ktime_get_ns();
-	run_time -= current->group_leader->start_time;
+	run_time -= sysiso_current->group_leader->start_time;
 	/* convert nsec -> AHZ */
 	elapsed = nsec_to_AHZ(run_time);
 #if ACCT_VERSION == 3
@@ -453,8 +453,8 @@ static void fill_ac(acct_t *ac)
 	ac->ac_ahz = AHZ;
 #endif
 
-	spin_lock_irq(&current->sighand->siglock);
-	tty = current->signal->tty;	/* Safe as we hold the siglock */
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	tty = sysiso_current->signal->tty;	/* Safe as we hold the siglock */
 	ac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;
 	ac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));
 	ac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));
@@ -463,7 +463,7 @@ static void fill_ac(acct_t *ac)
 	ac->ac_minflt = encode_comp_t(pacct->ac_minflt);
 	ac->ac_majflt = encode_comp_t(pacct->ac_majflt);
 	ac->ac_exitcode = pacct->ac_exitcode;
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 /*
  *  do_acct_process does all actual work. Caller holds the reference to file.
@@ -479,7 +479,7 @@ static void do_acct_process(struct bsd_acct_struct *acct)
 	 * Accounting records are not subject to resource limits.
 	 */
 	flim = rlimit(RLIMIT_FSIZE);
-	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
+	sysiso_current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
 	/* Perform file operations on behalf of whoever enabled accounting */
 	orig_cred = override_creds(file->f_cred);
 
@@ -502,9 +502,9 @@ static void do_acct_process(struct bsd_acct_struct *acct)
 	{
 		struct pid_namespace *ns = acct->ns;
 
-		ac.ac_pid = task_tgid_nr_ns(current, ns);
+		ac.ac_pid = task_tgid_nr_ns(sysiso_current, ns);
 		rcu_read_lock();
-		ac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),
+		ac.ac_ppid = task_tgid_nr_ns(rcu_dereference(sysiso_current->real_parent),
 					     ns);
 		rcu_read_unlock();
 	}
@@ -520,7 +520,7 @@ static void do_acct_process(struct bsd_acct_struct *acct)
 		file_end_write(file);
 	}
 out:
-	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
+	sysiso_current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
 	revert_creds(orig_cred);
 }
 
@@ -531,7 +531,7 @@ static void do_acct_process(struct bsd_acct_struct *acct)
  */
 void acct_collect(long exitcode, int group_dead)
 {
-	struct pacct_struct *pacct = &current->signal->pacct;
+	struct pacct_struct *pacct = &sysiso_current->signal->pacct;
 	u64 utime, stime;
 	unsigned long vsize = 0;
 
@@ -547,27 +547,27 @@ void acct_collect(long exitcode, int group_dead)
 		mmap_read_unlock(current->mm);
 	}
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	if (group_dead)
 		pacct->ac_mem = vsize / 1024;
 	if (thread_group_leader(current)) {
 		pacct->ac_exitcode = exitcode;
-		if (current->flags & PF_FORKNOEXEC)
+		if (sysiso_current->flags & PF_FORKNOEXEC)
 			pacct->ac_flag |= AFORK;
 	}
-	if (current->flags & PF_SUPERPRIV)
+	if (sysiso_current->flags & PF_SUPERPRIV)
 		pacct->ac_flag |= ASU;
-	if (current->flags & PF_DUMPCORE)
+	if (sysiso_current->flags & PF_DUMPCORE)
 		pacct->ac_flag |= ACORE;
-	if (current->flags & PF_SIGNALED)
+	if (sysiso_current->flags & PF_SIGNALED)
 		pacct->ac_flag |= AXSIG;
 
 	task_cputime(current, &utime, &stime);
 	pacct->ac_utime += utime;
 	pacct->ac_stime += stime;
-	pacct->ac_minflt += current->min_flt;
-	pacct->ac_majflt += current->maj_flt;
-	spin_unlock_irq(&current->sighand->siglock);
+	pacct->ac_minflt += sysiso_current->min_flt;
+	pacct->ac_majflt += sysiso_current->maj_flt;
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 
 static void slow_acct_process(struct pid_namespace *ns)
@@ -594,7 +594,7 @@ void acct_process(void)
 	 * alive and holds its namespace, which in turn holds
 	 * its parent.
 	 */
-	for (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {
+	for (ns = task_active_pid_ns(sysiso_current); ns != NULL; ns = ns->parent) {
 		if (ns->bacct)
 			break;
 	}
diff --git a/kernel/async.c b/kernel/async.c
index b8d7a6634..8a33c0479 100644
--- a/kernel/async.c
+++ b/kernel/async.c
@@ -121,7 +121,7 @@ static void async_run_entry_fn(struct work_struct *work)
 
 	/* 1) run (and print duration) */
 	pr_debug("calling  %lli_%pS @ %i\n", (long long)entry->cookie,
-		 entry->func, task_pid_nr(current));
+		 entry->func, task_pid_nr(sysiso_current));
 	calltime = ktime_get();
 
 	entry->func(entry->data, entry->cookie);
@@ -206,7 +206,7 @@ async_cookie_t async_schedule_node_domain(async_func_t func, void *data,
 	spin_unlock_irqrestore(&async_lock, flags);
 
 	/* mark that this task has queued an async job, used by module init */
-	current->flags |= PF_USED_ASYNC;
+	sysiso_current->flags |= PF_USED_ASYNC;
 
 	/* schedule for execution */
 	queue_work_node(node, system_unbound_wq, &entry->work);
@@ -271,12 +271,13 @@ void async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain
 {
 	ktime_t starttime;
 
-	pr_debug("async_waiting @ %i\n", task_pid_nr(current));
+	pr_debug("async_waiting @ %i\n", task_pid_nr(sysiso_current));
 	starttime = ktime_get();
 
 	wait_event(async_done, lowest_in_progress(domain) >= cookie);
 
-	pr_debug("async_continuing @ %i after %lli usec\n", task_pid_nr(current),
+	pr_debug("async_continuing @ %i after %lli usec\n",
+		 task_pid_nr(sysiso_current),
 		 microseconds_since(starttime));
 }
 EXPORT_SYMBOL_GPL(async_synchronize_cookie_domain);
diff --git a/kernel/audit.c b/kernel/audit.c
index 121d37e70..116c1c32e 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1034,7 +1034,7 @@ static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)
 	case AUDIT_MAKE_EQUIV:
 		/* Only support auditd and auditctl in initial pid namespace
 		 * for now. */
-		if (task_active_pid_ns(current) != &init_pid_ns)
+		if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 			return -EPERM;
 
 		if (!netlink_capable(skb, CAP_AUDIT_CONTROL))
@@ -1057,7 +1057,7 @@ static void audit_log_common_recv_msg(struct audit_context *context,
 					struct audit_buffer **ab, u16 msg_type)
 {
 	uid_t uid = from_kuid(&init_user_ns, current_uid());
-	pid_t pid = task_tgid_nr(current);
+	pid_t pid = task_tgid_nr(sysiso_current);
 
 	if (!audit_enabled && msg_type != AUDIT_USER_AVC) {
 		*ab = NULL;
@@ -1466,7 +1466,7 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		struct audit_tty_status s;
 		unsigned int t;
 
-		t = READ_ONCE(current->signal->audit_tty);
+		t = READ_ONCE(sysiso_current->signal->audit_tty);
 		s.enabled = t & AUDIT_TTY_ENABLE;
 		s.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);
 
@@ -1487,10 +1487,10 @@ static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 			err = -EINVAL;
 
 		if (err)
-			t = READ_ONCE(current->signal->audit_tty);
+			t = READ_ONCE(sysiso_current->signal->audit_tty);
 		else {
 			t = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);
-			t = xchg(&current->signal->audit_tty, t);
+			t = xchg(&sysiso_current->signal->audit_tty, t);
 		}
 		old.enabled = t & AUDIT_TTY_ENABLE;
 		old.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);
@@ -1549,7 +1549,7 @@ static void audit_log_multicast(int group, const char *op, int err)
 {
 	const struct cred *cred;
 	struct tty_struct *tty;
-	char comm[sizeof(current->comm)];
+	char comm[sizeof(sysiso_current->comm)];
 	struct audit_buffer *ab;
 
 	if (!audit_enabled)
@@ -1562,7 +1562,7 @@ static void audit_log_multicast(int group, const char *op, int err)
 	cred = current_cred();
 	tty = audit_get_tty();
 	audit_log_format(ab, "pid=%u uid=%u auid=%u tty=%s ses=%u",
-			 task_pid_nr(current),
+			 task_pid_nr(sysiso_current),
 			 from_kuid(&init_user_ns, cred->uid),
 			 from_kuid(&init_user_ns, audit_get_loginuid(current)),
 			 tty ? tty_name(tty) : "(none)",
@@ -2177,10 +2177,10 @@ struct tty_struct *audit_get_tty(void)
 	struct tty_struct *tty = NULL;
 	unsigned long flags;
 
-	spin_lock_irqsave(&current->sighand->siglock, flags);
-	if (current->signal)
-		tty = tty_kref_get(current->signal->tty);
-	spin_unlock_irqrestore(&current->sighand->siglock, flags);
+	spin_lock_irqsave(&sysiso_current->sighand->siglock, flags);
+	if (sysiso_current->signal)
+		tty = tty_kref_get(sysiso_current->signal->tty);
+	spin_unlock_irqrestore(&sysiso_current->sighand->siglock, flags);
 	return tty;
 }
 
@@ -2192,7 +2192,7 @@ void audit_put_tty(struct tty_struct *tty)
 void audit_log_task_info(struct audit_buffer *ab)
 {
 	const struct cred *cred;
-	char comm[sizeof(current->comm)];
+	char comm[sizeof(sysiso_current->comm)];
 	struct tty_struct *tty;
 
 	if (!ab)
@@ -2204,8 +2204,8 @@ void audit_log_task_info(struct audit_buffer *ab)
 			 " ppid=%d pid=%d auid=%u uid=%u gid=%u"
 			 " euid=%u suid=%u fsuid=%u"
 			 " egid=%u sgid=%u fsgid=%u tty=%s ses=%u",
-			 task_ppid_nr(current),
-			 task_tgid_nr(current),
+			 task_ppid_nr(sysiso_current),
+			 task_tgid_nr(sysiso_current),
 			 from_kuid(&init_user_ns, audit_get_loginuid(current)),
 			 from_kuid(&init_user_ns, cred->uid),
 			 from_kgid(&init_user_ns, cred->gid),
@@ -2288,7 +2288,8 @@ static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,
 	loginuid = from_kuid(&init_user_ns, kloginuid);
 	tty = audit_get_tty();
 
-	audit_log_format(ab, "pid=%d uid=%u", task_tgid_nr(current), uid);
+	audit_log_format(ab, "pid=%d uid=%u", task_tgid_nr(sysiso_current),
+			 uid);
 	audit_log_task_context(ab);
 	audit_log_format(ab, " old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d",
 			 oldloginuid, loginuid, tty ? tty_name(tty) : "(none)",
@@ -2325,8 +2326,8 @@ int audit_set_loginuid(kuid_t loginuid)
 			sessionid = (unsigned int)atomic_inc_return(&session_id);
 	}
 
-	current->sessionid = sessionid;
-	current->loginuid = loginuid;
+	sysiso_current->sessionid = sessionid;
+	sysiso_current->loginuid = loginuid;
 out:
 	audit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);
 	return rc;
@@ -2347,7 +2348,7 @@ int audit_signal_info(int sig, struct task_struct *t)
 	if (auditd_test_task(t) &&
 	    (sig == SIGTERM || sig == SIGHUP ||
 	     sig == SIGUSR1 || sig == SIGUSR2)) {
-		audit_sig_pid = task_tgid_nr(current);
+		audit_sig_pid = task_tgid_nr(sysiso_current);
 		auid = audit_get_loginuid(current);
 		if (uid_valid(auid))
 			audit_sig_uid = auid;
diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index db2c6b59d..758cefb31 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -1333,7 +1333,7 @@ int audit_filter(int msgtype, unsigned int listtype)
 
 			switch (f->type) {
 			case AUDIT_PID:
-				pid = task_pid_nr(current);
+				pid = task_pid_nr(sysiso_current);
 				result = audit_comparator(pid, f->op, f->val);
 				break;
 			case AUDIT_UID:
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index b1cb1dbf7..7f6e2035f 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1033,7 +1033,7 @@ static void audit_log_execve_info(struct audit_context *context,
 	unsigned int arg;
 	char *buf_head;
 	char *buf;
-	const char __user *p = (const char __user *)current->mm->arg_start;
+	const char __user *p = (const char __user *)sysiso_current->mm->arg_start;
 
 	/* NOTE: this buffer needs to be large enough to hold all the non-arg
 	 *       data we put in the audit record for this argument (see the
@@ -1487,7 +1487,7 @@ static void audit_log_exit(void)
 	struct audit_aux_data *aux;
 	struct audit_names *n;
 
-	context->personality = current->personality;
+	context->personality = sysiso_current->personality;
 
 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);
 	if (!ab)
@@ -1685,7 +1685,7 @@ void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,
 			return;
 	}
 
-	context->arch	    = syscall_get_arch(current);
+	context->arch	    = syscall_get_arch(sysiso_current);
 	context->major      = major;
 	context->argv[0]    = a1;
 	context->argv[1]    = a2;
@@ -1878,7 +1878,7 @@ static struct audit_names *audit_alloc_name(struct audit_context *context,
 
 	context->name_count++;
 	if (!context->pwd.dentry)
-		get_fs_pwd(current->fs, &context->pwd);
+		get_fs_pwd(sysiso_current->fs, &context->pwd);
 	return aname;
 }
 
@@ -2529,7 +2529,7 @@ void __audit_log_capset(const struct cred *new, const struct cred *old)
 {
 	struct audit_context *context = audit_context();
 
-	context->capset.pid = task_tgid_nr(current);
+	context->capset.pid = task_tgid_nr(sysiso_current);
 	context->capset.cap.effective   = new->cap_effective;
 	context->capset.cap.inheritable = new->cap_effective;
 	context->capset.cap.permitted   = new->cap_permitted;
@@ -2595,7 +2595,7 @@ void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,
 		       enum audit_nfcfgop op, gfp_t gfp)
 {
 	struct audit_buffer *ab;
-	char comm[sizeof(current->comm)];
+	char comm[sizeof(sysiso_current->comm)];
 
 	ab = audit_log_start(audit_context(), gfp, AUDIT_NETFILTER_CFG);
 	if (!ab)
@@ -2603,10 +2603,10 @@ void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,
 	audit_log_format(ab, "table=%s family=%u entries=%u op=%s",
 			 name, af, nentries, audit_nfcfgs[op].s);
 
-	audit_log_format(ab, " pid=%u", task_pid_nr(current));
+	audit_log_format(ab, " pid=%u", task_pid_nr(sysiso_current));
 	audit_log_task_context(ab); /* subj= */
 	audit_log_format(ab, " comm=");
-	audit_log_untrustedstring(ab, get_task_comm(comm, current));
+	audit_log_untrustedstring(ab, get_task_comm(comm, sysiso_current));
 	audit_log_end(ab);
 }
 EXPORT_SYMBOL_GPL(__audit_log_nfcfg);
@@ -2616,10 +2616,10 @@ static void audit_log_task(struct audit_buffer *ab)
 	kuid_t auid, uid;
 	kgid_t gid;
 	unsigned int sessionid;
-	char comm[sizeof(current->comm)];
+	char comm[sizeof(sysiso_current->comm)];
 
-	auid = audit_get_loginuid(current);
-	sessionid = audit_get_sessionid(current);
+	auid = audit_get_loginuid(sysiso_current);
+	sessionid = audit_get_sessionid(sysiso_current);
 	current_uid_gid(&uid, &gid);
 
 	audit_log_format(ab, "auid=%u uid=%u gid=%u ses=%u",
@@ -2628,9 +2628,9 @@ static void audit_log_task(struct audit_buffer *ab)
 			 from_kgid(&init_user_ns, gid),
 			 sessionid);
 	audit_log_task_context(ab);
-	audit_log_format(ab, " pid=%d comm=", task_tgid_nr(current));
-	audit_log_untrustedstring(ab, get_task_comm(comm, current));
-	audit_log_d_path_exe(ab, current->mm);
+	audit_log_format(ab, " pid=%d comm=", task_tgid_nr(sysiso_current));
+	audit_log_untrustedstring(ab, get_task_comm(comm, sysiso_current));
+	audit_log_d_path_exe(ab, sysiso_current->mm);
 }
 
 /**
@@ -2679,8 +2679,8 @@ void audit_seccomp(unsigned long syscall, long signr, int code)
 		return;
 	audit_log_task(ab);
 	audit_log_format(ab, " sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x",
-			 signr, syscall_get_arch(current), syscall,
-			 in_compat_syscall(), KSTK_EIP(current), code);
+			 signr, syscall_get_arch(sysiso_current), syscall,
+			 in_compat_syscall(), KSTK_EIP(sysiso_current), code);
 	audit_log_end(ab);
 }
 
diff --git a/kernel/bpf/devmap.c b/kernel/bpf/devmap.c
index f02d04540..c020006f2 100644
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@ -936,7 +936,7 @@ static int __dev_map_update_elem(struct net *net, struct bpf_map *map,
 static int dev_map_update_elem(struct bpf_map *map, void *key, void *value,
 			       u64 map_flags)
 {
-	return __dev_map_update_elem(current->nsproxy->net_ns,
+	return __dev_map_update_elem(sysiso_current->nsproxy->net_ns,
 				     map, key, value, map_flags);
 }
 
@@ -996,8 +996,8 @@ static int __dev_map_hash_update_elem(struct net *net, struct bpf_map *map,
 static int dev_map_hash_update_elem(struct bpf_map *map, void *key, void *value,
 				   u64 map_flags)
 {
-	return __dev_map_hash_update_elem(current->nsproxy->net_ns,
-					 map, key, value, map_flags);
+	return __dev_map_hash_update_elem(sysiso_current->nsproxy->net_ns,
+					  map, key, value, map_flags);
 }
 
 static int dev_map_redirect(struct bpf_map *map, u32 ifindex, u64 flags)
diff --git a/kernel/bpf/helpers.c b/kernel/bpf/helpers.c
index 9aabf84af..06c68bb38 100644
--- a/kernel/bpf/helpers.c
+++ b/kernel/bpf/helpers.c
@@ -181,7 +181,7 @@ const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto = {
 
 BPF_CALL_0(bpf_get_current_pid_tgid)
 {
-	struct task_struct *task = current;
+	struct task_struct *task = sysiso_current;
 
 	if (unlikely(!task))
 		return -EINVAL;
diff --git a/kernel/bpf/net_namespace.c b/kernel/bpf/net_namespace.c
index 542f275bf..cda38c70c 100644
--- a/kernel/bpf/net_namespace.c
+++ b/kernel/bpf/net_namespace.c
@@ -308,7 +308,7 @@ int netns_bpf_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)
 	if (type < 0)
 		return -EINVAL;
 
-	net = current->nsproxy->net_ns;
+	net = sysiso_current->nsproxy->net_ns;
 	mutex_lock(&netns_bpf_mutex);
 
 	/* Attaching prog directly is not compatible with links */
@@ -397,7 +397,8 @@ int netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)
 		return PTR_ERR(prog);
 
 	mutex_lock(&netns_bpf_mutex);
-	ret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);
+	ret = __netns_bpf_prog_detach(sysiso_current->nsproxy->net_ns, type,
+				      prog);
 	mutex_unlock(&netns_bpf_mutex);
 
 	bpf_prog_put(prog);
diff --git a/kernel/bpf/offload.c b/kernel/bpf/offload.c
index bd09290e3..dd9fdb264 100644
--- a/kernel/bpf/offload.c
+++ b/kernel/bpf/offload.c
@@ -96,7 +96,7 @@ int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr)
 
 	offload->prog = prog;
 
-	offload->netdev = dev_get_by_index(current->nsproxy->net_ns,
+	offload->netdev = dev_get_by_index(sysiso_current->nsproxy->net_ns,
 					   attr->prog_ifindex);
 	err = bpf_dev_offload_check(offload->netdev);
 	if (err)
@@ -361,7 +361,7 @@ static int bpf_map_offload_ndo(struct bpf_offloaded_map *offmap,
 
 struct bpf_map *bpf_map_offload_map_alloc(union bpf_attr *attr)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct bpf_offload_netdev *ondev;
 	struct bpf_offloaded_map *offmap;
 	int err;
diff --git a/kernel/bpf/task_iter.c b/kernel/bpf/task_iter.c
index b48750bfb..7886315e5 100644
--- a/kernel/bpf/task_iter.c
+++ b/kernel/bpf/task_iter.c
@@ -268,7 +268,7 @@ static int init_seq_pidns(void *priv_data, struct bpf_iter_aux_info *aux)
 {
 	struct bpf_iter_seq_task_common *common = priv_data;
 
-	common->ns = get_pid_ns(task_active_pid_ns(current));
+	common->ns = get_pid_ns(task_active_pid_ns(sysiso_current));
 	return 0;
 }
 
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index e76b55917..5a64f207a 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -10909,7 +10909,7 @@ static int do_check(struct bpf_verifier_env *env)
 			goto process_bpf_exit;
 		}
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EAGAIN;
 
 		if (need_resched())
diff --git a/kernel/capability.c b/kernel/capability.c
index 46a361dde..7cefff17d 100644
--- a/kernel/capability.c
+++ b/kernel/capability.c
@@ -45,7 +45,7 @@ __setup("no_file_caps", file_caps_disable);
 
 static void warn_legacy_capability_use(void)
 {
-	char name[sizeof(current->comm)];
+	char name[sizeof(sysiso_current->comm)];
 
 	pr_info_once("warning: `%s' uses 32-bit capabilities (legacy support in use)\n",
 		     get_task_comm(name, current));
@@ -69,7 +69,7 @@ static void warn_legacy_capability_use(void)
 
 static void warn_deprecated_v2(void)
 {
-	char name[sizeof(current->comm)];
+	char name[sizeof(sysiso_current->comm)];
 
 	pr_info_once("warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\n",
 		     get_task_comm(name, current));
@@ -118,7 +118,7 @@ static inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,
 {
 	int ret;
 
-	if (pid && (pid != task_pid_vnr(current))) {
+	if (pid && (pid != task_pid_vnr(sysiso_current))) {
 		struct task_struct *target;
 
 		rcu_read_lock();
@@ -236,7 +236,7 @@ SYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)
 		return -EFAULT;
 
 	/* may only affect current now */
-	if (pid != 0 && pid != task_pid_vnr(current))
+	if (pid != 0 && pid != task_pid_vnr(sysiso_current))
 		return -EPERM;
 
 	copybytes = tocopy * sizeof(struct __user_cap_data_struct);
@@ -374,7 +374,7 @@ static bool ns_capable_common(struct user_namespace *ns,
 
 	capable = security_capable(current_cred(), ns, cap, opts);
 	if (capable == 0) {
-		current->flags |= PF_SUPERPRIV;
+		sysiso_current->flags |= PF_SUPERPRIV;
 		return true;
 	}
 	return false;
diff --git a/kernel/cgroup/cgroup-v1.c b/kernel/cgroup/cgroup-v1.c
index 35b920328..a684006f3 100644
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@ -282,7 +282,7 @@ static struct cgroup_pidlist *cgroup_pidlist_find(struct cgroup *cgrp,
 {
 	struct cgroup_pidlist *l;
 	/* don't need task_nsproxy() if we're looking at ourself */
-	struct pid_namespace *ns = task_active_pid_ns(current);
+	struct pid_namespace *ns = task_active_pid_ns(sysiso_current);
 
 	lockdep_assert_held(&cgrp->pidlist_mutex);
 
@@ -317,7 +317,7 @@ static struct cgroup_pidlist *cgroup_pidlist_find_create(struct cgroup *cgrp,
 	INIT_DELAYED_WORK(&l->destroy_dwork, cgroup_pidlist_destroy_work_fn);
 	l->key.type = type;
 	/* don't need task_nsproxy() if we're looking at ourself */
-	l->key.ns = get_pid_ns(task_active_pid_ns(current));
+	l->key.ns = get_pid_ns(task_active_pid_ns(sysiso_current));
 	l->owner = cgrp;
 	list_add(&l->links, &cgrp->pidlists);
 	return l;
@@ -1062,7 +1062,7 @@ int cgroup1_reconfigure(struct fs_context *fc)
 
 	if (ctx->subsys_mask != root->subsys_mask || ctx->release_agent)
 		pr_warn("option changes via remount are deprecated (pid=%d comm=%s)\n",
-			task_tgid_nr(current), current->comm);
+			task_tgid_nr(sysiso_current), sysiso_current->comm);
 
 	added_mask = ctx->subsys_mask & ~root->subsys_mask;
 	removed_mask = root->subsys_mask & ~ctx->subsys_mask;
diff --git a/kernel/cgroup/cgroup.c b/kernel/cgroup/cgroup.c
index ea08f01d0..5175c681b 100644
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@ -1389,7 +1389,7 @@ current_cgns_cgroup_from_root(struct cgroup_root *root)
 
 	rcu_read_lock();
 
-	cset = current->nsproxy->cgroup_ns->root_cset;
+	cset = sysiso_current->nsproxy->cgroup_ns->root_cset;
 	if (cset == &init_css_set) {
 		res = &root->cgrp;
 	} else if (root == &cgrp_dfl_root) {
@@ -1878,7 +1878,7 @@ static int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param
 
 static void apply_cgroup_root_flags(unsigned int root_flags)
 {
-	if (current->nsproxy->cgroup_ns == &init_cgroup_ns) {
+	if (sysiso_current->nsproxy->cgroup_ns == &init_cgroup_ns) {
 		if (root_flags & CGRP_ROOT_NS_DELEGATE)
 			cgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;
 		else
@@ -2162,7 +2162,7 @@ static int cgroup_init_fs_context(struct fs_context *fc)
 	if (!ctx)
 		return -ENOMEM;
 
-	ctx->ns = current->nsproxy->cgroup_ns;
+	ctx->ns = sysiso_current->nsproxy->cgroup_ns;
 	get_cgroup_ns(ctx->ns);
 	fc->fs_private = &ctx->kfc;
 	if (fc->fs_type == &cgroup2_fs_type)
@@ -3805,7 +3805,7 @@ static void cgroup_file_release(struct kernfs_open_file *of)
 static ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,
 				 size_t nbytes, loff_t off)
 {
-	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
+	struct cgroup_namespace *ns = sysiso_current->nsproxy->cgroup_ns;
 	struct cgroup *cgrp = of->kn->parent->priv;
 	struct cftype *cft = of_cft(of);
 	struct cgroup_subsys_state *css;
@@ -4817,7 +4817,7 @@ static int cgroup_procs_write_permission(struct cgroup *src_cgrp,
 					 struct cgroup *dst_cgrp,
 					 struct super_block *sb)
 {
-	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
+	struct cgroup_namespace *ns = sysiso_current->nsproxy->cgroup_ns;
 	struct cgroup *com_cgrp = src_cgrp;
 	int ret;
 
@@ -5978,7 +5978,7 @@ int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,
 		 */
 		if (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {
 			retval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,
-						current->nsproxy->cgroup_ns);
+						sysiso_current->nsproxy->cgroup_ns);
 			if (retval >= PATH_MAX)
 				retval = -ENAMETOOLONG;
 			if (retval < 0)
diff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c
index 2a9695ccb..df38c78bb 100644
--- a/kernel/cgroup/cpuset.c
+++ b/kernel/cgroup/cpuset.c
@@ -3529,7 +3529,7 @@ bool __cpuset_node_allowed(int node, gfp_t gfp_mask)
 	if (gfp_mask & __GFP_HARDWALL)	/* If hardwall request, stop here */
 		return false;
 
-	if (current->flags & PF_EXITING) /* Let dying task have memory */
+	if (sysiso_current->flags & PF_EXITING) /* Let dying task have memory */
 		return true;
 
 	/* Not hardwall and node outside mems_allowed: scan up cpusets */
@@ -3691,7 +3691,7 @@ int proc_cpuset_show(struct seq_file *m, struct pid_namespace *ns,
 
 	css = task_get_css(tsk, cpuset_cgrp_id);
 	retval = cgroup_path_ns(css->cgroup, buf, PATH_MAX,
-				current->nsproxy->cgroup_ns);
+				sysiso_current->nsproxy->cgroup_ns);
 	css_put(css);
 	if (retval >= PATH_MAX)
 		retval = -ENAMETOOLONG;
diff --git a/kernel/cgroup/freezer.c b/kernel/cgroup/freezer.c
index 3984dd6b8..5c908c96c 100644
--- a/kernel/cgroup/freezer.c
+++ b/kernel/cgroup/freezer.c
@@ -139,11 +139,11 @@ void cgroup_leave_frozen(bool always_leave)
 		cgroup_update_frozen(cgrp);
 		WARN_ON_ONCE(!current->frozen);
 		current->frozen = false;
-	} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {
-		spin_lock(&current->sighand->siglock);
-		current->jobctl |= JOBCTL_TRAP_FREEZE;
+	} else if (!(sysiso_current->jobctl & JOBCTL_TRAP_FREEZE)) {
+		spin_lock(&sysiso_current->sighand->siglock);
+		sysiso_current->jobctl |= JOBCTL_TRAP_FREEZE;
 		set_thread_flag(TIF_SIGPENDING);
-		spin_unlock(&current->sighand->siglock);
+		spin_unlock(&sysiso_current->sighand->siglock);
 	}
 	spin_unlock_irq(&css_set_lock);
 }
diff --git a/kernel/compat.c b/kernel/compat.c
index 55551989d..e3c29d896 100644
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@ -44,14 +44,14 @@ COMPAT_SYSCALL_DEFINE3(sigprocmask, int, how,
 	old_sigset_t old_set, new_set;
 	sigset_t new_blocked;
 
-	old_set = current->blocked.sig[0];
+	old_set = sysiso_current->blocked.sig[0];
 
 	if (nset) {
 		if (get_user(new_set, nset))
 			return -EFAULT;
 		new_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));
 
-		new_blocked = current->blocked;
+		new_blocked = sysiso_current->blocked;
 
 		switch (how) {
 		case SIG_BLOCK:
diff --git a/kernel/cred.c b/kernel/cred.c
index 1ae0b4948..5f1cbd299 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -20,13 +20,13 @@
 #if 0
 #define kdebug(FMT, ...)						\
 	printk("[%-5.5s%5u] " FMT "\n",					\
-	       current->comm, current->pid, ##__VA_ARGS__)
+	       sysiso_current->comm, current->pid, ##__VA_ARGS__)
 #else
 #define kdebug(FMT, ...)						\
 do {									\
 	if (0)								\
 		no_printk("[%-5.5s%5u] " FMT "\n",			\
-			  current->comm, current->pid, ##__VA_ARGS__);	\
+			  sysiso_current->comm, sysiso_current->pid, ##__VA_ARGS__);	\
 } while (0)
 #endif
 
@@ -144,7 +144,7 @@ void __put_cred(struct cred *cred)
 	cred->magic = CRED_MAGIC_DEAD;
 	cred->put_addr = __builtin_return_address(0);
 #endif
-	BUG_ON(cred == current->cred);
+	BUG_ON(cred == sysiso_current->cred);
 	BUG_ON(cred == current->real_cred);
 
 	if (cred->non_rcu)
@@ -251,7 +251,7 @@ struct cred *cred_alloc_blank(void)
  */
 struct cred *prepare_creds(void)
 {
-	struct task_struct *task = current;
+	struct task_struct *task = sysiso_current;
 	const struct cred *old;
 	struct cred *new;
 
@@ -446,7 +446,7 @@ static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)
  */
 int commit_creds(struct cred *new)
 {
-	struct task_struct *task = current;
+	struct task_struct *task = sysiso_current;
 	const struct cred *old = task->real_cred;
 
 	kdebug("commit_creds(%p{%d,%d})", new,
@@ -553,7 +553,7 @@ EXPORT_SYMBOL(abort_creds);
  */
 const struct cred *override_creds(const struct cred *new)
 {
-	const struct cred *old = current->cred;
+	const struct cred *old = sysiso_current->cred;
 
 	kdebug("override_creds(%p{%d,%d})", new,
 	       atomic_read(&new->usage),
@@ -575,7 +575,7 @@ const struct cred *override_creds(const struct cred *new)
 	 */
 	get_new_cred((struct cred *)new);
 	alter_cred_subscribers(new, 1);
-	rcu_assign_pointer(current->cred, new);
+	rcu_assign_pointer(sysiso_current->cred, new);
 	alter_cred_subscribers(old, -1);
 
 	kdebug("override_creds() = %p{%d,%d}", old,
@@ -594,7 +594,7 @@ EXPORT_SYMBOL(override_creds);
  */
 void revert_creds(const struct cred *old)
 {
-	const struct cred *override = current->cred;
+	const struct cred *override = sysiso_current->cred;
 
 	kdebug("revert_creds(%p{%d,%d})", old,
 	       atomic_read(&old->usage),
@@ -603,7 +603,7 @@ void revert_creds(const struct cred *old)
 	validate_creds(old);
 	validate_creds(override);
 	alter_cred_subscribers(old, 1);
-	rcu_assign_pointer(current->cred, old);
+	rcu_assign_pointer(sysiso_current->cred, old);
 	alter_cred_subscribers(override, -1);
 	put_cred(override);
 }
diff --git a/kernel/debug/gdbstub.c b/kernel/debug/gdbstub.c
index 9d34d2364..0823e07b5 100644
--- a/kernel/debug/gdbstub.c
+++ b/kernel/debug/gdbstub.c
@@ -740,7 +740,7 @@ static void gdb_cmd_query(struct kgdb_state *ks)
 	case 'C':
 		/* Current thread id */
 		strcpy(remcom_out_buffer, "QC");
-		ks->threadid = shadow_pid(current->pid);
+		ks->threadid = shadow_pid(sysiso_current->pid);
 		int_to_threadref(thref, ks->threadid);
 		pack_threadid(remcom_out_buffer + 2, thref);
 		break;
@@ -971,7 +971,7 @@ int gdb_serial_stub(struct kgdb_state *ks)
 		*ptr++ = 'T';
 		ptr = hex_byte_pack(ptr, ks->signo);
 		ptr += strlen(strcpy(ptr, "thread:"));
-		int_to_threadref(thref, shadow_pid(current->pid));
+		int_to_threadref(thref, shadow_pid(sysiso_current->pid));
 		ptr = pack_threadid(ptr, thref);
 		*ptr++ = ';';
 		put_packet(remcom_out_buffer);
diff --git a/kernel/delayacct.c b/kernel/delayacct.c
index 51530d5b1..315aa768a 100644
--- a/kernel/delayacct.c
+++ b/kernel/delayacct.c
@@ -91,7 +91,7 @@ static void delayacct_end(raw_spinlock_t *lock, u64 *start, u64 *total, u32 *cou
 
 void __delayacct_blkio_start(void)
 {
-	current->delays->blkio_start = local_clock();
+	sysiso_current->delays->blkio_start = local_clock();
 }
 
 /*
@@ -187,26 +187,26 @@ __u64 __delayacct_blkio_ticks(struct task_struct *tsk)
 
 void __delayacct_freepages_start(void)
 {
-	current->delays->freepages_start = local_clock();
+	sysiso_current->delays->freepages_start = local_clock();
 }
 
 void __delayacct_freepages_end(void)
 {
-	delayacct_end(&current->delays->lock,
-		      &current->delays->freepages_start,
-		      &current->delays->freepages_delay,
-		      &current->delays->freepages_count);
+	delayacct_end(&sysiso_current->delays->lock,
+		      &sysiso_current->delays->freepages_start,
+		      &sysiso_current->delays->freepages_delay,
+		      &sysiso_current->delays->freepages_count);
 }
 
 void __delayacct_thrashing_start(void)
 {
-	current->delays->thrashing_start = local_clock();
+	sysiso_current->delays->thrashing_start = local_clock();
 }
 
 void __delayacct_thrashing_end(void)
 {
-	delayacct_end(&current->delays->lock,
-		      &current->delays->thrashing_start,
-		      &current->delays->thrashing_delay,
-		      &current->delays->thrashing_count);
+	delayacct_end(&sysiso_current->delays->lock,
+		      &sysiso_current->delays->thrashing_start,
+		      &sysiso_current->delays->thrashing_delay,
+		      &sysiso_current->delays->thrashing_count);
 }
diff --git a/kernel/entry/common.c b/kernel/entry/common.c
index d5a61d565..38919637c 100644
--- a/kernel/entry/common.c
+++ b/kernel/entry/common.c
@@ -262,7 +262,7 @@ static void syscall_exit_work(struct pt_regs *regs, unsigned long work)
 static void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)
 {
 	unsigned long work = READ_ONCE(current_thread_info()->syscall_work);
-	unsigned long nr = syscall_get_nr(current, regs);
+	unsigned long nr = syscall_get_nr(sysiso_current, regs);
 
 	CT_WARN_ON(ct_state() != CONTEXT_KERNEL);
 
diff --git a/kernel/events/core.c b/kernel/events/core.c
index f23ca2603..1f70ecfb3 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -6449,7 +6449,7 @@ static void perf_sigtrap(struct perf_event *event)
 	/*
 	 * perf_pending_event() can race with the task exiting.
 	 */
-	if (current->flags & PF_EXITING)
+	if (sysiso_current->flags & PF_EXITING)
 		return;
 
 	force_sig_perf((void __user *)event->pending_addr,
@@ -6564,7 +6564,7 @@ static void perf_sample_regs_user(struct perf_regs *regs_user,
 	if (user_mode(regs)) {
 		regs_user->abi = perf_reg_abi(current);
 		regs_user->regs = regs;
-	} else if (!(current->flags & PF_KTHREAD)) {
+	} else if (!(sysiso_current->flags & PF_KTHREAD)) {
 		perf_get_regs_user(regs_user, regs);
 	} else {
 		regs_user->abi = PERF_SAMPLE_REGS_ABI_NONE;
@@ -11501,7 +11501,7 @@ perf_event_alloc(struct perf_event_attr *attr, int cpu,
 
 	event->parent		= parent_event;
 
-	event->ns		= get_pid_ns(task_active_pid_ns(current));
+	event->ns		= get_pid_ns(task_active_pid_ns(sysiso_current));
 	event->id		= atomic64_inc_return(&perf_event_id);
 
 	event->state		= PERF_EVENT_STATE_INACTIVE;
diff --git a/kernel/events/uprobes.c b/kernel/events/uprobes.c
index af24dc3fe..9d360d203 100644
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@ -1387,7 +1387,7 @@ int uprobe_mmap(struct vm_area_struct *vma)
 	 * consumers have gone away.
 	 */
 	list_for_each_entry_safe(uprobe, u, &tmp_list, pending_list) {
-		if (!fatal_signal_pending(current) &&
+		if (!fatal_signal_pending(sysiso_current) &&
 		    filter_chain(uprobe, UPROBE_FILTER_MMAP, vma->vm_mm)) {
 			unsigned long vaddr = offset_to_vaddr(vma, uprobe->offset);
 			install_breakpoint(uprobe, vma->vm_mm, vma, vaddr);
@@ -1693,7 +1693,7 @@ unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs)
 
 unsigned long uprobe_get_trap_addr(struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	if (unlikely(utask && utask->active_uprobe))
 		return utask->vaddr;
@@ -1743,9 +1743,9 @@ void uprobe_free_utask(struct task_struct *t)
  */
 static struct uprobe_task *get_utask(void)
 {
-	if (!current->utask)
-		current->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);
-	return current->utask;
+	if (!sysiso_current->utask)
+		sysiso_current->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);
+	return sysiso_current->utask;
 }
 
 static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)
@@ -1779,16 +1779,16 @@ static int dup_utask(struct task_struct *t, struct uprobe_task *o_utask)
 static void uprobe_warn(struct task_struct *t, const char *msg)
 {
 	pr_warn("uprobe: %s:%d failed to %s\n",
-			current->comm, current->pid, msg);
+			sysiso_current->comm, sysiso_current->pid, msg);
 }
 
 static void dup_xol_work(struct callback_head *work)
 {
-	if (current->flags & PF_EXITING)
+	if (sysiso_current->flags & PF_EXITING)
 		return;
 
 	if (!__create_xol_area(current->utask->dup_xol_addr) &&
-			!fatal_signal_pending(current))
+			!fatal_signal_pending(sysiso_current))
 		uprobe_warn(current, "dup xol area");
 }
 
@@ -1797,7 +1797,7 @@ static void dup_xol_work(struct callback_head *work)
  */
 void uprobe_copy_process(struct task_struct *t, unsigned long flags)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 	struct mm_struct *mm = current->mm;
 	struct xol_area *area;
 
@@ -1874,7 +1874,7 @@ static void prepare_uretprobe(struct uprobe *uprobe, struct pt_regs *regs)
 	if (utask->depth >= MAX_URETPROBE_DEPTH) {
 		printk_ratelimited(KERN_INFO "uprobe: omit uretprobe due to"
 				" nestedness limit pid/tgid=%d/%d\n",
-				current->pid, current->tgid);
+				sysiso_current->pid, sysiso_current->tgid);
 		return;
 	}
 
@@ -2133,7 +2133,7 @@ static void handle_trampoline(struct pt_regs *regs)
 	struct return_instance *ri, *next;
 	bool valid;
 
-	utask = current->utask;
+	utask = sysiso_current->utask;
 	if (!utask)
 		goto sigill;
 
@@ -2275,9 +2275,9 @@ static void handle_singlestep(struct uprobe_task *utask, struct pt_regs *regs)
 	utask->state = UTASK_RUNNING;
 	xol_free_insn_slot(current);
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	recalc_sigpending(); /* see uprobe_deny_signal() */
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	if (unlikely(err)) {
 		uprobe_warn(current, "execute the probed insn, sending SIGILL.");
@@ -2302,7 +2302,7 @@ void uprobe_notify_resume(struct pt_regs *regs)
 
 	clear_thread_flag(TIF_UPROBE);
 
-	utask = current->utask;
+	utask = sysiso_current->utask;
 	if (utask && utask->active_uprobe)
 		handle_singlestep(utask, regs);
 	else
@@ -2319,7 +2319,7 @@ int uprobe_pre_sstep_notifier(struct pt_regs *regs)
 		return 0;
 
 	if (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&
-	    (!current->utask || !current->utask->return_instances))
+	    (!sysiso_current->utask || !current->utask->return_instances))
 		return 0;
 
 	set_thread_flag(TIF_UPROBE);
@@ -2332,7 +2332,7 @@ int uprobe_pre_sstep_notifier(struct pt_regs *regs)
  */
 int uprobe_post_sstep_notifier(struct pt_regs *regs)
 {
-	struct uprobe_task *utask = current->utask;
+	struct uprobe_task *utask = sysiso_current->utask;
 
 	if (!current->mm || !utask || !utask->active_uprobe)
 		/* task is currently not uprobed */
diff --git a/kernel/exit.c b/kernel/exit.c
index 91a43e57a..a02d76472 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -69,6 +69,8 @@
 #include <asm/unistd.h>
 #include <asm/mmu_context.h>
 
+#include <linux/sysiso.h>
+
 static void __unhash_process(struct task_struct *p, bool group_dead)
 {
 	nr_threads--;
@@ -290,7 +292,7 @@ int is_current_pgrp_orphaned(void)
 	int retval;
 
 	read_lock(&tasklist_lock);
-	retval = will_become_orphaned_pgrp(task_pgrp(current), NULL);
+	retval = will_become_orphaned_pgrp(task_pgrp(sysiso_current), NULL);
 	read_unlock(&tasklist_lock);
 
 	return retval;
@@ -715,7 +717,7 @@ static void check_stack_usage(void)
 	spin_lock(&low_water_lock);
 	if (free < lowest_to_date) {
 		pr_info("%s (%d) used greatest stack depth: %lu bytes left\n",
-			current->comm, task_pid_nr(current), free);
+			sysiso_current->comm, task_pid_nr(sysiso_current), free);
 		lowest_to_date = free;
 	}
 	spin_unlock(&low_water_lock);
@@ -726,7 +728,7 @@ static inline void check_stack_usage(void) {}
 
 void __noreturn do_exit(long code)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	int group_dead;
 
 	/*
@@ -754,7 +756,7 @@ void __noreturn do_exit(long code)
 
 	if (unlikely(in_atomic())) {
 		pr_info("note: %s[%d] exited with preempt_count %d\n",
-			current->comm, task_pid_nr(current),
+			sysiso_current->comm, task_pid_nr(sysiso_current),
 			preempt_count());
 		preempt_count_set(PREEMPT_ENABLED);
 	}
@@ -873,6 +875,10 @@ void __noreturn do_exit(long code)
 	exit_tasks_rcu_finish();
 
 	lockdep_free_task(tsk);
+
+	if (IS_ENABLED(CONFIG_SYSISO))
+		sysiso_client_disable(tsk);
+
 	do_task_dead();
 }
 EXPORT_SYMBOL_GPL(do_exit);
@@ -898,14 +904,14 @@ SYSCALL_DEFINE1(exit, int, error_code)
 void
 do_group_exit(int exit_code)
 {
-	struct signal_struct *sig = current->signal;
+	struct signal_struct *sig = sysiso_current->signal;
 
 	BUG_ON(exit_code & 0x80); /* core dumps don't get here */
 
 	if (signal_group_exit(sig))
 		exit_code = sig->group_exit_code;
 	else if (!thread_group_empty(current)) {
-		struct sighand_struct *const sighand = current->sighand;
+		struct sighand_struct *const sighand = sysiso_current->sighand;
 
 		spin_lock_irq(&sighand->siglock);
 		if (signal_group_exit(sig))
@@ -1032,7 +1038,7 @@ static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)
 	 */
 	if (state == EXIT_DEAD && thread_group_leader(p)) {
 		struct signal_struct *sig = p->signal;
-		struct signal_struct *psig = current->signal;
+		struct signal_struct *psig = sysiso_current->signal;
 		unsigned long maxrss;
 		u64 tgutime, tgstime;
 
@@ -1057,7 +1063,7 @@ static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)
 		 * in the group including the group leader.
 		 */
 		thread_group_cputime_adjusted(p, &tgutime, &tgstime);
-		spin_lock_irq(&current->sighand->siglock);
+		spin_lock_irq(&sysiso_current->sighand->siglock);
 		write_seqlock(&psig->stats_lock);
 		psig->cutime += tgutime + sig->cutime;
 		psig->cstime += tgstime + sig->cstime;
@@ -1082,7 +1088,7 @@ static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)
 		task_io_accounting_add(&psig->ioac, &p->ioac);
 		task_io_accounting_add(&psig->ioac, &sig->ioac);
 		write_sequnlock(&psig->stats_lock);
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 	}
 
 	if (wo->wo_rusage)
@@ -1446,7 +1452,7 @@ static bool is_effectively_child(struct wait_opts *wo, bool ptrace,
 		!ptrace ? target->real_parent : target->parent;
 
 	return current == parent || (!(wo->wo_flags & __WNOTHREAD) &&
-				     same_thread_group(current, parent));
+				     same_thread_group(sysiso_current, parent));
 }
 
 /*
@@ -1486,8 +1492,12 @@ static long do_wait(struct wait_opts *wo)
 	trace_sched_process_wait(wo->wo_pid);
 
 	init_waitqueue_func_entry(&wo->child_wait, child_wait_callback);
-	wo->child_wait.private = current;
-	add_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);
+	if (sysiso_current_is_server())	{
+		wo->child_wait.sysiso_task = sysiso_current->sysiso_task;
+	}
+
+	wo->child_wait.private = sysiso_current;
+	add_wait_queue(&sysiso_current->signal->wait_chldexit, &wo->child_wait);
 repeat:
 	/*
 	 * If there is nothing that can match our criteria, just get out.
@@ -1508,7 +1518,7 @@ static long do_wait(struct wait_opts *wo)
 		if (retval)
 			goto end;
 	} else {
-		struct task_struct *tsk = current;
+		struct task_struct *tsk = sysiso_current;
 
 		do {
 			retval = do_wait_thread(wo, tsk);
@@ -1521,7 +1531,7 @@ static long do_wait(struct wait_opts *wo)
 
 			if (wo->wo_flags & __WNOTHREAD)
 				break;
-		} while_each_thread(current, tsk);
+		} while_each_thread(sysiso_current, tsk);
 	}
 	read_unlock(&tasklist_lock);
 
@@ -1529,14 +1539,14 @@ static long do_wait(struct wait_opts *wo)
 	retval = wo->notask_error;
 	if (!retval && !(wo->wo_flags & WNOHANG)) {
 		retval = -ERESTARTSYS;
-		if (!signal_pending(current)) {
+		if (!signal_pending(sysiso_current)) {
 			schedule();
 			goto repeat;
 		}
 	}
 end:
 	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);
+	remove_wait_queue(&sysiso_current->signal->wait_chldexit, &wo->child_wait);
 	return retval;
 }
 
diff --git a/kernel/fork.c b/kernel/fork.c
index 38681ad44..f500780f3 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -98,6 +98,8 @@
 #include <linux/io_uring.h>
 #include <linux/bpf.h>
 
+#include <linux/sysiso.h>
+
 #include <asm/pgalloc.h>
 #include <linux/uaccess.h>
 #include <asm/mmu_context.h>
@@ -538,7 +540,7 @@ static __latent_entropy int dup_mmap(struct mm_struct *mm,
 		 * Don't duplicate many vmas if we've been oom-killed (for
 		 * example)
 		 */
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			retval = -EINTR;
 			goto out;
 		}
@@ -1514,7 +1516,7 @@ static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)
 
 static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)
 {
-	struct fs_struct *fs = current->fs;
+	struct fs_struct *fs = sysiso_current->fs;
 	if (clone_flags & CLONE_FS) {
 		/* tsk->fs is already what we want */
 		spin_lock(&fs->lock);
@@ -1540,7 +1542,7 @@ static int copy_files(unsigned long clone_flags, struct task_struct *tsk)
 	/*
 	 * A background process may not have any files ...
 	 */
-	oldf = current->files;
+	oldf = sysiso_current->files;
 	if (!oldf)
 		goto out;
 
@@ -1599,9 +1601,9 @@ static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)
 		return -ENOMEM;
 
 	refcount_set(&sig->count, 1);
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	memcpy(sig->action, current->sighand->action, sizeof(sig->action));
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	/* Reset all signal handler not set to SIG_IGN to SIG_DFL. */
 	if (clone_flags & CLONE_CLEAR_SIGHAND)
@@ -1668,7 +1670,7 @@ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
 #endif
 
 	task_lock(current->group_leader);
-	memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);
+	memcpy(sig->rlim, sysiso_current->signal->rlim, sizeof sig->rlim);
 	task_unlock(current->group_leader);
 
 	posix_cpu_timers_init_group(sig);
@@ -1676,8 +1678,8 @@ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)
 	tty_audit_fork(sig);
 	sched_autogroup_fork(sig);
 
-	sig->oom_score_adj = current->signal->oom_score_adj;
-	sig->oom_score_adj_min = current->signal->oom_score_adj_min;
+	sig->oom_score_adj = sysiso_current->signal->oom_score_adj;
+	sig->oom_score_adj_min = sysiso_current->signal->oom_score_adj_min;
 
 	mutex_init(&sig->cred_guard_mutex);
 	init_rwsem(&sig->exec_update_lock);
@@ -1694,7 +1696,7 @@ static void copy_seccomp(struct task_struct *p)
 	 * needed because this new task is not yet running and cannot
 	 * be racing exec.
 	 */
-	assert_spin_locked(&current->sighand->siglock);
+	assert_spin_locked(&sysiso_current->sighand->siglock);
 
 	/* Ref-count the new filter user, and assign it. */
 	get_seccomp_filter(current);
@@ -1722,7 +1724,7 @@ SYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)
 {
 	current->clear_child_tid = tidptr;
 
-	return task_pid_vnr(current);
+	return task_pid_vnr(sysiso_current);
 }
 
 static void rt_mutex_init_task(struct task_struct *p)
@@ -1914,8 +1916,8 @@ static void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)
 	mutex_lock(&oom_adj_mutex);
 	set_bit(MMF_MULTIPROCESS, &tsk->mm->flags);
 	/* Update the values in case they were changed after copy_signal */
-	tsk->signal->oom_score_adj = current->signal->oom_score_adj;
-	tsk->signal->oom_score_adj_min = current->signal->oom_score_adj_min;
+	tsk->signal->oom_score_adj = sysiso_current->signal->oom_score_adj;
+	tsk->signal->oom_score_adj_min = sysiso_current->signal->oom_score_adj_min;
 	mutex_unlock(&oom_adj_mutex);
 }
 
@@ -1938,7 +1940,7 @@ static __latent_entropy struct task_struct *copy_process(
 	struct multiprocess_signals delayed;
 	struct file *pidfile = NULL;
 	u64 clone_flags = args->flags;
-	struct nsproxy *nsp = current->nsproxy;
+	struct nsproxy *nsp = sysiso_current->nsproxy;
 
 	/*
 	 * Don't allow sharing the root directory with processes in a different
@@ -1972,7 +1974,7 @@ static __latent_entropy struct task_struct *copy_process(
 	 * from creating siblings.
 	 */
 	if ((clone_flags & CLONE_PARENT) &&
-				current->signal->flags & SIGNAL_UNKILLABLE)
+				sysiso_current->signal->flags & SIGNAL_UNKILLABLE)
 		return ERR_PTR(-EINVAL);
 
 	/*
@@ -1981,7 +1983,7 @@ static __latent_entropy struct task_struct *copy_process(
 	 */
 	if (clone_flags & CLONE_THREAD) {
 		if ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||
-		    (task_active_pid_ns(current) != nsp->pid_ns_for_children))
+		    (task_active_pid_ns(sysiso_current) != nsp->pid_ns_for_children))
 			return ERR_PTR(-EINVAL);
 	}
 
@@ -2013,11 +2015,11 @@ static __latent_entropy struct task_struct *copy_process(
 	sigemptyset(&delayed.signal);
 	INIT_HLIST_NODE(&delayed.node);
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	if (!(clone_flags & CLONE_THREAD))
 		hlist_add_head(&delayed.node, &current->signal->multiprocess);
 	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 	retval = -ERESTARTNOINTR;
 	if (task_sigpending(current))
 		goto fork_out;
@@ -2061,7 +2063,7 @@ static __latent_entropy struct task_struct *copy_process(
 		    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))
 			goto bad_fork_free;
 	}
-	current->flags &= ~PF_NPROC_EXCEEDED;
+	sysiso_current->flags &= ~PF_NPROC_EXCEEDED;
 
 	retval = copy_creds(p, clone_flags);
 	if (retval < 0)
@@ -2107,7 +2109,7 @@ static __latent_entropy struct task_struct *copy_process(
 	memset(&p->rss_stat, 0, sizeof(p->rss_stat));
 #endif
 
-	p->default_timer_slack_ns = current->timer_slack_ns;
+	p->default_timer_slack_ns = sysiso_current->timer_slack_ns;
 
 #ifdef CONFIG_PSI
 	p->psi_flags = 0;
@@ -2267,7 +2269,7 @@ static __latent_entropy struct task_struct *copy_process(
 	p->pid = pid_nr(pid);
 	if (clone_flags & CLONE_THREAD) {
 		p->group_leader = current->group_leader;
-		p->tgid = current->tgid;
+		p->tgid = sysiso_current->tgid;
 	} else {
 		p->group_leader = p;
 		p->tgid = p->pid;
@@ -2285,6 +2287,12 @@ static __latent_entropy struct task_struct *copy_process(
 	p->kretprobe_instances.first = NULL;
 #endif
 
+#ifdef CONFIG_SYSISO
+	if (sysiso_task_is_client(p)) {
+		sysiso_client_enable(p);
+	}
+#endif
+
 	/*
 	 * Ensure that the cgroup subsystem policies allow the new process to be
 	 * forked. It should be noted that the new process's css_set can be changed
@@ -2314,7 +2322,7 @@ static __latent_entropy struct task_struct *copy_process(
 
 	/* CLONE_PARENT re-uses the old parent */
 	if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
-		p->real_parent = current->real_parent;
+		p->real_parent = sysiso_current->real_parent;
 		p->parent_exec_id = current->parent_exec_id;
 		if (clone_flags & CLONE_THREAD)
 			p->exit_signal = -1;
@@ -2330,7 +2338,7 @@ static __latent_entropy struct task_struct *copy_process(
 
 	sched_core_fork(p);
 
-	spin_lock(&current->sighand->siglock);
+	spin_lock(&sysiso_current->sighand->siglock);
 
 	/*
 	 * Copy seccomp details explicitly here, in case they were changed
@@ -2347,7 +2355,7 @@ static __latent_entropy struct task_struct *copy_process(
 	}
 
 	/* Let kill terminate clone/fork in the middle */
-	if (fatal_signal_pending(current)) {
+	if (fatal_signal_pending(sysiso_current)) {
 		retval = -EINTR;
 		goto bad_fork_cancel_cgroup;
 	}
@@ -2363,15 +2371,15 @@ static __latent_entropy struct task_struct *copy_process(
 		init_task_pid(p, PIDTYPE_PID, pid);
 		if (thread_group_leader(p)) {
 			init_task_pid(p, PIDTYPE_TGID, pid);
-			init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));
-			init_task_pid(p, PIDTYPE_SID, task_session(current));
+			init_task_pid(p, PIDTYPE_PGID, task_pgrp(sysiso_current));
+			init_task_pid(p, PIDTYPE_SID, task_session(sysiso_current));
 
 			if (is_child_reaper(pid)) {
 				ns_of_pid(pid)->child_reaper = p;
 				p->signal->flags |= SIGNAL_UNKILLABLE;
 			}
 			p->signal->shared_pending.signal = delayed.signal;
-			p->signal->tty = tty_kref_get(current->signal->tty);
+			p->signal->tty = tty_kref_get(sysiso_current->signal->tty);
 			/*
 			 * Inherit has_child_subreaper flag under the same
 			 * tasklist_lock with adding child to the process tree
@@ -2400,7 +2408,7 @@ static __latent_entropy struct task_struct *copy_process(
 	}
 	total_forks++;
 	hlist_del_init(&delayed.node);
-	spin_unlock(&current->sighand->siglock);
+	spin_unlock(&sysiso_current->sighand->siglock);
 	syscall_tracepoint_update(p);
 	write_unlock_irq(&tasklist_lock);
 
@@ -2418,7 +2426,7 @@ static __latent_entropy struct task_struct *copy_process(
 
 bad_fork_cancel_cgroup:
 	sched_core_free(p);
-	spin_unlock(&current->sighand->siglock);
+	spin_unlock(&sysiso_current->sighand->siglock);
 	write_unlock_irq(&tasklist_lock);
 	cgroup_cancel_fork(p, args);
 bad_fork_put_pidfd:
@@ -2473,9 +2481,9 @@ static __latent_entropy struct task_struct *copy_process(
 	put_task_stack(p);
 	delayed_free_task(p);
 fork_out:
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	hlist_del_init(&delayed.node);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 	return ERR_PTR(retval);
 }
 
@@ -2981,7 +2989,7 @@ static int check_unshare_flags(unsigned long unshare_flags)
  */
 static int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)
 {
-	struct fs_struct *fs = current->fs;
+	struct fs_struct *fs = sysiso_current->fs;
 
 	if (!(unshare_flags & CLONE_FS) || !fs)
 		return 0;
@@ -3003,7 +3011,7 @@ static int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)
 int unshare_fd(unsigned long unshare_flags, unsigned int max_fds,
 	       struct files_struct **new_fdp)
 {
-	struct files_struct *fd = current->files;
+	struct files_struct *fd = sysiso_current->files;
 	int error = 0;
 
 	if ((unshare_flags & CLONE_FILES) &&
@@ -3104,9 +3112,9 @@ int ksys_unshare(unsigned long unshare_flags)
 		task_lock(current);
 
 		if (new_fs) {
-			fs = current->fs;
+			fs = sysiso_current->fs;
 			spin_lock(&fs->lock);
-			current->fs = new_fs;
+			sysiso_current->fs = new_fs;
 			if (--fs->users)
 				new_fs = NULL;
 			else
@@ -3115,8 +3123,8 @@ int ksys_unshare(unsigned long unshare_flags)
 		}
 
 		if (new_fd) {
-			fd = current->files;
-			current->files = new_fd;
+			fd = sysiso_current->files;
+			sysiso_current->files = new_fd;
 			new_fd = fd;
 		}
 
@@ -3159,7 +3167,7 @@ SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
 
 int unshare_files(void)
 {
-	struct task_struct *task = current;
+	struct task_struct *task = sysiso_current;
 	struct files_struct *old, *copy = NULL;
 	int error;
 
diff --git a/kernel/freezer.c b/kernel/freezer.c
index 45ab36ffd..59593eaec 100644
--- a/kernel/freezer.c
+++ b/kernel/freezer.c
@@ -60,25 +60,25 @@ bool __refrigerator(bool check_kthr_stop)
 	bool was_frozen = false;
 	unsigned int save = get_current_state();
 
-	pr_debug("%s entered refrigerator\n", current->comm);
+	pr_debug("%s entered refrigerator\n", sysiso_current->comm);
 
 	for (;;) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 
 		spin_lock_irq(&freezer_lock);
-		current->flags |= PF_FROZEN;
-		if (!freezing(current) ||
+		sysiso_current->flags |= PF_FROZEN;
+		if (!freezing(sysiso_current) ||
 		    (check_kthr_stop && kthread_should_stop()))
-			current->flags &= ~PF_FROZEN;
+			sysiso_current->flags &= ~PF_FROZEN;
 		spin_unlock_irq(&freezer_lock);
 
-		if (!(current->flags & PF_FROZEN))
+		if (!(sysiso_current->flags & PF_FROZEN))
 			break;
 		was_frozen = true;
 		schedule();
 	}
 
-	pr_debug("%s left refrigerator\n", current->comm);
+	pr_debug("%s left refrigerator\n", sysiso_current->comm);
 
 	/*
 	 * Restore saved task state before returning.  The mb'd version
@@ -168,7 +168,7 @@ bool set_freezable(void)
 	 * condition is visible to try_to_freeze() below.
 	 */
 	spin_lock_irq(&freezer_lock);
-	current->flags &= ~PF_NOFREEZE;
+	sysiso_current->flags &= ~PF_NOFREEZE;
 	spin_unlock_irq(&freezer_lock);
 
 	return try_to_freeze();
diff --git a/kernel/futex.c b/kernel/futex.c
index c15ad276f..7300066c0 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -1703,7 +1703,7 @@ static int futex_atomic_op_inuser(unsigned int encoded_op, u32 __user *uaddr)
 
 	if (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {
 		if (oparg < 0 || oparg > 31) {
-			char comm[sizeof(current->comm)];
+			char comm[sizeof(sysiso_current->comm)];
 			/*
 			 * kill this print and return -EINVAL when userspace
 			 * is sane again
@@ -2940,7 +2940,7 @@ static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,
 	q.bitset = bitset;
 
 	to = futex_setup_timer(abs_time, &timeout, flags,
-			       current->timer_slack_ns);
+			       sysiso_current->timer_slack_ns);
 retry:
 	/*
 	 * Prepare to wait on uaddr. On success, it holds hb->lock and q
@@ -2962,17 +2962,17 @@ static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,
 		goto out;
 
 	/*
-	 * We expect signal_pending(current), but we might be the
+	 * We expect signal_pending(sysiso_current), but we might be the
 	 * victim of a spurious wakeup as well.
 	 */
-	if (!signal_pending(current))
+	if (!signal_pending(sysiso_current))
 		goto retry;
 
 	ret = -ERESTARTSYS;
 	if (!abs_time)
 		goto out;
 
-	restart = &current->restart_block;
+	restart = &sysiso_current->restart_block;
 	restart->futex.uaddr = uaddr;
 	restart->futex.val = val;
 	restart->futex.time = *abs_time;
@@ -3188,7 +3188,7 @@ static int futex_lock_pi(u32 __user *uaddr, unsigned int flags,
  */
 static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)
 {
-	u32 curval, uval, vpid = task_pid_vnr(current);
+	u32 curval, uval, vpid = task_pid_vnr(sysiso_current);
 	union futex_key key = FUTEX_KEY_INIT;
 	struct futex_hash_bucket *hb;
 	struct futex_q *top_waiter;
@@ -3358,7 +3358,7 @@ int handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,
 	ret = -EWOULDBLOCK;
 	if (timeout && !timeout->task)
 		ret = -ETIMEDOUT;
-	else if (signal_pending(current))
+	else if (signal_pending(sysiso_current))
 		ret = -ERESTARTNOINTR;
 	return ret;
 }
@@ -3425,7 +3425,7 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		return -EINVAL;
 
 	to = futex_setup_timer(abs_time, &timeout, flags,
-			       current->timer_slack_ns);
+			       sysiso_current->timer_slack_ns);
 
 	/*
 	 * The waiter is allocated on our stack, manipulated by the requeue
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 27667e82e..8027b64f0 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1211,11 +1211,11 @@ static void wake_threads_waitq(struct irq_desc *desc)
 
 static void irq_thread_dtor(struct callback_head *unused)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	struct irq_desc *desc;
 	struct irqaction *action;
 
-	if (WARN_ON_ONCE(!(current->flags & PF_EXITING)))
+	if (WARN_ON_ONCE(!(sysiso_current->flags & PF_EXITING)))
 		return;
 
 	action = kthread_data(tsk);
diff --git a/kernel/kcsan/permissive.h b/kernel/kcsan/permissive.h
index 2c01fe4a5..ee71ac0f4 100644
--- a/kernel/kcsan/permissive.h
+++ b/kernel/kcsan/permissive.h
@@ -25,7 +25,7 @@ static __always_inline bool kcsan_ignore_address(const volatile void *ptr)
 		return false;
 
 	/*
-	 * Data-racy bitops on current->flags are too common, ignore completely
+	 * Data-racy bitops on sysiso_current->flags are too common, ignore completely
 	 * for now.
 	 */
 	return ptr == &current->flags;
diff --git a/kernel/kcsan/report.c b/kernel/kcsan/report.c
index 21137929d..5bd383299 100644
--- a/kernel/kcsan/report.c
+++ b/kernel/kcsan/report.c
@@ -582,7 +582,7 @@ static struct access_info prepare_access_info(const volatile void *ptr, size_t s
 		.ptr		= ptr,
 		.size		= size,
 		.access_type	= access_type,
-		.task_pid	= in_task() ? task_pid_nr(current) : -1,
+		.task_pid	= in_task() ? task_pid_nr(sysiso_current) : -1,
 		.cpu_id		= raw_smp_processor_id()
 	};
 }
diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c
index 5a5d192a8..ccdb93626 100644
--- a/kernel/kexec_core.c
+++ b/kernel/kexec_core.c
@@ -301,7 +301,7 @@ static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)
 {
 	struct page *pages;
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return NULL;
 	pages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);
 	if (pages) {
@@ -1077,7 +1077,7 @@ void crash_save_cpu(struct pt_regs *regs, int cpu)
 	if (!buf)
 		return;
 	memset(&prstatus, 0, sizeof(prstatus));
-	prstatus.common.pr_pid = current->pid;
+	prstatus.common.pr_pid = sysiso_current->pid;
 	elf_core_copy_kernel_regs(&prstatus.pr_reg, regs);
 	buf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,
 			      &prstatus, sizeof(prstatus));
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 5b37a8567..0277b2e4f 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -175,7 +175,7 @@ bool kthread_freezable_should_stop(bool *was_frozen)
 
 	might_sleep();
 
-	if (unlikely(freezing(current)))
+	if (unlikely(freezing(sysiso_current)))
 		frozen = __refrigerator(true);
 
 	if (was_frozen)
@@ -420,7 +420,7 @@ struct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),
 
 /**
  * kthread_create_on_node - create a kthread.
- * @threadfn: the function to run until signal_pending(current).
+ * @threadfn: the function to run until signal_pending(sysiso_current).
  * @data: data ptr for @threadfn.
  * @node: task and thread structures for the thread are allocated on this node
  * @namefmt: printf-style name for the thread.
@@ -500,7 +500,7 @@ EXPORT_SYMBOL(kthread_bind);
 
 /**
  * kthread_create_on_cpu - Create a cpu bound kthread
- * @threadfn: the function to run until signal_pending(current).
+ * @threadfn: the function to run until signal_pending(sysiso_current).
  * @data: data ptr for @threadfn.
  * @cpu: The cpu on which the thread should be bound,
  * @namefmt: printf-style name for the thread. Format is restricted
@@ -664,7 +664,7 @@ int kthreadd(void *unused)
 	set_cpus_allowed_ptr(tsk, housekeeping_cpumask(HK_FLAG_KTHREAD));
 	set_mems_allowed(node_states[N_MEMORY]);
 
-	current->flags |= PF_NOFREEZE;
+	sysiso_current->flags |= PF_NOFREEZE;
 	cgroup_init_kthreadd();
 
 	for (;;) {
@@ -765,7 +765,7 @@ int kthread_worker_fn(void *worker_ptr)
 		 * event only cares about the address.
 		 */
 		trace_sched_kthread_work_execute_end(work, func);
-	} else if (!freezing(current))
+	} else if (!freezing(sysiso_current))
 		schedule();
 
 	try_to_freeze();
@@ -1433,7 +1433,7 @@ void kthread_associate_blkcg(struct cgroup_subsys_state *css)
 {
 	struct kthread *kthread;
 
-	if (!(current->flags & PF_KTHREAD))
+	if (!(sysiso_current->flags & PF_KTHREAD))
 		return;
 	kthread = to_kthread(current);
 	if (!kthread)
@@ -1459,7 +1459,7 @@ struct cgroup_subsys_state *kthread_blkcg(void)
 {
 	struct kthread *kthread;
 
-	if (current->flags & PF_KTHREAD) {
+	if (sysiso_current->flags & PF_KTHREAD) {
 		kthread = to_kthread(current);
 		if (kthread)
 			return kthread->blkcg_css;
diff --git a/kernel/locking/lockdep.c b/kernel/locking/lockdep.c
index bf1c00c88..332a80693 100644
--- a/kernel/locking/lockdep.c
+++ b/kernel/locking/lockdep.c
@@ -1885,7 +1885,7 @@ print_circular_bug_header(struct lock_list *entry, unsigned int depth,
 			struct held_lock *check_src,
 			struct held_lock *check_tgt)
 {
-	struct task_struct *curr = current;
+	struct task_struct *curr = sysiso_current;
 
 	if (debug_locks_silent)
 		return;
@@ -3532,7 +3532,7 @@ static void print_collision(struct task_struct *curr,
 	pr_warn("WARNING: chain_key collision\n");
 	print_kernel_ident();
 	pr_warn("----------------------------\n");
-	pr_warn("%s/%d: ", current->comm, task_pid_nr(current));
+	pr_warn("%s/%d: ", sysiso_current->comm, task_pid_nr(sysiso_current));
 	pr_warn("Hash chain already cached but the contents don't match!\n");
 
 	pr_warn("Held locks:");
@@ -6423,7 +6423,7 @@ static void print_held_locks_bug(void)
 	pr_warn("\n");
 	pr_warn("====================================\n");
 	pr_warn("WARNING: %s/%d still has locks held!\n",
-	       current->comm, task_pid_nr(current));
+	       sysiso_current->comm, task_pid_nr(sysiso_current));
 	print_kernel_ident();
 	pr_warn("------------------------------------\n");
 	lockdep_print_held_locks(current);
diff --git a/kernel/locking/mutex.c b/kernel/locking/mutex.c
index d456579d0..23add9037 100644
--- a/kernel/locking/mutex.c
+++ b/kernel/locking/mutex.c
@@ -654,7 +654,7 @@ __mutex_lock_common(struct mutex *lock, unsigned int state, unsigned int subclas
 		 * wait_lock. This ensures the lock cancellation is ordered
 		 * against mutex_unlock() and wake-ups do not go missing.
 		 */
-		if (signal_pending_state(state, current)) {
+		if (signal_pending_state(state, sysiso_current)) {
 			ret = -EINTR;
 			goto err;
 		}
diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
index 6bb116c55..6e0f13868 100644
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -1184,7 +1184,7 @@ static void __sched mark_wakeup_next_waiter(struct rt_wake_q_head *wqh,
 {
 	struct rt_mutex_waiter *waiter;
 
-	raw_spin_lock(&current->pi_lock);
+	raw_spin_lock(&sysiso_current->pi_lock);
 
 	waiter = rt_mutex_top_waiter(lock);
 
@@ -1220,7 +1220,7 @@ static void __sched mark_wakeup_next_waiter(struct rt_wake_q_head *wqh,
 	 */
 	preempt_disable();
 	rt_mutex_wake_q_add(wqh, waiter);
-	raw_spin_unlock(&current->pi_lock);
+	raw_spin_unlock(&sysiso_current->pi_lock);
 }
 
 static int __sched __rt_mutex_slowtrylock(struct rt_mutex_base *lock)
@@ -1414,10 +1414,10 @@ static void __sched remove_waiter(struct rt_mutex_base *lock,
 
 	lockdep_assert_held(&lock->wait_lock);
 
-	raw_spin_lock(&current->pi_lock);
+	raw_spin_lock(&sysiso_current->pi_lock);
 	rt_mutex_dequeue(lock, waiter);
-	current->pi_blocked_on = NULL;
-	raw_spin_unlock(&current->pi_lock);
+	sysiso_current->pi_blocked_on = NULL;
+	raw_spin_unlock(&sysiso_current->pi_lock);
 
 	/*
 	 * Only update priority if the waiter was the highest priority
@@ -1488,7 +1488,7 @@ static int __sched rt_mutex_slowlock_block(struct rt_mutex_base *lock,
 			ret = -ETIMEDOUT;
 			break;
 		}
-		if (signal_pending_state(state, current)) {
+		if (signal_pending_state(state, sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
diff --git a/kernel/locking/rwbase_rt.c b/kernel/locking/rwbase_rt.c
index 88191f6e2..f911d78bc 100644
--- a/kernel/locking/rwbase_rt.c
+++ b/kernel/locking/rwbase_rt.c
@@ -246,7 +246,7 @@ static int __sched rwbase_write_lock(struct rwbase_rt *rwb,
 	rwbase_set_and_save_current_state(state);
 	for (;;) {
 		/* Optimized out for rwlocks */
-		if (rwbase_signal_pending_state(state, current)) {
+		if (rwbase_signal_pending_state(state, sysiso_current)) {
 			rwbase_restore_current_state();
 			__rwbase_write_unlock(rwb, 0, flags);
 			return -EINTR;
diff --git a/kernel/locking/rwsem.c b/kernel/locking/rwsem.c
index 000e8d5a2..f75812f28 100644
--- a/kernel/locking/rwsem.c
+++ b/kernel/locking/rwsem.c
@@ -982,7 +982,7 @@ rwsem_down_read_slowpath(struct rw_semaphore *sem, long count, unsigned int stat
 			/* Matches rwsem_mark_wake()'s smp_store_release(). */
 			break;
 		}
-		if (signal_pending_state(state, current)) {
+		if (signal_pending_state(state, sysiso_current)) {
 			raw_spin_lock_irq(&sem->wait_lock);
 			if (waiter.task)
 				goto out_nolock;
@@ -1101,7 +1101,7 @@ rwsem_down_write_slowpath(struct rw_semaphore *sem, int state)
 
 		/* Block until there are no active lockers. */
 		for (;;) {
-			if (signal_pending_state(state, current))
+			if (signal_pending_state(state, sysiso_current))
 				goto out_nolock;
 
 			schedule();
@@ -1368,8 +1368,8 @@ static inline void __downgrade_write(struct rw_semaphore *sem)
 #define rwbase_rtmutex_trylock(rtm)			\
 	__rt_mutex_trylock(rtm)
 
-#define rwbase_signal_pending_state(state, current)	\
-	signal_pending_state(state, current)
+#define rwbase_signal_pending_state(state, sysiso_current)	\
+	signal_pending_state(state, sysiso_current)
 
 #define rwbase_schedule()				\
 	schedule()
diff --git a/kernel/locking/semaphore.c b/kernel/locking/semaphore.c
index 9ee381e4d..4fc24be58 100644
--- a/kernel/locking/semaphore.c
+++ b/kernel/locking/semaphore.c
@@ -215,7 +215,7 @@ static inline int __sched __down_common(struct semaphore *sem, long state,
 	waiter.up = false;
 
 	for (;;) {
-		if (signal_pending_state(state, current))
+		if (signal_pending_state(state, sysiso_current))
 			goto interrupted;
 		if (unlikely(timeout <= 0))
 			goto timed_out;
diff --git a/kernel/locking/spinlock_debug.c b/kernel/locking/spinlock_debug.c
index 14235671a..6a0eb6ca8 100644
--- a/kernel/locking/spinlock_debug.c
+++ b/kernel/locking/spinlock_debug.c
@@ -59,7 +59,7 @@ static void spin_dump(raw_spinlock_t *lock, const char *msg)
 		owner = NULL;
 	printk(KERN_EMERG "BUG: spinlock %s on CPU#%d, %s/%d\n",
 		msg, raw_smp_processor_id(),
-		current->comm, task_pid_nr(current));
+		sysiso_current->comm, task_pid_nr(sysiso_current));
 	printk(KERN_EMERG " lock: %pS, .magic: %08x, .owner: %s/%d, "
 			".owner_cpu: %d\n",
 		lock, READ_ONCE(lock->magic),
@@ -148,8 +148,8 @@ static void rwlock_bug(rwlock_t *lock, const char *msg)
 		return;
 
 	printk(KERN_EMERG "BUG: rwlock %s on CPU#%d, %s/%d, %p\n",
-		msg, raw_smp_processor_id(), current->comm,
-		task_pid_nr(current), lock);
+		msg, raw_smp_processor_id(), sysiso_current->comm,
+		task_pid_nr(sysiso_current), lock);
 	dump_stack();
 }
 
diff --git a/kernel/locking/spinlock_rt.c b/kernel/locking/spinlock_rt.c
index d2912e44d..03d5c0eea 100644
--- a/kernel/locking/spinlock_rt.c
+++ b/kernel/locking/spinlock_rt.c
@@ -171,7 +171,7 @@ static __always_inline int  rwbase_rtmutex_trylock(struct rt_mutex_base *rtm)
 	return rt_mutex_slowtrylock(rtm);
 }
 
-#define rwbase_signal_pending_state(state, current)	(0)
+#define rwbase_signal_pending_state(state, sysiso_current)	(0)
 
 #define rwbase_schedule()				\
 	schedule_rtlock()
diff --git a/kernel/module.c b/kernel/module.c
index 5c26a76e8..2b798b50f 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -3687,7 +3687,7 @@ static noinline int do_init_module(struct module *mod)
 	 * We want to find out whether @mod uses async during init.  Clear
 	 * PF_USED_ASYNC.  async_schedule*() will set it.
 	 */
-	current->flags &= ~PF_USED_ASYNC;
+	sysiso_current->flags &= ~PF_USED_ASYNC;
 
 	do_mod_ctors(mod);
 	/* Start the module */
@@ -3729,7 +3729,7 @@ static noinline int do_init_module(struct module *mod)
 	 *
 	 * http://thread.gmane.org/gmane.linux.kernel/1420814
 	 */
-	if (!mod->async_probe_requested && (current->flags & PF_USED_ASYNC))
+	if (!mod->async_probe_requested && (sysiso_current->flags & PF_USED_ASYNC))
 		async_synchronize_full();
 
 	ftrace_free_mem(mod, mod->init_layout.base, mod->init_layout.base +
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index eec72ca96..b1532dec3 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -224,7 +224,7 @@ int unshare_nsproxy_namespaces(unsigned long unshare_flags,
 		return -EPERM;
 
 	*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,
-					 new_fs ? new_fs : current->fs);
+					 new_fs ? new_fs : sysiso_current->fs);
 	if (IS_ERR(*new_nsp)) {
 		err = PTR_ERR(*new_nsp);
 		goto out;
@@ -311,7 +311,7 @@ static void put_nsset(struct nsset *nsset)
 
 static int prepare_nsset(unsigned flags, struct nsset *nsset)
 {
-	struct task_struct *me = current;
+	struct task_struct *me = sysiso_current;
 
 	nsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);
 	if (IS_ERR(nsset->nsproxy))
diff --git a/kernel/panic.c b/kernel/panic.c
index cefd7d823..2f85dcf25 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -578,11 +578,12 @@ void __warn(const char *file, int line, void *caller, unsigned taint,
 
 	if (file)
 		pr_warn("WARNING: CPU: %d PID: %d at %s:%d %pS\n",
-			raw_smp_processor_id(), current->pid, file, line,
+			raw_smp_processor_id(), sysiso_current->pid, file,
+			line,
 			caller);
 	else
 		pr_warn("WARNING: CPU: %d PID: %d at %pS\n",
-			raw_smp_processor_id(), current->pid, caller);
+			raw_smp_processor_id(), sysiso_current->pid, caller);
 
 	if (args)
 		vprintk(args->fmt, args->args);
diff --git a/kernel/pid.c b/kernel/pid.c
index efe87db44..bf9c0617d 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -314,7 +314,7 @@ EXPORT_SYMBOL_GPL(find_pid_ns);
 
 struct pid *find_vpid(int nr)
 {
-	return find_pid_ns(nr, task_active_pid_ns(current));
+	return find_pid_ns(nr, task_active_pid_ns(sysiso_current));
 }
 EXPORT_SYMBOL_GPL(find_vpid);
 
@@ -419,7 +419,7 @@ struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
 
 struct task_struct *find_task_by_vpid(pid_t vnr)
 {
-	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
+	return find_task_by_pid_ns(vnr, task_active_pid_ns(sysiso_current));
 }
 
 struct task_struct *find_get_task_by_vpid(pid_t nr)
@@ -485,7 +485,7 @@ EXPORT_SYMBOL_GPL(pid_nr_ns);
 
 pid_t pid_vnr(struct pid *pid)
 {
-	return pid_nr_ns(pid, task_active_pid_ns(current));
+	return pid_nr_ns(pid, task_active_pid_ns(sysiso_current));
 }
 EXPORT_SYMBOL_GPL(pid_vnr);
 
@@ -496,7 +496,7 @@ pid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,
 
 	rcu_read_lock();
 	if (!ns)
-		ns = task_active_pid_ns(current);
+		ns = task_active_pid_ns(sysiso_current);
 	nr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);
 	rcu_read_unlock();
 
diff --git a/kernel/pid_namespace.c b/kernel/pid_namespace.c
index a46a3723b..74a2a3486 100644
--- a/kernel/pid_namespace.c
+++ b/kernel/pid_namespace.c
@@ -144,7 +144,7 @@ struct pid_namespace *copy_pid_ns(unsigned long flags,
 {
 	if (!(flags & CLONE_NEWPID))
 		return get_pid_ns(old_ns);
-	if (task_active_pid_ns(current) != old_ns)
+	if (task_active_pid_ns(sysiso_current) != old_ns)
 		return ERR_PTR(-EINVAL);
 	return create_pid_namespace(user_ns, old_ns);
 }
@@ -249,7 +249,7 @@ void zap_pid_ns_processes(struct pid_namespace *pid_ns)
 	__set_current_state(TASK_RUNNING);
 
 	if (pid_ns->reboot)
-		current->signal->group_exit_code = pid_ns->reboot;
+		sysiso_current->signal->group_exit_code = pid_ns->reboot;
 
 	acct_exit_ns(pid_ns);
 	return;
@@ -259,7 +259,7 @@ void zap_pid_ns_processes(struct pid_namespace *pid_ns)
 static int pid_ns_ctl_handler(struct ctl_table *table, int write,
 		void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct pid_namespace *pid_ns = task_active_pid_ns(current);
+	struct pid_namespace *pid_ns = task_active_pid_ns(sysiso_current);
 	struct ctl_table tmp = *table;
 	int ret, next;
 
@@ -375,7 +375,7 @@ static void pidns_put(struct ns_common *ns)
 static int pidns_install(struct nsset *nsset, struct ns_common *ns)
 {
 	struct nsproxy *nsproxy = nsset->nsproxy;
-	struct pid_namespace *active = task_active_pid_ns(current);
+	struct pid_namespace *active = task_active_pid_ns(sysiso_current);
 	struct pid_namespace *ancestor, *new = to_pid_ns(ns);
 
 	if (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||
@@ -406,7 +406,7 @@ static int pidns_install(struct nsset *nsset, struct ns_common *ns)
 
 static struct ns_common *pidns_get_parent(struct ns_common *ns)
 {
-	struct pid_namespace *active = task_active_pid_ns(current);
+	struct pid_namespace *active = task_active_pid_ns(sysiso_current);
 	struct pid_namespace *pid_ns, *p;
 
 	/* See if the parent is in the current namespace */
diff --git a/kernel/power/main.c b/kernel/power/main.c
index 44169f308..a46a030b3 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -23,7 +23,7 @@
 
 void lock_system_sleep(void)
 {
-	current->flags |= PF_FREEZER_SKIP;
+	sysiso_current->flags |= PF_FREEZER_SKIP;
 	mutex_lock(&system_transition_mutex);
 }
 EXPORT_SYMBOL_GPL(lock_system_sleep);
@@ -46,7 +46,7 @@ void unlock_system_sleep(void)
 	 * Which means, if we use try_to_freeze() here, it would make them
 	 * enter the refrigerator, thus causing hibernation to lockup.
 	 */
-	current->flags &= ~PF_FREEZER_SKIP;
+	sysiso_current->flags &= ~PF_FREEZER_SKIP;
 	mutex_unlock(&system_transition_mutex);
 }
 EXPORT_SYMBOL_GPL(unlock_system_sleep);
diff --git a/kernel/power/process.c b/kernel/power/process.c
index 37401c99b..726d0c19a 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -129,7 +129,7 @@ int freeze_processes(void)
 		return error;
 
 	/* Make sure this task doesn't get frozen */
-	current->flags |= PF_SUSPEND_TASK;
+	sysiso_current->flags |= PF_SUSPEND_TASK;
 
 	if (!pm_freezing)
 		atomic_inc(&system_freezing_cnt);
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a8d0a58de..72a6e5a18 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -533,7 +533,7 @@ static int check_syslog_permissions(int type, int source)
 			pr_warn_once("%s (%d): Attempt to access syslog with "
 				     "CAP_SYS_ADMIN but no CAP_SYSLOG "
 				     "(deprecated).\n",
-				 current->comm, task_pid_nr(current));
+				 sysiso_current->comm, task_pid_nr(sysiso_current));
 			goto ok;
 		}
 		return -EPERM;
@@ -669,7 +669,7 @@ static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 
 	/* Ratelimit when not explicitly enabled. */
 	if (!(devkmsg_log & DEVKMSG_LOG_MASK_ON)) {
-		if (!___ratelimit(&user->rs, current->comm))
+		if (!___ratelimit(&user->rs, sysiso_current->comm))
 			return ret;
 	}
 
@@ -2017,7 +2017,7 @@ static inline void printk_delay(void)
 
 static inline u32 printk_caller_id(void)
 {
-	return in_task() ? task_pid_nr(current) :
+	return in_task() ? task_pid_nr(sysiso_current) :
 		0x80000000 + raw_smp_processor_id();
 }
 
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index f8589bf8d..559425465 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -311,7 +311,7 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	 */
 
 	/* Don't let security modules deny introspection */
-	if (same_thread_group(task, current))
+	if (same_thread_group(task, sysiso_current))
 		return 0;
 	rcu_read_lock();
 	if (mode & PTRACE_MODE_FSCREDS) {
@@ -394,7 +394,7 @@ static int ptrace_attach(struct task_struct *task, long request,
 	retval = -EPERM;
 	if (unlikely(task->flags & PF_KTHREAD))
 		goto out;
-	if (same_thread_group(task, current))
+	if (same_thread_group(task, sysiso_current))
 		goto out;
 
 	/*
@@ -496,7 +496,7 @@ static int ptrace_traceme(void)
 		 */
 		if (!ret && !(current->real_parent->flags & PF_EXITING)) {
 			current->ptrace = PT_PTRACED;
-			ptrace_link(current, current->real_parent);
+			ptrace_link(current, sysiso_current->real_parent);
 		}
 	}
 	write_unlock_irq(&tasklist_lock);
@@ -784,7 +784,7 @@ static int ptrace_peek_siginfo(struct task_struct *child,
 		data += sizeof(siginfo_t);
 		i++;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		cond_resched();
diff --git a/kernel/rcu/rcutorture.c b/kernel/rcu/rcutorture.c
index ab4215266..73bf02be1 100644
--- a/kernel/rcu/rcutorture.c
+++ b/kernel/rcu/rcutorture.c
@@ -777,7 +777,8 @@ static void synchronize_rcu_trivial(void)
 	int cpu;
 
 	for_each_online_cpu(cpu) {
-		rcutorture_sched_setaffinity(current->pid, cpumask_of(cpu));
+		rcutorture_sched_setaffinity(sysiso_current->pid,
+					     cpumask_of(cpu));
 		WARN_ON_ONCE(raw_smp_processor_id() != cpu);
 	}
 }
@@ -1458,10 +1459,10 @@ static void rcutorture_one_extend(int *readstate, int newstate,
 		bool lockit = !statesnew && !(torture_random(trsp) & 0xffff);
 
 		if (lockit)
-			raw_spin_lock_irqsave(&current->pi_lock, flags);
+			raw_spin_lock_irqsave(&sysiso_current->pi_lock, flags);
 		cur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);
 		if (lockit)
-			raw_spin_unlock_irqrestore(&current->pi_lock, flags);
+			raw_spin_unlock_irqrestore(&sysiso_current->pi_lock, flags);
 	}
 
 	/* Delay if neither beginning nor end and there was a change. */
diff --git a/kernel/rcu/tasks.h b/kernel/rcu/tasks.h
index 806160c44..5639dd8d8 100644
--- a/kernel/rcu/tasks.h
+++ b/kernel/rcu/tasks.h
@@ -211,7 +211,7 @@ static int __noreturn rcu_tasks_kthread(void *arg)
 			wait_event_interruptible(rtp->cbs_wq,
 						 READ_ONCE(rtp->cbs_head));
 			if (!rtp->cbs_head) {
-				WARN_ON(signal_pending(current));
+				WARN_ON(signal_pending(sysiso_current));
 				set_tasks_gp_state(rtp, RTGS_WAIT_WAIT_CBS);
 				schedule_timeout_idle(HZ/10);
 			}
@@ -353,7 +353,7 @@ static void rcu_tasks_wait_gp(struct rcu_tasks *rtp)
 		if (needreport)
 			lastreport = jiffies;
 		firstreport = true;
-		WARN_ON(signal_pending(current));
+		WARN_ON(signal_pending(sysiso_current));
 		set_tasks_gp_state(rtp, RTGS_SCAN_HOLDOUTS);
 		rtp->holdouts_func(&holdouts, needreport, &firstreport);
 	}
diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c
index bce848e50..e0faa7b02 100644
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@ -684,10 +684,10 @@ noinstr static void rcu_irq_work_resched(void)
 {
 	struct rcu_data *rdp = this_cpu_ptr(&rcu_data);
 
-	if (IS_ENABLED(CONFIG_GENERIC_ENTRY) && !(current->flags & PF_VCPU))
+	if (IS_ENABLED(CONFIG_GENERIC_ENTRY) && !(sysiso_current->flags & PF_VCPU))
 		return;
 
-	if (IS_ENABLED(CONFIG_KVM_XFER_TO_GUEST_WORK) && (current->flags & PF_VCPU))
+	if (IS_ENABLED(CONFIG_KVM_XFER_TO_GUEST_WORK) && (sysiso_current->flags & PF_VCPU))
 		return;
 
 	instrumentation_begin();
@@ -1984,7 +1984,7 @@ static noinline_for_stack void rcu_gp_fqs_loop(void)
 			/* Deal with stray signal. */
 			cond_resched_tasks_rcu_qs();
 			WRITE_ONCE(rcu_state.gp_activity, jiffies);
-			WARN_ON(signal_pending(current));
+			WARN_ON(signal_pending(sysiso_current));
 			trace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,
 					       TPS("fqswaitsig"));
 			ret = 1; /* Keep old FQS timing. */
@@ -2121,7 +2121,7 @@ static int __noreturn rcu_gp_kthread(void *unused)
 				break;
 			cond_resched_tasks_rcu_qs();
 			WRITE_ONCE(rcu_state.gp_activity, jiffies);
-			WARN_ON(signal_pending(current));
+			WARN_ON(signal_pending(sysiso_current));
 			trace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,
 					       TPS("reqwaitsig"));
 		}
diff --git a/kernel/rcu/tree_nocb.h b/kernel/rcu/tree_nocb.h
index 8fdf44f85..fdd6dcbf1 100644
--- a/kernel/rcu/tree_nocb.h
+++ b/kernel/rcu/tree_nocb.h
@@ -741,7 +741,7 @@ static void nocb_gp_wait(struct rcu_data *my_rdp)
 		raw_spin_unlock_irqrestore(&my_rdp->nocb_gp_lock, flags);
 	}
 	my_rdp->nocb_gp_seq = -1;
-	WARN_ON(signal_pending(current));
+	WARN_ON(signal_pending(sysiso_current));
 }
 
 /*
@@ -848,7 +848,7 @@ static void nocb_cb_wait(struct rcu_data *rdp)
 
 		// VVV Ensure CB invocation follows _sleep test.
 		if (smp_load_acquire(&rdp->nocb_cb_sleep)) { // ^^^
-			WARN_ON(signal_pending(current));
+			WARN_ON(signal_pending(sysiso_current));
 			trace_rcu_nocb_wake(rcu_state.name, rdp->cpu, TPS("WokeEmpty"));
 		}
 	} while (!nocb_cb_can_run(rdp));
@@ -1303,7 +1303,7 @@ static void __init rcu_organize_nocb_kthreads(void)
 void rcu_bind_current_to_nocb(void)
 {
 	if (cpumask_available(rcu_nocb_mask) && cpumask_weight(rcu_nocb_mask))
-		WARN_ON(sched_setaffinity(current->pid, rcu_nocb_mask));
+		WARN_ON(sched_setaffinity(sysiso_current->pid, rcu_nocb_mask));
 }
 EXPORT_SYMBOL_GPL(rcu_bind_current_to_nocb);
 
diff --git a/kernel/reboot.c b/kernel/reboot.c
index f7440c0c7..3477f73fc 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -228,7 +228,7 @@ void migrate_to_reboot_cpu(void)
 		cpu = cpumask_first(cpu_online_mask);
 
 	/* Prevent races with other tasks migrating this task */
-	current->flags |= PF_NO_SETAFFINITY;
+	sysiso_current->flags |= PF_NO_SETAFFINITY;
 
 	/* Make certain I only run on the appropriate processor */
 	set_cpus_allowed_ptr(current, cpumask_of(cpu));
diff --git a/kernel/sched/completion.c b/kernel/sched/completion.c
index a778554f9..5ff945957 100644
--- a/kernel/sched/completion.c
+++ b/kernel/sched/completion.c
@@ -75,7 +75,7 @@ do_wait_for_common(struct completion *x,
 		DECLARE_SWAITQUEUE(wait);
 
 		do {
-			if (signal_pending_state(state, current)) {
+			if (signal_pending_state(state, sysiso_current)) {
 				timeout = -ERESTARTSYS;
 				break;
 			}
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index f21714ea3..17a5c5d9c 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -20,6 +20,8 @@
 #include <asm/switch_to.h>
 #include <asm/tlb.h>
 
+#include <linux/sysiso.h>
+
 #include "../workqueue_internal.h"
 #include "../../fs/io-wq.h"
 #include "../smpboot.h"
@@ -3523,6 +3525,8 @@ static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,
 {
 	check_preempt_curr(rq, p, wake_flags);
 	WRITE_ONCE(p->__state, TASK_RUNNING);
+	/* SYSISO_TODO: this is suspicious, should we wake up here? */
+
 	trace_sched_wakeup(p);
 
 #ifdef CONFIG_SMP
@@ -3951,6 +3955,13 @@ try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
 	int cpu, success = 0;
 
 	preempt_disable();
+
+	/* Only sysisod controls the state of its clients! */
+	if(sysiso_try_to_wake_up(p)) {
+		success = 1;
+		goto unlock;
+	}
+
 	if (p == current) {
 		/*
 		 * We're waking current, this means 'p->on_rq' and 'task_cpu(p)
@@ -4044,6 +4055,7 @@ try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
 	 * enqueue, such as ttwu_queue_wakelist().
 	 */
 	WRITE_ONCE(p->__state, TASK_WAKING);
+	/* SYSISO_TODO this is suspicious, should we consider this? */
 
 	/*
 	 * If the owning (remote) CPU is still in the middle of schedule() with
@@ -4788,7 +4800,7 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 	 */
 	if (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,
 		      "corrupted preempt_count: %s/%d/0x%x\n",
-		      current->comm, current->pid, preempt_count()))
+		      sysiso_current->comm, current->pid, preempt_count()))
 		preempt_count_set(FORK_PREEMPT_COUNT);
 
 	rq->prev_mm = NULL;
@@ -4877,7 +4889,7 @@ asmlinkage __visible void schedule_tail(struct task_struct *prev)
 	preempt_enable();
 
 	if (current->set_child_tid)
-		put_user(task_pid_vnr(current), current->set_child_tid);
+		put_user(task_pid_vnr(sysiso_current), current->set_child_tid);
 
 	calculate_sigpending();
 }
@@ -6300,7 +6312,7 @@ void __noreturn do_task_dead(void)
 	set_special_state(TASK_DEAD);
 
 	/* Tell freezer to ignore us: */
-	current->flags |= PF_NOFREEZE;
+	sysiso_current->flags |= PF_NOFREEZE;
 
 	__schedule(SM_NONE);
 	BUG();
@@ -6356,7 +6368,7 @@ static void sched_update_worker(struct task_struct *tsk)
 	}
 }
 
-asmlinkage __visible void __sched schedule(void)
+asmlinkage __visible void __sched schedule_linux(void)
 {
 	struct task_struct *tsk = current;
 
@@ -6368,6 +6380,15 @@ asmlinkage __visible void __sched schedule(void)
 	} while (need_resched());
 	sched_update_worker(tsk);
 }
+EXPORT_SYMBOL(schedule_linux);
+
+asmlinkage __visible void __sched schedule(void)
+{
+	if (sysiso_current_is_server())
+		sysiso_schedule();
+	else
+		schedule_linux();
+}
 EXPORT_SYMBOL(schedule);
 
 /*
@@ -9236,7 +9257,7 @@ void __init sched_init_smp(void)
 	/* Move init over to a non-isolated CPU */
 	if (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_DOMAIN)) < 0)
 		BUG();
-	current->flags &= ~PF_NO_SETAFFINITY;
+	sysiso_current->flags &= ~PF_NO_SETAFFINITY;
 	sched_init_granularity();
 
 	init_sched_rt_class();
@@ -9523,7 +9544,7 @@ void ___might_sleep(const char *file, int line, int preempt_offset)
 	printk(KERN_ERR
 		"in_atomic(): %d, irqs_disabled(): %d, non_block: %d, pid: %d, name: %s\n",
 			in_atomic(), irqs_disabled(), current->non_block_count,
-			current->pid, current->comm);
+			sysiso_current->pid, sysiso_current->comm);
 
 	if (task_stack_end_corrupted(current))
 		printk(KERN_EMERG "Thread overran stack, or stack corrupted\n");
@@ -9561,7 +9582,7 @@ void __cant_sleep(const char *file, int line, int preempt_offset)
 	printk(KERN_ERR "BUG: assuming atomic context at %s:%d\n", file, line);
 	printk(KERN_ERR "in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n",
 			in_atomic(), irqs_disabled(),
-			current->pid, current->comm);
+			sysiso_current->pid, sysiso_current->comm);
 
 	debug_show_held_locks(current);
 	dump_stack();
@@ -9593,7 +9614,7 @@ void __cant_migrate(const char *file, int line)
 	pr_err("BUG: assuming non migratable context at %s:%d\n", file, line);
 	pr_err("in_atomic(): %d, irqs_disabled(): %d, migration_disabled() %u pid: %d, name: %s\n",
 	       in_atomic(), irqs_disabled(), is_migration_disabled(current),
-	       current->pid, current->comm);
+	       sysiso_current->pid, sysiso_current->comm);
 
 	debug_show_held_locks(current);
 	dump_stack();
diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c
index 872e481d5..3ab157cb5 100644
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@ -307,7 +307,7 @@ void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)
 	 * those pending times and rely only on values updated on tick or
 	 * other scheduler action.
 	 */
-	if (same_thread_group(current, tsk))
+	if (same_thread_group(sysiso_current, tsk))
 		(void) task_sched_runtime(current);
 
 	rcu_read_lock();
@@ -779,7 +779,7 @@ void vtime_task_switch_generic(struct task_struct *prev)
 	write_seqcount_begin(&vtime->seqcount);
 	if (is_idle_task(current))
 		vtime->state = VTIME_IDLE;
-	else if (current->flags & PF_VCPU)
+	else if (sysiso_current->flags & PF_VCPU)
 		vtime->state = VTIME_GUEST;
 	else
 		vtime->state = VTIME_SYS;
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index f6a05d9b5..f565a21e4 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -1416,7 +1416,7 @@ bool should_numa_migrate_memory(struct task_struct *p, struct page * page,
 	int dst_nid = cpu_to_node(dst_cpu);
 	int last_cpupid, this_cpupid;
 
-	this_cpupid = cpu_pid_to_cpupid(dst_cpu, current->pid);
+	this_cpupid = cpu_pid_to_cpupid(dst_cpu, sysiso_current->pid);
 	last_cpupid = page_cpupid_xchg_last(page, this_cpupid);
 
 	/*
@@ -6911,7 +6911,7 @@ static int find_energy_efficient_cpu(struct task_struct *p, int prev_cpu)
 static int
 select_task_rq_fair(struct task_struct *p, int prev_cpu, int wake_flags)
 {
-	int sync = (wake_flags & WF_SYNC) && !(current->flags & PF_EXITING);
+	int sync = (wake_flags & WF_SYNC) && !(sysiso_current->flags & PF_EXITING);
 	struct sched_domain *tmp, *sd = NULL;
 	int cpu = smp_processor_id();
 	int new_cpu = prev_cpu;
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
index d17b0a5ce..7d4a0e12a 100644
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -368,14 +368,14 @@ void play_idle_precise(u64 duration_ns, u64 latency_ns)
 	 */
 	WARN_ON_ONCE(current->policy != SCHED_FIFO);
 	WARN_ON_ONCE(current->nr_cpus_allowed != 1);
-	WARN_ON_ONCE(!(current->flags & PF_KTHREAD));
-	WARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));
+	WARN_ON_ONCE(!(sysiso_current->flags & PF_KTHREAD));
+	WARN_ON_ONCE(!(sysiso_current->flags & PF_NO_SETAFFINITY));
 	WARN_ON_ONCE(!duration_ns);
 	WARN_ON_ONCE(current->mm);
 
 	rcu_sleep_check();
 	preempt_disable();
-	current->flags |= PF_IDLE;
+	sysiso_current->flags |= PF_IDLE;
 	cpuidle_use_deepest_state(latency_ns);
 
 	it.done = 0;
@@ -388,7 +388,7 @@ void play_idle_precise(u64 duration_ns, u64 latency_ns)
 		do_idle();
 
 	cpuidle_use_deepest_state(0);
-	current->flags &= ~PF_IDLE;
+	sysiso_current->flags &= ~PF_IDLE;
 
 	preempt_fold_need_resched();
 	preempt_enable();
diff --git a/kernel/sched/swait.c b/kernel/sched/swait.c
index e1c655f92..45f0d394c 100644
--- a/kernel/sched/swait.c
+++ b/kernel/sched/swait.c
@@ -106,7 +106,7 @@ long prepare_to_swait_event(struct swait_queue_head *q, struct swait_queue *wait
 	long ret = 0;
 
 	raw_spin_lock_irqsave(&q->lock, flags);
-	if (signal_pending_state(state, current)) {
+	if (signal_pending_state(state, sysiso_current)) {
 		/*
 		 * See prepare_to_wait_event(). TL;DR, subsequent swake_up_one()
 		 * must not see us.
diff --git a/kernel/sched/wait.c b/kernel/sched/wait.c
index 76577d164..0e0ddd40d 100644
--- a/kernel/sched/wait.c
+++ b/kernel/sched/wait.c
@@ -6,6 +6,9 @@
  */
 #include "sched.h"
 
+#include <linux/sysiso.h>
+
+
 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)
 {
 	spin_lock_init(&wq_head->lock);
@@ -106,6 +109,8 @@ static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,
 			continue;
 
 		ret = curr->func(curr, mode, wake_flags, key);
+		sysiso__wake_up_common(curr);
+
 		if (ret < 0)
 			break;
 		if (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)
@@ -260,6 +265,7 @@ prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_ent
 	if (list_empty(&wq_entry->entry))
 		__add_wait_queue(wq_head, wq_entry);
 	set_current_state(state);
+	sysiso_prepare_wait(wq_entry);
 	spin_unlock_irqrestore(&wq_head->lock, flags);
 }
 EXPORT_SYMBOL(prepare_to_wait);
@@ -278,6 +284,7 @@ prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_ent
 		__add_wait_queue_entry_tail(wq_head, wq_entry);
 	}
 	set_current_state(state);
+	sysiso_prepare_wait(wq_entry);
 	spin_unlock_irqrestore(&wq_head->lock, flags);
 	return was_empty;
 }
@@ -288,6 +295,10 @@ void init_wait_entry(struct wait_queue_entry *wq_entry, int flags)
 	wq_entry->flags = flags;
 	wq_entry->private = current;
 	wq_entry->func = autoremove_wake_function;
+//	sysiso_init_wait_entry(wq_entry);
+#ifdef CONFIG_SYSISO
+	wq_entry->sysiso_task = NULL;
+#endif
 	INIT_LIST_HEAD(&wq_entry->entry);
 }
 EXPORT_SYMBOL(init_wait_entry);
@@ -321,6 +332,7 @@ long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_en
 				__add_wait_queue(wq_head, wq_entry);
 		}
 		set_current_state(state);
+		sysiso_prepare_wait(wq_entry);
 	}
 	spin_unlock_irqrestore(&wq_head->lock, flags);
 
@@ -341,7 +353,7 @@ int do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)
 		__add_wait_queue_entry_tail(wq, wait);
 
 	set_current_state(TASK_INTERRUPTIBLE);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	spin_unlock(&wq->lock);
@@ -358,7 +370,7 @@ int do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)
 		__add_wait_queue_entry_tail(wq, wait);
 
 	set_current_state(TASK_INTERRUPTIBLE);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return -ERESTARTSYS;
 
 	spin_unlock_irq(&wq->lock);
@@ -417,7 +429,7 @@ EXPORT_SYMBOL(autoremove_wake_function);
 
 static inline bool is_kthread_should_stop(void)
 {
-	return (current->flags & PF_KTHREAD) && kthread_should_stop();
+	return (sysiso_current->flags & PF_KTHREAD) && kthread_should_stop();
 }
 
 /*
diff --git a/kernel/sched/wait_bit.c b/kernel/sched/wait_bit.c
index 02ce292b9..5831cab5f 100644
--- a/kernel/sched/wait_bit.c
+++ b/kernel/sched/wait_bit.c
@@ -182,6 +182,9 @@ void init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int
 			.flags	 = flags,
 			.private = current,
 			.func	 = var_wake_function,
+#ifdef CONFIG_SYSISO
+			.sysiso_task = NULL,
+#endif
 			.entry	 = LIST_HEAD_INIT(wbq_entry->wq_entry.entry),
 		},
 	};
@@ -197,7 +200,7 @@ EXPORT_SYMBOL(wake_up_var);
 __sched int bit_wait(struct wait_bit_key *word, int mode)
 {
 	schedule();
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -EINTR;
 
 	return 0;
@@ -207,7 +210,7 @@ EXPORT_SYMBOL(bit_wait);
 __sched int bit_wait_io(struct wait_bit_key *word, int mode)
 {
 	io_schedule();
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -EINTR;
 
 	return 0;
@@ -221,7 +224,7 @@ __sched int bit_wait_timeout(struct wait_bit_key *word, int mode)
 	if (time_after_eq(now, word->timeout))
 		return -EAGAIN;
 	schedule_timeout(word->timeout - now);
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -EINTR;
 
 	return 0;
@@ -235,7 +238,7 @@ __sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)
 	if (time_after_eq(now, word->timeout))
 		return -EAGAIN;
 	io_schedule_timeout(word->timeout - now);
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -EINTR;
 
 	return 0;
diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 4d8f44a17..05fef80c5 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -426,7 +426,7 @@ static u32 seccomp_run_filters(const struct seccomp_data *sd,
 
 static inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)
 {
-	assert_spin_locked(&current->sighand->siglock);
+	assert_spin_locked(&sysiso_current->sighand->siglock);
 
 	if (current->seccomp.mode && current->seccomp.mode != seccomp_mode)
 		return false;
@@ -481,8 +481,8 @@ static inline pid_t seccomp_can_sync_threads(void)
 {
 	struct task_struct *thread, *caller;
 
-	BUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));
-	assert_spin_locked(&current->sighand->siglock);
+	BUG_ON(!mutex_is_locked(&sysiso_current->signal->cred_guard_mutex));
+	assert_spin_locked(&sysiso_current->sighand->siglock);
 
 	/* Validate all threads being eligible for synchronization. */
 	caller = current;
@@ -578,8 +578,8 @@ static inline void seccomp_sync_threads(unsigned long flags)
 {
 	struct task_struct *thread, *caller;
 
-	BUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));
-	assert_spin_locked(&current->sighand->siglock);
+	BUG_ON(!mutex_is_locked(&sysiso_current->signal->cred_guard_mutex));
+	assert_spin_locked(&sysiso_current->sighand->siglock);
 
 	/* Synchronize all threads. */
 	caller = current;
@@ -865,7 +865,7 @@ static long seccomp_attach_filter(unsigned int flags,
 	unsigned long total_insns;
 	struct seccomp_filter *walker;
 
-	assert_spin_locked(&current->sighand->siglock);
+	assert_spin_locked(&sysiso_current->sighand->siglock);
 
 	/* Validate resulting filter length. */
 	total_insns = filter->prog->len;
@@ -1222,7 +1222,7 @@ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
 		 * kill the process and correctly handle any tracer exit
 		 * notifications.
 		 */
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			goto skip;
 		/* Check if the tracer forced the syscall to be skipped. */
 		this_syscall = syscall_get_nr(current, current_pt_regs());
@@ -1332,7 +1332,7 @@ static long seccomp_set_mode_strict(void)
 	const unsigned long seccomp_mode = SECCOMP_MODE_STRICT;
 	long ret = -EINVAL;
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 
 	if (!seccomp_may_assign_mode(seccomp_mode))
 		goto out;
@@ -1344,7 +1344,7 @@ static long seccomp_set_mode_strict(void)
 	ret = 0;
 
 out:
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	return ret;
 }
@@ -1770,7 +1770,7 @@ static bool has_duplicate_listener(struct seccomp_filter *new_child)
 	struct seccomp_filter *cur;
 
 	/* must be protected against concurrent TSYNC */
-	lockdep_assert_held(&current->sighand->siglock);
+	lockdep_assert_held(&sysiso_current->sighand->siglock);
 
 	if (!new_child->notif)
 		return false;
@@ -1845,10 +1845,10 @@ static long seccomp_set_mode_filter(unsigned int flags,
 	 * while another thread is in the middle of calling exec.
 	 */
 	if (flags & SECCOMP_FILTER_FLAG_TSYNC &&
-	    mutex_lock_killable(&current->signal->cred_guard_mutex))
+	    mutex_lock_killable(&sysiso_current->signal->cred_guard_mutex))
 		goto out_put_fd;
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 
 	if (!seccomp_may_assign_mode(seccomp_mode))
 		goto out;
@@ -1866,9 +1866,9 @@ static long seccomp_set_mode_filter(unsigned int flags,
 
 	seccomp_assign_mode(current, seccomp_mode, flags);
 out:
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 	if (flags & SECCOMP_FILTER_FLAG_TSYNC)
-		mutex_unlock(&current->signal->cred_guard_mutex);
+		mutex_unlock(&sysiso_current->signal->cred_guard_mutex);
 out_put_fd:
 	if (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {
 		if (ret) {
diff --git a/kernel/signal.c b/kernel/signal.c
index 487bf4f5d..cf3bca0f0 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -162,8 +162,8 @@ static bool recalc_sigpending_tsk(struct task_struct *t)
 	}
 
 	/*
-	 * We must never clear the flag in another thread, or in current
-	 * when it's possible the current syscall is returning -ERESTART*.
+	 * We must never clear the flag in another thread, or in sysiso_current
+	 * when it's possible the sysiso_current syscall is returning -ERESTART*.
 	 * So we don't clear it here, and only callers who know they should do.
 	 */
 	return false;
@@ -171,7 +171,7 @@ static bool recalc_sigpending_tsk(struct task_struct *t)
 
 /*
  * After recalculating TIF_SIGPENDING, we need to make sure the task wakes up.
- * This is superfluous when called on current, the wakeup is a harmless no-op.
+ * This is superfluous when called on sysiso_current, the wakeup is a harmless no-op.
  */
 void recalc_sigpending_and_wake(struct task_struct *t)
 {
@@ -181,7 +181,7 @@ void recalc_sigpending_and_wake(struct task_struct *t)
 
 void recalc_sigpending(void)
 {
-	if (!recalc_sigpending_tsk(current) && !freezing(current))
+	if (!recalc_sigpending_tsk(sysiso_current) && !freezing(sysiso_current))
 		clear_thread_flag(TIF_SIGPENDING);
 
 }
@@ -192,10 +192,10 @@ void calculate_sigpending(void)
 	/* Have any signals or users of TIF_SIGPENDING been delayed
 	 * until after fork?
 	 */
-	spin_lock_irq(&current->sighand->siglock);
-	set_tsk_thread_flag(current, TIF_SIGPENDING);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	set_tsk_thread_flag(sysiso_current, TIF_SIGPENDING);
 	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 
 /* Given the mask, find the first available signal that should be serviced. */
@@ -261,7 +261,7 @@ static inline void print_dropped_signal(int sig)
 		return;
 
 	pr_info("%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\n",
-				current->comm, current->pid, sig);
+				sysiso_current->comm, sysiso_current->pid, sig);
 }
 
 /**
@@ -390,8 +390,8 @@ static bool task_participate_group_stop(struct task_struct *task)
 
 void task_join_group_stop(struct task_struct *task)
 {
-	unsigned long mask = current->jobctl & JOBCTL_STOP_SIGMASK;
-	struct signal_struct *sig = current->signal;
+	unsigned long mask = sysiso_current->jobctl & JOBCTL_STOP_SIGMASK;
+	struct signal_struct *sig = sysiso_current->signal;
 
 	if (sig->group_stop_count) {
 		sig->group_stop_count++;
@@ -405,7 +405,7 @@ void task_join_group_stop(struct task_struct *task)
 
 /*
  * allocate a new signal queue record
- * - this may be called without locks if and only if t == current, otherwise an
+ * - this may be called without locks if and only if t == sysiso_current, otherwise an
  *   appropriate lock must be held to stop the target task from exiting
  */
 static struct sigqueue *
@@ -511,7 +511,7 @@ static void __flush_itimer_signals(struct sigpending *pending)
 
 void flush_itimer_signals(void)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	unsigned long flags;
 
 	spin_lock_irqsave(&tsk->sighand->siglock, flags);
@@ -682,7 +682,7 @@ int dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *in
 		 * is to alert stop-signal processing code when another
 		 * processor has come along and cleared the flag.
 		 */
-		current->jobctl |= JOBCTL_STOP_DEQUEUED;
+		sysiso_current->jobctl |= JOBCTL_STOP_DEQUEUED;
 	}
 #ifdef CONFIG_POSIX_TIMERS
 	if (resched_timer) {
@@ -706,7 +706,7 @@ EXPORT_SYMBOL_GPL(dequeue_signal);
 
 static int dequeue_synchronous_signal(kernel_siginfo_t *info)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	struct sigpending *pending = &tsk->pending;
 	struct sigqueue *q, *sync = NULL;
 
@@ -841,7 +841,7 @@ static int check_kill_permission(int sig, struct kernel_siginfo *info,
 	if (error)
 		return error;
 
-	if (!same_thread_group(current, t) &&
+	if (!same_thread_group(sysiso_current, t) &&
 	    !kill_ok_by_cred(t)) {
 		switch (sig) {
 		case SIGCONT:
@@ -850,7 +850,7 @@ static int check_kill_permission(int sig, struct kernel_siginfo *info,
 			 * We don't return the error if sid == NULL. The
 			 * task was unhashed, the caller must notice this.
 			 */
-			if (!sid || sid == task_session(current))
+			if (!sid || sid == task_session(sysiso_current))
 				break;
 			fallthrough;
 		default:
@@ -1123,7 +1123,7 @@ static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struc
 			q->info.si_signo = sig;
 			q->info.si_errno = 0;
 			q->info.si_code = SI_USER;
-			q->info.si_pid = task_tgid_nr_ns(current,
+			q->info.si_pid = task_tgid_nr_ns(sysiso_current,
 							task_active_pid_ns(t));
 			rcu_read_lock();
 			q->info.si_uid =
@@ -1217,7 +1217,7 @@ static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct
 
 	if (info == SEND_SIG_NOINFO) {
 		/* Force if sent from an ancestor pid namespace */
-		force = !task_pid_nr_ns(current, task_active_pid_ns(t));
+		force = !task_pid_nr_ns(sysiso_current, task_active_pid_ns(t));
 	} else if (info == SEND_SIG_PRIV) {
 		/* Don't ignore kernel generated signals */
 		force = true;
@@ -1237,7 +1237,7 @@ static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct
 		force = (info->si_code == SI_KERNEL);
 
 		/* From an ancestor pid namespace? */
-		if (!task_pid_nr_ns(current, task_active_pid_ns(t))) {
+		if (!task_pid_nr_ns(sysiso_current, task_active_pid_ns(t))) {
 			info->si_pid = 0;
 			force = true;
 		}
@@ -1342,7 +1342,7 @@ force_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t, bool
 
 int force_sig_info(struct kernel_siginfo *info)
 {
-	return force_sig_info_to_task(info, current, false);
+	return force_sig_info_to_task(info, sysiso_current, false);
 }
 
 /*
@@ -1586,14 +1586,14 @@ static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)
 	read_lock(&tasklist_lock);
 	if (pid != -1) {
 		ret = __kill_pgrp_info(sig, info,
-				pid ? find_vpid(-pid) : task_pgrp(current));
+				pid ? find_vpid(-pid) : task_pgrp(sysiso_current));
 	} else {
 		int retval = 0, count = 0;
 		struct task_struct * p;
 
 		for_each_process(p) {
 			if (task_pid_vnr(p) > 1 &&
-					!same_thread_group(p, current)) {
+					!same_thread_group(p, sysiso_current)) {
 				int err = group_send_sig_info(sig, info, p,
 							      PIDTYPE_MAX);
 				++count;
@@ -1657,7 +1657,7 @@ EXPORT_SYMBOL(force_sig);
  */
 void force_sigsegv(int sig)
 {
-	struct task_struct *p = current;
+	struct task_struct *p = sysiso_current;
 
 	if (sig == SIGSEGV) {
 		unsigned long flags;
@@ -1691,7 +1691,7 @@ int force_sig_fault(int sig, int code, void __user *addr
 	___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr))
 {
 	return force_sig_fault_to_task(sig, code, addr
-				       ___ARCH_SI_IA64(imm, flags, isr), current);
+				       ___ARCH_SI_IA64(imm, flags, isr), sysiso_current);
 }
 
 int send_sig_fault(int sig, int code, void __user *addr
@@ -1800,11 +1800,11 @@ int force_sig_seccomp(int syscall, int reason, bool force_coredump)
 	clear_siginfo(&info);
 	info.si_signo = SIGSYS;
 	info.si_code = SYS_SECCOMP;
-	info.si_call_addr = (void __user *)KSTK_EIP(current);
+	info.si_call_addr = (void __user *)KSTK_EIP(sysiso_current);
 	info.si_errno = reason;
-	info.si_arch = syscall_get_arch(current);
+	info.si_arch = syscall_get_arch(sysiso_current);
 	info.si_syscall = syscall;
-	return force_sig_info_to_task(&info, current, force_coredump);
+	return force_sig_info_to_task(&info, sysiso_current, force_coredump);
 }
 
 /* For the crazy architectures that include trap information in
@@ -1884,13 +1884,13 @@ EXPORT_SYMBOL(kill_pid);
  */
 struct sigqueue *sigqueue_alloc(void)
 {
-	return __sigqueue_alloc(-1, current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);
+	return __sigqueue_alloc(-1, sysiso_current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);
 }
 
 void sigqueue_free(struct sigqueue *q)
 {
 	unsigned long flags;
-	spinlock_t *lock = &current->sighand->siglock;
+	spinlock_t *lock = &sysiso_current->sighand->siglock;
 
 	BUG_ON(!(q->flags & SIGQUEUE_PREALLOC));
 	/*
@@ -2183,16 +2183,16 @@ static bool sigkill_pending(struct task_struct *tsk)
  * This must be called with current->sighand->siglock held.
  *
  * This should be the path for all ptrace stops.
- * We always set current->last_siginfo while stopped here.
+ * We always set sysiso_current->last_siginfo while stopped here.
  * That makes it a way to test a stopped process for
  * being ptrace-stopped vs being job-control-stopped.
  *
  * If we actually decide not to stop at all because the tracer
- * is gone, we keep current->exit_code unless clear_code.
+ * is gone, we keep sysiso_current->exit_code unless clear_code.
  */
 static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)
-	__releases(&current->sighand->siglock)
-	__acquires(&current->sighand->siglock)
+	__releases(&sysiso_current->sighand->siglock)
+	__acquires(&sysiso_current->sighand->siglock)
 {
 	bool gstop_done = false;
 
@@ -2208,10 +2208,10 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 		 * siglock.  That must prevent us from sleeping in TASK_TRACED.
 		 * So after regaining the lock, we must check for SIGKILL.
 		 */
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 		arch_ptrace_stop(exit_code, info);
-		spin_lock_irq(&current->sighand->siglock);
-		if (sigkill_pending(current))
+		spin_lock_irq(&sysiso_current->sighand->siglock);
+		if (sigkill_pending(sysiso_current))
 			return;
 	}
 
@@ -2237,8 +2237,8 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 	 */
 	smp_wmb();
 
-	current->last_siginfo = info;
-	current->exit_code = exit_code;
+	sysiso_current->last_siginfo = info;
+	sysiso_current->exit_code = exit_code;
 
 	/*
 	 * If @why is CLD_STOPPED, we're trapping to participate in a group
@@ -2247,18 +2247,18 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 	 * could be clear now.  We act as if SIGCONT is received after
 	 * TASK_TRACED is entered - ignore it.
 	 */
-	if (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))
-		gstop_done = task_participate_group_stop(current);
+	if (why == CLD_STOPPED && (sysiso_current->jobctl & JOBCTL_STOP_PENDING))
+		gstop_done = task_participate_group_stop(sysiso_current);
 
 	/* any trap clears pending STOP trap, STOP trap clears NOTIFY */
-	task_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);
+	task_clear_jobctl_pending(sysiso_current, JOBCTL_TRAP_STOP);
 	if (info && info->si_code >> 8 == PTRACE_EVENT_STOP)
-		task_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);
+		task_clear_jobctl_pending(sysiso_current, JOBCTL_TRAP_NOTIFY);
 
 	/* entering a trap, clear TRAPPING */
-	task_clear_jobctl_trapping(current);
+	task_clear_jobctl_trapping(sysiso_current);
 
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 	read_lock(&tasklist_lock);
 	if (may_ptrace_stop()) {
 		/*
@@ -2271,9 +2271,9 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 		 * for the two don't interact with each other.  Notify
 		 * separately unless they're gonna be duplicates.
 		 */
-		do_notify_parent_cldstop(current, true, why);
-		if (gstop_done && ptrace_reparented(current))
-			do_notify_parent_cldstop(current, false, why);
+		do_notify_parent_cldstop(sysiso_current, true, why);
+		if (gstop_done && ptrace_reparented(sysiso_current))
+			do_notify_parent_cldstop(sysiso_current, false, why);
 
 		/*
 		 * Don't want to allow preemption here, because
@@ -2299,12 +2299,12 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 		 * the real parent of the group stop completion is enough.
 		 */
 		if (gstop_done)
-			do_notify_parent_cldstop(current, false, why);
+			do_notify_parent_cldstop(sysiso_current, false, why);
 
 		/* tasklist protects us from ptrace_freeze_traced() */
 		__set_current_state(TASK_RUNNING);
 		if (clear_code)
-			current->exit_code = 0;
+			sysiso_current->exit_code = 0;
 		read_unlock(&tasklist_lock);
 	}
 
@@ -2313,18 +2313,18 @@ static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t
 	 * last_siginfo, so that we are sure to have synchronized with
 	 * any signal-sending on another CPU that wants to examine it.
 	 */
-	spin_lock_irq(&current->sighand->siglock);
-	current->last_siginfo = NULL;
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	sysiso_current->last_siginfo = NULL;
 
 	/* LISTENING can be set only during STOP traps, clear it */
-	current->jobctl &= ~JOBCTL_LISTENING;
+	sysiso_current->jobctl &= ~JOBCTL_LISTENING;
 
 	/*
 	 * Queued signals ignored us while we were stopped for tracing.
 	 * So check for any that we should take before resuming user mode.
 	 * This sets TIF_SIGPENDING, but never clears it.
 	 */
-	recalc_sigpending_tsk(current);
+	recalc_sigpending_tsk(sysiso_current);
 }
 
 static void ptrace_do_notify(int signr, int exit_code, int why)
@@ -2334,7 +2334,7 @@ static void ptrace_do_notify(int signr, int exit_code, int why)
 	clear_siginfo(&info);
 	info.si_signo = signr;
 	info.si_code = exit_code;
-	info.si_pid = task_pid_vnr(current);
+	info.si_pid = task_pid_vnr(sysiso_current);
 	info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
 
 	/* Let the debugger run.  */
@@ -2344,12 +2344,12 @@ static void ptrace_do_notify(int signr, int exit_code, int why)
 void ptrace_notify(int exit_code)
 {
 	BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);
-	if (unlikely(current->task_works))
+	if (unlikely(sysiso_current->task_works))
 		task_work_run();
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	ptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 
 /**
@@ -2375,18 +2375,18 @@ void ptrace_notify(int exit_code)
  * %true if participated in group stop.
  */
 static bool do_signal_stop(int signr)
-	__releases(&current->sighand->siglock)
+	__releases(&sysiso_current->sighand->siglock)
 {
-	struct signal_struct *sig = current->signal;
+	struct signal_struct *sig = sysiso_current->signal;
 
-	if (!(current->jobctl & JOBCTL_STOP_PENDING)) {
+	if (!(sysiso_current->jobctl & JOBCTL_STOP_PENDING)) {
 		unsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;
 		struct task_struct *t;
 
 		/* signr will be recorded in task->jobctl for retries */
 		WARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);
 
-		if (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||
+		if (!likely(sysiso_current->jobctl & JOBCTL_STOP_DEQUEUED) ||
 		    unlikely(signal_group_exit(sig)))
 			return false;
 		/*
@@ -2413,11 +2413,11 @@ static bool do_signal_stop(int signr)
 
 		sig->group_stop_count = 0;
 
-		if (task_set_jobctl_pending(current, signr | gstop))
+		if (task_set_jobctl_pending(sysiso_current, signr | gstop))
 			sig->group_stop_count++;
 
-		t = current;
-		while_each_thread(current, t) {
+		t = sysiso_current;
+		while_each_thread(sysiso_current, t) {
 			/*
 			 * Setting state to TASK_STOPPED for a group
 			 * stop is always done with the siglock held,
@@ -2442,11 +2442,11 @@ static bool do_signal_stop(int signr)
 		 * is a group stop in progress and we are the last to stop,
 		 * report to the parent.
 		 */
-		if (task_participate_group_stop(current))
+		if (task_participate_group_stop(sysiso_current))
 			notify = CLD_STOPPED;
 
 		set_special_state(TASK_STOPPED);
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 		/*
 		 * Notify the parent of the group stop completion.  Because
@@ -2459,7 +2459,7 @@ static bool do_signal_stop(int signr)
 		 */
 		if (notify) {
 			read_lock(&tasklist_lock);
-			do_notify_parent_cldstop(current, false, notify);
+			do_notify_parent_cldstop(sysiso_current, false, notify);
 			read_unlock(&tasklist_lock);
 		}
 
@@ -2472,7 +2472,7 @@ static bool do_signal_stop(int signr)
 		 * While ptraced, group stop is handled by STOP trap.
 		 * Schedule it and let the caller deal with it.
 		 */
-		task_set_jobctl_pending(current, JOBCTL_TRAP_STOP);
+		task_set_jobctl_pending(sysiso_current, JOBCTL_TRAP_STOP);
 		return false;
 	}
 }
@@ -2494,8 +2494,8 @@ static bool do_signal_stop(int signr)
  */
 static void do_jobctl_trap(void)
 {
-	struct signal_struct *signal = current->signal;
-	int signr = current->jobctl & JOBCTL_STOP_SIGMASK;
+	struct signal_struct *signal = sysiso_current->signal;
+	int signr = sysiso_current->jobctl & JOBCTL_STOP_SIGMASK;
 
 	if (current->ptrace & PT_SEIZED) {
 		if (!signal->group_stop_count &&
@@ -2507,7 +2507,7 @@ static void do_jobctl_trap(void)
 	} else {
 		WARN_ON_ONCE(!signr);
 		ptrace_stop(signr, CLD_STOPPED, 0, NULL);
-		current->exit_code = 0;
+		sysiso_current->exit_code = 0;
 	}
 }
 
@@ -2522,16 +2522,16 @@ static void do_jobctl_trap(void)
  * which is always released before returning.
  */
 static void do_freezer_trap(void)
-	__releases(&current->sighand->siglock)
+	__releases(&sysiso_current->sighand->siglock)
 {
 	/*
 	 * If there are other trap bits pending except JOBCTL_TRAP_FREEZE,
 	 * let's make another loop to give it a chance to be handled.
 	 * In any case, we'll return back.
 	 */
-	if ((current->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=
+	if ((sysiso_current->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=
 	     JOBCTL_TRAP_FREEZE) {
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 		return;
 	}
 
@@ -2543,7 +2543,7 @@ static void do_freezer_trap(void)
 	 */
 	__set_current_state(TASK_INTERRUPTIBLE);
 	clear_thread_flag(TIF_SIGPENDING);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 	cgroup_enter_frozen();
 	freezable_schedule();
 }
@@ -2559,15 +2559,15 @@ static int ptrace_signal(int signr, kernel_siginfo_t *info)
 	 * not cleared by SIGCONT while we were sleeping. See also the
 	 * comment in dequeue_signal().
 	 */
-	current->jobctl |= JOBCTL_STOP_DEQUEUED;
+	sysiso_current->jobctl |= JOBCTL_STOP_DEQUEUED;
 	ptrace_stop(signr, CLD_TRAPPED, 0, info);
 
 	/* We're back.  Did the debugger cancel the sig?  */
-	signr = current->exit_code;
+	signr = sysiso_current->exit_code;
 	if (signr == 0)
 		return signr;
 
-	current->exit_code = 0;
+	sysiso_current->exit_code = 0;
 
 	/*
 	 * Update the siginfo structure if the signal has
@@ -2581,15 +2581,15 @@ static int ptrace_signal(int signr, kernel_siginfo_t *info)
 		info->si_errno = 0;
 		info->si_code = SI_USER;
 		rcu_read_lock();
-		info->si_pid = task_pid_vnr(current->parent);
+		info->si_pid = task_pid_vnr(sysiso_current->parent);
 		info->si_uid = from_kuid_munged(current_user_ns(),
-						task_uid(current->parent));
+						task_uid(sysiso_current->parent));
 		rcu_read_unlock();
 	}
 
 	/* If the (new) signal is now blocked, requeue it.  */
-	if (sigismember(&current->blocked, signr)) {
-		send_signal(signr, info, current, PIDTYPE_PID);
+	if (sigismember(&sysiso_current->blocked, signr)) {
+		send_signal(signr, info, sysiso_current, PIDTYPE_PID);
 		signr = 0;
 	}
 
@@ -2620,11 +2620,11 @@ static void hide_si_addr_tag_bits(struct ksignal *ksig)
 
 bool get_signal(struct ksignal *ksig)
 {
-	struct sighand_struct *sighand = current->sighand;
-	struct signal_struct *signal = current->signal;
+	struct sighand_struct *sighand = sysiso_current->sighand;
+	struct signal_struct *signal = sysiso_current->signal;
 	int signr;
 
-	if (unlikely(current->task_works))
+	if (unlikely(sysiso_current->task_works))
 		task_work_run();
 
 	/*
@@ -2635,7 +2635,7 @@ bool get_signal(struct ksignal *ksig)
 	if (!IS_ENABLED(CONFIG_GENERIC_ENTRY)) {
 		if (test_thread_flag(TIF_NOTIFY_SIGNAL))
 			tracehook_notify_signal();
-		if (!task_sigpending(current))
+		if (!task_sigpending(sysiso_current))
 			return false;
 	}
 
@@ -2678,10 +2678,10 @@ bool get_signal(struct ksignal *ksig)
 		 * a duplicate.
 		 */
 		read_lock(&tasklist_lock);
-		do_notify_parent_cldstop(current, false, why);
+		do_notify_parent_cldstop(sysiso_current, false, why);
 
-		if (ptrace_reparented(current->group_leader))
-			do_notify_parent_cldstop(current->group_leader,
+		if (ptrace_reparented(sysiso_current->group_leader))
+			do_notify_parent_cldstop(sysiso_current->group_leader,
 						true, why);
 		read_unlock(&tasklist_lock);
 
@@ -2691,7 +2691,7 @@ bool get_signal(struct ksignal *ksig)
 	/* Has this task already been marked for death? */
 	if (signal_group_exit(signal)) {
 		ksig->info.si_signo = signr = SIGKILL;
-		sigdelset(&current->pending.signal, SIGKILL);
+		sigdelset(&sysiso_current->pending.signal, SIGKILL);
 		trace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,
 				&sighand->action[SIGKILL - 1]);
 		recalc_sigpending();
@@ -2701,16 +2701,16 @@ bool get_signal(struct ksignal *ksig)
 	for (;;) {
 		struct k_sigaction *ka;
 
-		if (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&
+		if (unlikely(sysiso_current->jobctl & JOBCTL_STOP_PENDING) &&
 		    do_signal_stop(0))
 			goto relock;
 
-		if (unlikely(current->jobctl &
+		if (unlikely(sysiso_current->jobctl &
 			     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {
-			if (current->jobctl & JOBCTL_TRAP_MASK) {
+			if (sysiso_current->jobctl & JOBCTL_TRAP_MASK) {
 				do_jobctl_trap();
 				spin_unlock_irq(&sighand->siglock);
-			} else if (current->jobctl & JOBCTL_TRAP_FREEZE)
+			} else if (sysiso_current->jobctl & JOBCTL_TRAP_FREEZE)
 				do_freezer_trap();
 
 			goto relock;
@@ -2720,7 +2720,7 @@ bool get_signal(struct ksignal *ksig)
 		 * If the task is leaving the frozen state, let's update
 		 * cgroup counters and reset the frozen bit.
 		 */
-		if (unlikely(cgroup_task_frozen(current))) {
+		if (unlikely(cgroup_task_frozen(sysiso_current))) {
 			spin_unlock_irq(&sighand->siglock);
 			cgroup_leave_frozen(false);
 			goto relock;
@@ -2734,7 +2734,7 @@ bool get_signal(struct ksignal *ksig)
 		 */
 		signr = dequeue_synchronous_signal(&ksig->info);
 		if (!signr)
-			signr = dequeue_signal(current, &current->blocked, &ksig->info);
+			signr = dequeue_signal(sysiso_current, &sysiso_current->blocked, &ksig->info);
 
 		if (!signr)
 			break; /* will return 0 */
@@ -2818,18 +2818,18 @@ bool get_signal(struct ksignal *ksig)
 
 	fatal:
 		spin_unlock_irq(&sighand->siglock);
-		if (unlikely(cgroup_task_frozen(current)))
+		if (unlikely(cgroup_task_frozen(sysiso_current)))
 			cgroup_leave_frozen(true);
 
 		/*
 		 * Anything else is fatal, maybe with a core dump.
 		 */
-		current->flags |= PF_SIGNALED;
+		sysiso_current->flags |= PF_SIGNALED;
 
 		if (sig_kernel_coredump(signr)) {
 			if (print_fatal_signals)
 				print_fatal_signal(ksig->info.si_signo);
-			proc_coredump_connector(current);
+			proc_coredump_connector(sysiso_current);
 			/*
 			 * If it was able to dump core, this kills all
 			 * other threads in the group and synchronizes with
@@ -2846,7 +2846,7 @@ bool get_signal(struct ksignal *ksig)
 		 * themselves. They have cleanup that must be performed, so
 		 * we cannot call do_exit() on their behalf.
 		 */
-		if (current->flags & PF_IO_WORKER)
+		if (sysiso_current->flags & PF_IO_WORKER)
 			goto out;
 
 		/*
@@ -2866,7 +2866,7 @@ bool get_signal(struct ksignal *ksig)
 }
 
 /**
- * signal_delivered - 
+ * signal_delivered -
  * @ksig:		kernel signal struct
  * @stepping:		nonzero if debugger single-step or block-step in use
  *
@@ -2885,12 +2885,12 @@ static void signal_delivered(struct ksignal *ksig, int stepping)
 	   simply clear the restore sigmask flag.  */
 	clear_restore_sigmask();
 
-	sigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);
+	sigorsets(&blocked, &sysiso_current->blocked, &ksig->ka.sa.sa_mask);
 	if (!(ksig->ka.sa.sa_flags & SA_NODEFER))
 		sigaddset(&blocked, ksig->sig);
 	set_current_blocked(&blocked);
-	if (current->sas_ss_flags & SS_AUTODISARM)
-		sas_ss_reset(current);
+	if (sysiso_current->sas_ss_flags & SS_AUTODISARM)
+		sas_ss_reset(sysiso_current);
 	tracehook_signal_handler(stepping);
 }
 
@@ -2993,7 +2993,7 @@ void exit_signals(struct task_struct *tsk)
  */
 SYSCALL_DEFINE0(restart_syscall)
 {
-	struct restart_block *restart = &current->restart_block;
+	struct restart_block *restart = &sysiso_current->restart_block;
 	return restart->fn(restart);
 }
 
@@ -3007,7 +3007,7 @@ static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)
 	if (task_sigpending(tsk) && !thread_group_empty(tsk)) {
 		sigset_t newblocked;
 		/* A set of now blocked but previously unblocked signals. */
-		sigandnsets(&newblocked, newset, &current->blocked);
+		sigandnsets(&newblocked, newset, &sysiso_current->blocked);
 		retarget_shared_pending(tsk, &newblocked);
 	}
 	tsk->blocked = *newset;
@@ -3015,7 +3015,7 @@ static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)
 }
 
 /**
- * set_current_blocked - change current->blocked mask
+ * set_current_blocked - change sysiso_current->blocked mask
  * @newset: new mask
  *
  * It is wrong to change ->blocked directly, this helper should be used
@@ -3029,11 +3029,11 @@ void set_current_blocked(sigset_t *newset)
 
 void __set_current_blocked(const sigset_t *newset)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 
 	/*
 	 * In case the signal mask hasn't changed, there is nothing we need
-	 * to do. The current->blocked shouldn't be modified by other task.
+	 * to do. The sysiso_current->blocked shouldn't be modified by other task.
 	 */
 	if (sigequalsets(&tsk->blocked, newset))
 		return;
@@ -3053,10 +3053,10 @@ void __set_current_blocked(const sigset_t *newset)
  */
 int sigprocmask(int how, sigset_t *set, sigset_t *oldset)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	sigset_t newset;
 
-	/* Lockless, only current can change ->blocked, never from irq */
+	/* Lockless, only sysiso_current can change ->blocked, never from irq */
 	if (oldset)
 		*oldset = tsk->blocked;
 
@@ -3100,7 +3100,7 @@ int set_user_sigmask(const sigset_t __user *umask, size_t sigsetsize)
 		return -EFAULT;
 
 	set_restore_sigmask();
-	current->saved_sigmask = current->blocked;
+	sysiso_current->saved_sigmask = sysiso_current->blocked;
 	set_current_blocked(&kmask);
 
 	return 0;
@@ -3120,7 +3120,7 @@ int set_compat_user_sigmask(const compat_sigset_t __user *umask,
 		return -EFAULT;
 
 	set_restore_sigmask();
-	current->saved_sigmask = current->blocked;
+	sysiso_current->saved_sigmask = sysiso_current->blocked;
 	set_current_blocked(&kmask);
 
 	return 0;
@@ -3144,7 +3144,7 @@ SYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,
 	if (sigsetsize != sizeof(sigset_t))
 		return -EINVAL;
 
-	old_set = current->blocked;
+	old_set = sysiso_current->blocked;
 
 	if (nset) {
 		if (copy_from_user(&new_set, nset, sizeof(sigset_t)))
@@ -3168,7 +3168,7 @@ SYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,
 COMPAT_SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,
 		compat_sigset_t __user *, oset, compat_size_t, sigsetsize)
 {
-	sigset_t old_set = current->blocked;
+	sigset_t old_set = sysiso_current->blocked;
 
 	/* XXX: Don't preclude handling different sized sigset_t's.  */
 	if (sigsetsize != sizeof(sigset_t))
@@ -3191,13 +3191,13 @@ COMPAT_SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,
 
 static void do_sigpending(sigset_t *set)
 {
-	spin_lock_irq(&current->sighand->siglock);
-	sigorsets(set, &current->pending.signal,
-		  &current->signal->shared_pending.signal);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	sigorsets(set, &sysiso_current->pending.signal,
+		  &sysiso_current->signal->shared_pending.signal);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	/* Outside the lock because only this thread touches it.  */
-	sigandsets(set, &current->blocked, set);
+	sigandsets(set, &sysiso_current->blocked, set);
 }
 
 /**
@@ -3563,7 +3563,7 @@ static int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,
 		    const struct timespec64 *ts)
 {
 	ktime_t *to = NULL, timeout = KTIME_MAX;
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	sigset_t mask = *which;
 	int sig, ret = 0;
 
@@ -3752,7 +3752,7 @@ static inline void prepare_kill_siginfo(int sig, struct kernel_siginfo *info)
 	info->si_signo = sig;
 	info->si_errno = 0;
 	info->si_code = SI_USER;
-	info->si_pid = task_tgid_vnr(current);
+	info->si_pid = task_tgid_vnr(sysiso_current);
 	info->si_uid = from_kuid_munged(current_user_ns(), current_uid());
 }
 
@@ -3777,7 +3777,7 @@ SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
  */
 static bool access_pidfd_pidns(struct pid *pid)
 {
-	struct pid_namespace *active = task_active_pid_ns(current);
+	struct pid_namespace *active = task_active_pid_ns(sysiso_current);
 	struct pid_namespace *p = ns_of_pid(pid);
 
 	for (;;) {
@@ -3874,7 +3874,7 @@ SYSCALL_DEFINE4(pidfd_send_signal, int, pidfd, int, sig,
 
 		/* Only allow sending arbitrary signals to yourself. */
 		ret = -EPERM;
-		if ((task_pid(current) != pid) &&
+		if ((task_pid(sysiso_current) != pid) &&
 		    (kinfo.si_code >= 0 || kinfo.si_code == SI_TKILL))
 			goto err;
 	} else {
@@ -3926,7 +3926,7 @@ static int do_tkill(pid_t tgid, pid_t pid, int sig)
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_TKILL;
-	info.si_pid = task_tgid_vnr(current);
+	info.si_pid = task_tgid_vnr(sysiso_current);
 	info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
 
 	return do_send_specific(tgid, pid, sig, &info);
@@ -3973,7 +3973,7 @@ static int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)
 	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
 	 */
 	if ((info->si_code >= 0 || info->si_code == SI_TKILL) &&
-	    (task_pid_vnr(current) != pid))
+	    (task_pid_vnr(sysiso_current) != pid))
 		return -EPERM;
 
 	/* POSIX.1b doesn't mention process groups.  */
@@ -4020,7 +4020,7 @@ static int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t
 	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
 	 */
 	if ((info->si_code >= 0 || info->si_code == SI_TKILL) &&
-	    (task_pid_vnr(current) != pid))
+	    (task_pid_vnr(sysiso_current) != pid))
 		return -EPERM;
 
 	return do_send_specific(tgid, pid, sig, info);
@@ -4056,19 +4056,19 @@ COMPAT_SYSCALL_DEFINE4(rt_tgsigqueueinfo,
  */
 void kernel_sigaction(int sig, __sighandler_t action)
 {
-	spin_lock_irq(&current->sighand->siglock);
-	current->sighand->action[sig - 1].sa.sa_handler = action;
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	sysiso_current->sighand->action[sig - 1].sa.sa_handler = action;
 	if (action == SIG_IGN) {
 		sigset_t mask;
 
 		sigemptyset(&mask);
 		sigaddset(&mask, sig);
 
-		flush_sigqueue_mask(&mask, &current->signal->shared_pending);
-		flush_sigqueue_mask(&mask, &current->pending);
+		flush_sigqueue_mask(&mask, &sysiso_current->signal->shared_pending);
+		flush_sigqueue_mask(&mask, &sysiso_current->pending);
 		recalc_sigpending();
 	}
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 }
 EXPORT_SYMBOL(kernel_sigaction);
 
@@ -4079,7 +4079,7 @@ void __weak sigaction_compat_abi(struct k_sigaction *act,
 
 int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)
 {
-	struct task_struct *p = current, *t;
+	struct task_struct *p = sysiso_current, *t;
 	struct k_sigaction *k;
 	sigset_t mask;
 
@@ -4142,14 +4142,14 @@ static int
 do_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,
 		size_t min_ss_size)
 {
-	struct task_struct *t = current;
+	struct task_struct *t = sysiso_current;
 
 	if (oss) {
 		memset(oss, 0, sizeof(stack_t));
 		oss->ss_sp = (void __user *) t->sas_ss_sp;
 		oss->ss_size = t->sas_ss_size;
 		oss->ss_flags = sas_ss_flags(sp) |
-			(current->sas_ss_flags & SS_FLAG_BITS);
+			(sysiso_current->sas_ss_flags & SS_FLAG_BITS);
 	}
 
 	if (ss) {
@@ -4208,7 +4208,7 @@ int restore_altstack(const stack_t __user *uss)
 
 int __save_altstack(stack_t __user *uss, unsigned long sp)
 {
-	struct task_struct *t = current;
+	struct task_struct *t = sysiso_current;
 	int err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
 		__put_user(t->sas_ss_flags, &uss->ss_flags) |
 		__put_user(t->sas_ss_size, &uss->ss_size);
@@ -4262,7 +4262,7 @@ int compat_restore_altstack(const compat_stack_t __user *uss)
 int __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)
 {
 	int err;
-	struct task_struct *t = current;
+	struct task_struct *t = sysiso_current;
 	err = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),
 			 &uss->ss_sp) |
 		__put_user(t->sas_ss_flags, &uss->ss_flags) |
@@ -4322,13 +4322,13 @@ SYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,
 	old_sigset_t old_set, new_set;
 	sigset_t new_blocked;
 
-	old_set = current->blocked.sig[0];
+	old_set = sysiso_current->blocked.sig[0];
 
 	if (nset) {
 		if (copy_from_user(&new_set, nset, sizeof(*nset)))
 			return -EFAULT;
 
-		new_blocked = current->blocked;
+		new_blocked = sysiso_current->blocked;
 
 		switch (how) {
 		case SIG_BLOCK:
@@ -4420,7 +4420,7 @@ COMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,
 
 	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
 	if (!ret && oact) {
-		ret = put_user(ptr_to_compat(old_ka.sa.sa_handler), 
+		ret = put_user(ptr_to_compat(old_ka.sa.sa_handler),
 			       &oact->sa_handler);
 		ret |= put_compat_sigset(&oact->sa_mask, &old_ka.sa.sa_mask,
 					 sizeof(oact->sa_mask));
@@ -4521,12 +4521,12 @@ COMPAT_SYSCALL_DEFINE3(sigaction, int, sig,
 SYSCALL_DEFINE0(sgetmask)
 {
 	/* SMP safe */
-	return current->blocked.sig[0];
+	return sysiso_current->blocked.sig[0];
 }
 
 SYSCALL_DEFINE1(ssetmask, int, newmask)
 {
-	int old = current->blocked.sig[0];
+	int old = sysiso_current->blocked.sig[0];
 	sigset_t newset;
 
 	siginitset(&newset, newmask);
@@ -4559,7 +4559,7 @@ SYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)
 
 SYSCALL_DEFINE0(pause)
 {
-	while (!signal_pending(current)) {
+	while (!signal_pending(sysiso_current)) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
 	}
@@ -4570,10 +4570,10 @@ SYSCALL_DEFINE0(pause)
 
 static int sigsuspend(sigset_t *set)
 {
-	current->saved_sigmask = current->blocked;
+	sysiso_current->saved_sigmask = sysiso_current->blocked;
 	set_current_blocked(set);
 
-	while (!signal_pending(current)) {
+	while (!signal_pending(sysiso_current)) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		schedule();
 	}
@@ -4599,7 +4599,7 @@ SYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)
 		return -EFAULT;
 	return sigsuspend(&newset);
 }
- 
+
 #ifdef CONFIG_COMPAT
 COMPAT_SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)
 {
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 322b65d45..922b2c027 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -515,7 +515,7 @@ static inline void lockdep_softirq_end(bool in_hardirq) { }
 asmlinkage __visible void __softirq_entry __do_softirq(void)
 {
 	unsigned long end = jiffies + MAX_SOFTIRQ_TIME;
-	unsigned long old_flags = current->flags;
+	unsigned long old_flags = sysiso_current->flags;
 	int max_restart = MAX_SOFTIRQ_RESTART;
 	struct softirq_action *h;
 	bool in_hardirq;
@@ -527,7 +527,7 @@ asmlinkage __visible void __softirq_entry __do_softirq(void)
 	 * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC
 	 * again if the socket is related to swapping.
 	 */
-	current->flags &= ~PF_MEMALLOC;
+	sysiso_current->flags &= ~PF_MEMALLOC;
 
 	pending = local_softirq_pending();
 
diff --git a/kernel/stacktrace.c b/kernel/stacktrace.c
index 9f8117c7c..eac4b12dc 100644
--- a/kernel/stacktrace.c
+++ b/kernel/stacktrace.c
@@ -228,7 +228,7 @@ unsigned int stack_trace_save_user(unsigned long *store, unsigned int size)
 	mm_segment_t fs;
 
 	/* Trace user stack if not a kernel thread */
-	if (current->flags & PF_KTHREAD)
+	if (sysiso_current->flags & PF_KTHREAD)
 		return 0;
 
 	fs = force_uaccess_begin();
diff --git a/kernel/sys.c b/kernel/sys.c
index 8fdac0d90..f20752761 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -72,6 +72,8 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#include <linux/sysiso.h>
+
 #include "uid16.h"
 
 #ifndef SET_UNALIGN_CTL
@@ -234,7 +236,7 @@ SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)
 		if (who)
 			pgrp = find_vpid(who);
 		else
-			pgrp = task_pgrp(current);
+			pgrp = task_pgrp(sysiso_current);
 		do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
 			error = set_one_prio(p, niceval, error);
 		} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);
@@ -300,7 +302,7 @@ SYSCALL_DEFINE2(getpriority, int, which, int, who)
 		if (who)
 			pgrp = find_vpid(who);
 		else
-			pgrp = task_pgrp(current);
+			pgrp = task_pgrp(sysiso_current);
 		do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
 			niceval = nice_to_rlimit(task_nice(p));
 			if (niceval > retval)
@@ -482,9 +484,9 @@ static int set_user(struct cred *new)
 	if (is_ucounts_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&
 			new_user != INIT_USER &&
 			!capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))
-		current->flags |= PF_NPROC_EXCEEDED;
+		sysiso_current->flags |= PF_NPROC_EXCEEDED;
 	else
-		current->flags &= ~PF_NPROC_EXCEEDED;
+		sysiso_current->flags &= ~PF_NPROC_EXCEEDED;
 
 	free_uid(new->user);
 	new->user = new_user;
@@ -923,13 +925,13 @@ SYSCALL_DEFINE1(setfsgid, gid_t, gid)
  */
 SYSCALL_DEFINE0(getpid)
 {
-	return task_tgid_vnr(current);
+	return task_tgid_vnr(sysiso_current);
 }
 
 /* Thread ID - the internal kernel "pid" */
 SYSCALL_DEFINE0(gettid)
 {
-	return task_pid_vnr(current);
+	return task_pid_vnr(sysiso_current);
 }
 
 /*
@@ -943,7 +945,7 @@ SYSCALL_DEFINE0(getppid)
 	int pid;
 
 	rcu_read_lock();
-	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
+	pid = task_tgid_vnr(rcu_dereference(sysiso_current->real_parent));
 	rcu_read_unlock();
 
 	return pid;
@@ -978,8 +980,8 @@ static void do_sys_times(struct tms *tms)
 	u64 tgutime, tgstime, cutime, cstime;
 
 	thread_group_cputime_adjusted(current, &tgutime, &tgstime);
-	cutime = current->signal->cutime;
-	cstime = current->signal->cstime;
+	cutime = sysiso_current->signal->cutime;
+	cstime = sysiso_current->signal->cstime;
 	tms->tms_utime = nsec_to_clock_t(tgutime);
 	tms->tms_stime = nsec_to_clock_t(tgstime);
 	tms->tms_cutime = nsec_to_clock_t(cutime);
@@ -1115,7 +1117,7 @@ static int do_getpgid(pid_t pid)
 
 	rcu_read_lock();
 	if (!pid)
-		grp = task_pgrp(current);
+		grp = task_pgrp(sysiso_current);
 	else {
 		retval = -ESRCH;
 		p = find_task_by_vpid(pid);
@@ -1157,7 +1159,7 @@ SYSCALL_DEFINE1(getsid, pid_t, pid)
 
 	rcu_read_lock();
 	if (!pid)
-		sid = task_session(current);
+		sid = task_session(sysiso_current);
 	else {
 		retval = -ESRCH;
 		p = find_task_by_vpid(pid);
@@ -1230,7 +1232,7 @@ DECLARE_RWSEM(uts_sem);
 
 #ifdef COMPAT_UTS_MACHINE
 #define override_architecture(name) \
-	(personality(current->personality) == PER_LINUX32 && \
+	(personality(sysiso_current->personality) == PER_LINUX32 && \
 	 copy_to_user(name->machine, COMPAT_UTS_MACHINE, \
 		      sizeof(COMPAT_UTS_MACHINE)))
 #else
@@ -1247,7 +1249,7 @@ static int override_release(char __user *release, size_t len)
 {
 	int ret = 0;
 
-	if (current->personality & UNAME26) {
+	if (sysiso_current->personality & UNAME26) {
 		const char *rest = UTS_RELEASE;
 		char buf[65] = { 0 };
 		int ndots = 0;
@@ -1395,7 +1397,7 @@ SYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
-	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
+	if (!ns_capable(sysiso_current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
@@ -1420,7 +1422,7 @@ SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
 	struct rlimit value;
 	int ret;
 
-	ret = do_prlimit(current, resource, NULL, &value);
+	ret = do_prlimit(sysiso_current, resource, NULL, &value);
 	if (!ret)
 		ret = copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;
 
@@ -1489,7 +1491,7 @@ SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
 
 	resource = array_index_nospec(resource, RLIM_NLIMITS);
 	task_lock(current->group_leader);
-	x = current->signal->rlim[resource];
+	x = sysiso_current->signal->rlim[resource];
 	task_unlock(current->group_leader);
 	if (x.rlim_cur > 0x7FFFFFFF)
 		x.rlim_cur = 0x7FFFFFFF;
@@ -1509,7 +1511,7 @@ COMPAT_SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
 
 	resource = array_index_nospec(resource, RLIM_NLIMITS);
 	task_lock(current->group_leader);
-	r = current->signal->rlim[resource];
+	r = sysiso_current->signal->rlim[resource];
 	task_unlock(current->group_leader);
 	if (r.rlim_cur > 0x7FFFFFFF)
 		r.rlim_cur = 0x7FFFFFFF;
@@ -1840,7 +1842,7 @@ COMPAT_SYSCALL_DEFINE2(getrusage, int, who, struct compat_rusage __user *, ru)
 
 SYSCALL_DEFINE1(umask, int, mask)
 {
-	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
+	mask = xchg(&sysiso_current->fs->umask, mask & S_IRWXUGO);
 	return mask;
 }
 
@@ -2074,9 +2076,9 @@ static int prctl_set_auxv(struct mm_struct *mm, unsigned long addr,
 
 	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
 
-	task_lock(current);
+	task_lock(sysiso_current);
 	memcpy(mm->saved_auxv, user_auxv, len);
-	task_unlock(current);
+	task_unlock(sysiso_current);
 
 	return 0;
 }
@@ -2358,17 +2360,17 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		error = perf_event_task_enable();
 		break;
 	case PR_GET_TIMERSLACK:
-		if (current->timer_slack_ns > ULONG_MAX)
+		if (sysiso_current->timer_slack_ns > ULONG_MAX)
 			error = ULONG_MAX;
 		else
-			error = current->timer_slack_ns;
+			error = sysiso_current->timer_slack_ns;
 		break;
 	case PR_SET_TIMERSLACK:
 		if (arg2 <= 0)
-			current->timer_slack_ns =
+			sysiso_current->timer_slack_ns =
 					current->default_timer_slack_ns;
 		else
-			current->timer_slack_ns = arg2;
+			sysiso_current->timer_slack_ns = arg2;
 		break;
 	case PR_MCE_KILL:
 		if (arg4 | arg5)
@@ -2377,16 +2379,16 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		case PR_MCE_KILL_CLEAR:
 			if (arg3 != 0)
 				return -EINVAL;
-			current->flags &= ~PF_MCE_PROCESS;
+			sysiso_current->flags &= ~PF_MCE_PROCESS;
 			break;
 		case PR_MCE_KILL_SET:
-			current->flags |= PF_MCE_PROCESS;
+			sysiso_current->flags |= PF_MCE_PROCESS;
 			if (arg3 == PR_MCE_KILL_EARLY)
-				current->flags |= PF_MCE_EARLY;
+				sysiso_current->flags |= PF_MCE_EARLY;
 			else if (arg3 == PR_MCE_KILL_LATE)
-				current->flags &= ~PF_MCE_EARLY;
+				sysiso_current->flags &= ~PF_MCE_EARLY;
 			else if (arg3 == PR_MCE_KILL_DEFAULT)
-				current->flags &=
+				sysiso_current->flags &=
 						~(PF_MCE_EARLY|PF_MCE_PROCESS);
 			else
 				return -EINVAL;
@@ -2398,8 +2400,8 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 	case PR_MCE_KILL_GET:
 		if (arg2 | arg3 | arg4 | arg5)
 			return -EINVAL;
-		if (current->flags & PF_MCE_PROCESS)
-			error = (current->flags & PF_MCE_EARLY) ?
+		if (sysiso_current->flags & PF_MCE_PROCESS)
+			error = (sysiso_current->flags & PF_MCE_EARLY) ?
 				PR_MCE_KILL_EARLY : PR_MCE_KILL_LATE;
 		else
 			error = PR_MCE_KILL_DEFAULT;
@@ -2506,9 +2508,9 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 			return -EINVAL;
 
 		if (arg2 == 1)
-			current->flags |= PR_IO_FLUSHER;
+			sysiso_current->flags |= PR_IO_FLUSHER;
 		else if (!arg2)
-			current->flags &= ~PR_IO_FLUSHER;
+			sysiso_current->flags &= ~PR_IO_FLUSHER;
 		else
 			return -EINVAL;
 		break;
@@ -2519,7 +2521,7 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		if (arg2 || arg3 || arg4 || arg5)
 			return -EINVAL;
 
-		error = (current->flags & PR_IO_FLUSHER) == PR_IO_FLUSHER;
+		error = (sysiso_current->flags & PR_IO_FLUSHER) == PR_IO_FLUSHER;
 		break;
 	case PR_SET_SYSCALL_USER_DISPATCH:
 		error = set_syscall_user_dispatch(arg2, arg3, arg4,
@@ -2529,6 +2531,14 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 	case PR_SCHED_CORE:
 		error = sched_core_share_pid(arg2, arg3, arg4, arg5);
 		break;
+#endif
+#ifdef CONFIG_SYSISO
+	case PR_SET_SYSISO:
+		error = sysiso_client_enable_prctl();
+		break;
+	case PR_GET_SYSISO:
+		error = test_tsk_thread_flag(me, TIF_SYSISO_CLIENT);
+		break;
 #endif
 	default:
 		error = -EINVAL;
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index f43d89d92..883c276b3 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -476,3 +476,5 @@ COND_SYSCALL(setuid16);
 
 /* restartable sequence */
 COND_SYSCALL(rseq);
+
+COND_SYSCALL(sysiso_test);
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 083be6af2..d851833d9 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -322,7 +322,7 @@ static void warn_sysctl_write(struct ctl_table *table)
 	pr_warn_once("%s wrote to %s when file position was not 0!\n"
 		"This will not be supported in the future. To silence this\n"
 		"warning, set kernel.sysctl_writes_strict = -1\n",
-		current->comm, table->procname);
+		sysiso_current->comm, table->procname);
 }
 
 /**
@@ -867,8 +867,8 @@ static int proc_dointvec_minmax_warn_RT_change(struct ctl_table *table,
 		return ret;
 	if (old != *(int *)table->data)
 		pr_warn_once("sysctl attribute %s changed by %s[%d]\n",
-			     table->procname, current->comm,
-			     task_pid_nr(current));
+			     table->procname, sysiso_current->comm,
+			     task_pid_nr(sysiso_current));
 	return ret;
 }
 #endif
diff --git a/kernel/taskstats.c b/kernel/taskstats.c
index 2b4898b47..e6a220efe 100644
--- a/kernel/taskstats.c
+++ b/kernel/taskstats.c
@@ -183,7 +183,8 @@ static int fill_stats_for_pid(pid_t pid, struct taskstats *stats)
 	tsk = find_get_task_by_vpid(pid);
 	if (!tsk)
 		return -ESRCH;
-	fill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);
+	fill_stats(current_user_ns(), task_active_pid_ns(sysiso_current), tsk,
+		   stats);
 	put_task_struct(tsk);
 	return 0;
 }
@@ -284,7 +285,7 @@ static int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)
 	if (current_user_ns() != &init_user_ns)
 		return -EINVAL;
 
-	if (task_active_pid_ns(current) != &init_pid_ns)
+	if (task_active_pid_ns(sysiso_current) != &init_pid_ns)
 		return -EINVAL;
 
 	if (isadd == REGISTER) {
diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c
index 5897828b9..07eb892fb 100644
--- a/kernel/time/alarmtimer.c
+++ b/kernel/time/alarmtimer.c
@@ -755,7 +755,7 @@ static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,
 			schedule();
 
 		alarm_cancel(alarm);
-	} while (alarm->data && !signal_pending(current));
+	} while (alarm->data && !signal_pending(sysiso_current));
 
 	__set_current_state(TASK_RUNNING);
 
@@ -764,9 +764,9 @@ static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,
 	if (!alarm->data)
 		return 0;
 
-	if (freezing(current))
+	if (freezing(sysiso_current))
 		alarmtimer_freezerset(absexp, type);
-	restart = &current->restart_block;
+	restart = &sysiso_current->restart_block;
 	if (restart->nanosleep.type != TT_NONE) {
 		struct timespec64 rmt;
 		ktime_t rem;
@@ -820,7 +820,7 @@ static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
 			      const struct timespec64 *tsreq)
 {
 	enum  alarmtimer_type type = clock2alarm(which_clock);
-	struct restart_block *restart = &current->restart_block;
+	struct restart_block *restart = &sysiso_current->restart_block;
 	struct alarm alarm;
 	ktime_t exp;
 	int ret = 0;
diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c
index 0ea8702eb..509630df5 100644
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -1556,6 +1556,8 @@ static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
 
 	memset(timer, 0, sizeof(struct hrtimer));
 
+	sysiso___hrtimer_init();
+
 	cpu_base = raw_cpu_ptr(&hrtimer_bases);
 
 	/*
@@ -1934,6 +1936,8 @@ static enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)
 		container_of(timer, struct hrtimer_sleeper, timer);
 	struct task_struct *task = t->task;
 
+	sysiso_hrtimer_wakeup(task);
+
 	t->task = NULL;
 	if (task)
 		wake_up_process(task);
@@ -1995,7 +1999,7 @@ static void __hrtimer_init_sleeper(struct hrtimer_sleeper *sl,
 
 	__hrtimer_init(&sl->timer, clock_id, mode);
 	sl->timer.function = hrtimer_wakeup;
-	sl->task = current;
+	sl->task = sysiso_current;
 }
 
 /**
@@ -2046,14 +2050,14 @@ static int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mod
 		hrtimer_cancel(&t->timer);
 		mode = HRTIMER_MODE_ABS;
 
-	} while (t->task && !signal_pending(current));
+	} while (t->task && !signal_pending(sysiso_current));
 
 	__set_current_state(TASK_RUNNING);
 
 	if (!t->task)
 		return 0;
 
-	restart = &current->restart_block;
+	restart = &sysiso_current->restart_block;
 	if (restart->nanosleep.type != TT_NONE) {
 		ktime_t rem = hrtimer_expires_remaining(&t->timer);
 		struct timespec64 rmt;
@@ -2088,7 +2092,7 @@ long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,
 	int ret = 0;
 	u64 slack;
 
-	slack = current->timer_slack_ns;
+	slack = sysiso_current->timer_slack_ns;
 	if (dl_task(current) || rt_task(current))
 		slack = 0;
 
@@ -2104,7 +2108,7 @@ long hrtimer_nanosleep(ktime_t rqtp, const enum hrtimer_mode mode,
 		goto out;
 	}
 
-	restart = &current->restart_block;
+	restart = &sysiso_current->restart_block;
 	restart->nanosleep.clockid = t.timer.base->clockid;
 	restart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);
 	set_restart_fn(restart, hrtimer_nanosleep_restart);
@@ -2126,8 +2130,8 @@ SYSCALL_DEFINE2(nanosleep, struct __kernel_timespec __user *, rqtp,
 	if (!timespec64_valid(&tu))
 		return -EINVAL;
 
-	current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
-	current->restart_block.nanosleep.rmtp = rmtp;
+	sysiso_current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
+	sysiso_current->restart_block.nanosleep.rmtp = rmtp;
 	return hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,
 				 CLOCK_MONOTONIC);
 }
@@ -2147,8 +2151,8 @@ SYSCALL_DEFINE2(nanosleep_time32, struct old_timespec32 __user *, rqtp,
 	if (!timespec64_valid(&tu))
 		return -EINVAL;
 
-	current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
-	current->restart_block.nanosleep.compat_rmtp = rmtp;
+	sysiso_current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
+	sysiso_current->restart_block.nanosleep.compat_rmtp = rmtp;
 	return hrtimer_nanosleep(timespec64_to_ktime(tu), HRTIMER_MODE_REL,
 				 CLOCK_MONOTONIC);
 }
@@ -2279,6 +2283,12 @@ schedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,
 			       const enum hrtimer_mode mode, clockid_t clock_id)
 {
 	struct hrtimer_sleeper t;
+	struct hrtimer_sleeper *pt;
+
+	if (!sysiso_current_is_server())
+		pt = &t;
+	else
+		pt = sysiso_get_hrtimer_sleeper(sysiso_current);
 
 	/*
 	 * Optimize when a zero timeout value is given. It does not
@@ -2293,23 +2303,25 @@ schedule_hrtimeout_range_clock(ktime_t *expires, u64 delta,
 	 * A NULL parameter means "infinite"
 	 */
 	if (!expires) {
-		schedule();
+		if (!sysiso_current_is_server())
+			schedule_linux();
 		return -EINTR;
 	}
 
-	hrtimer_init_sleeper_on_stack(&t, clock_id, mode);
-	hrtimer_set_expires_range_ns(&t.timer, *expires, delta);
-	hrtimer_sleeper_start_expires(&t, mode);
+	hrtimer_init_sleeper_on_stack(pt, clock_id, mode);
+	hrtimer_set_expires_range_ns(&pt->timer, *expires, delta);
+	hrtimer_sleeper_start_expires(pt, mode);
 
-	if (likely(t.task))
+	if (likely(pt->task))
 		schedule();
 
-	hrtimer_cancel(&t.timer);
-	destroy_hrtimer_on_stack(&t.timer);
+
+	hrtimer_cancel(&pt->timer);
+	destroy_hrtimer_on_stack(&pt->timer);
 
 	__set_current_state(TASK_RUNNING);
 
-	return !t.task ? 0 : -EINTR;
+	return !pt->task ? 0 : -EINTR;
 }
 
 /**
diff --git a/kernel/time/itimer.c b/kernel/time/itimer.c
index 00629e658..3e6c1bfab 100644
--- a/kernel/time/itimer.c
+++ b/kernel/time/itimer.c
@@ -343,7 +343,7 @@ SYSCALL_DEFINE3(setitimer, int, which, struct __kernel_old_itimerval __user *, v
 		memset(&set_buffer, 0, sizeof(set_buffer));
 		printk_once(KERN_WARNING "%s calls setitimer() with new_value NULL pointer."
 			    " Misfeature support will be removed\n",
-			    current->comm);
+			    sysiso_current->comm);
 	}
 
 	error = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);
@@ -390,7 +390,7 @@ COMPAT_SYSCALL_DEFINE3(setitimer, int, which,
 		memset(&set_buffer, 0, sizeof(set_buffer));
 		printk_once(KERN_WARNING "%s calls setitimer() with new_value NULL pointer."
 			    " Misfeature support will be removed\n",
-			    current->comm);
+			    sysiso_current->comm);
 	}
 
 	error = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);
diff --git a/kernel/time/posix-cpu-timers.c b/kernel/time/posix-cpu-timers.c
index 643d412ac..5ae7f77ad 100644
--- a/kernel/time/posix-cpu-timers.c
+++ b/kernel/time/posix-cpu-timers.c
@@ -61,7 +61,7 @@ static struct pid *pid_for_clock(const clockid_t clock, bool gettime)
 	 * or the process to which current belongs.
 	 */
 	if (upid == 0)
-		return thread ? task_pid(current) : task_tgid(current);
+		return thread ? task_pid(sysiso_current) : task_tgid(current);
 
 	pid = find_vpid(upid);
 	if (!pid)
@@ -69,7 +69,7 @@ static struct pid *pid_for_clock(const clockid_t clock, bool gettime)
 
 	if (thread) {
 		struct task_struct *tsk = pid_task(pid, PIDTYPE_PID);
-		return (tsk && same_thread_group(tsk, current)) ? pid : NULL;
+		return (tsk && same_thread_group(tsk, sysiso_current)) ? pid : NULL;
 	}
 
 	/*
@@ -78,7 +78,7 @@ static struct pid *pid_for_clock(const clockid_t clock, bool gettime)
 	 * of the process so that pid_task(pid, PIDTYPE_TGID) can be
 	 * used to find the process.
 	 */
-	if (gettime && (pid == task_pid(current)))
+	if (gettime && (pid == task_pid(sysiso_current)))
 		return task_tgid(current);
 
 	/*
@@ -875,7 +875,7 @@ static bool check_rlimit(u64 time, u64 limit, int signo, bool rt, bool hard)
 	if (print_fatal_signals) {
 		pr_info("%s Watchdog Timeout (%s): %s[%d]\n",
 			rt ? "RT" : "CPU", hard ? "hard" : "soft",
-			current->comm, task_pid_nr(current));
+			sysiso_current->comm, task_pid_nr(sysiso_current));
 	}
 	__group_send_sig_info(signo, SEND_SIG_PRIV, current);
 	return true;
@@ -1450,7 +1450,7 @@ static int do_cpu_nanosleep(const clockid_t which_clock, int flags,
 			return error;
 		}
 
-		while (!signal_pending(current)) {
+		while (!signal_pending(sysiso_current)) {
 			if (!cpu_timer_getexpires(&timer.it.cpu)) {
 				/*
 				 * Our timer fired and was reset, below
@@ -1505,7 +1505,7 @@ static int do_cpu_nanosleep(const clockid_t which_clock, int flags,
 		/*
 		 * Report back to the user the time still remaining.
 		 */
-		restart = &current->restart_block;
+		restart = &sysiso_current->restart_block;
 		restart->nanosleep.expires = expires;
 		if (restart->nanosleep.type != TT_NONE)
 			error = nanosleep_copyout(restart, &it.it_value);
@@ -1519,7 +1519,7 @@ static long posix_cpu_nsleep_restart(struct restart_block *restart_block);
 static int posix_cpu_nsleep(const clockid_t which_clock, int flags,
 			    const struct timespec64 *rqtp)
 {
-	struct restart_block *restart_block = &current->restart_block;
+	struct restart_block *restart_block = &sysiso_current->restart_block;
 	int error;
 
 	/*
@@ -1527,7 +1527,7 @@ static int posix_cpu_nsleep(const clockid_t which_clock, int flags,
 	 */
 	if (CPUCLOCK_PERTHREAD(which_clock) &&
 	    (CPUCLOCK_PID(which_clock) == 0 ||
-	     CPUCLOCK_PID(which_clock) == task_pid_vnr(current)))
+	     CPUCLOCK_PID(which_clock) == task_pid_vnr(sysiso_current)))
 		return -EINVAL;
 
 	error = do_cpu_nanosleep(which_clock, flags, rqtp);
diff --git a/kernel/time/posix-stubs.c b/kernel/time/posix-stubs.c
index fcb3b21d8..5f2ecc523 100644
--- a/kernel/time/posix-stubs.c
+++ b/kernel/time/posix-stubs.c
@@ -26,7 +26,7 @@ asmlinkage long sys_ni_posix_timers(void)
 {
 	pr_err_once("process %d (%s) attempted a POSIX timer syscall "
 		    "while CONFIG_POSIX_TIMERS is not set\n",
-		    current->pid, current->comm);
+		    sysiso_current->pid, sysiso_current->comm);
 	return -ENOSYS;
 }
 
@@ -146,8 +146,8 @@ SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,
 		return -EINVAL;
 	if (flags & TIMER_ABSTIME)
 		rmtp = NULL;
-	current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
-	current->restart_block.nanosleep.rmtp = rmtp;
+	sysiso_current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
+	sysiso_current->restart_block.nanosleep.rmtp = rmtp;
 	texp = timespec64_to_ktime(t);
 	if (flags & TIMER_ABSTIME)
 		texp = timens_ktime_to_host(which_clock, texp);
@@ -239,8 +239,8 @@ SYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,
 		return -EINVAL;
 	if (flags & TIMER_ABSTIME)
 		rmtp = NULL;
-	current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
-	current->restart_block.nanosleep.compat_rmtp = rmtp;
+	sysiso_current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
+	sysiso_current->restart_block.nanosleep.compat_rmtp = rmtp;
 	texp = timespec64_to_ktime(t);
 	if (flags & TIMER_ABSTIME)
 		texp = timens_ktime_to_host(which_clock, texp);
diff --git a/kernel/time/posix-timers.c b/kernel/time/posix-timers.c
index 1cd10b102..e59c612cd 100644
--- a/kernel/time/posix-timers.c
+++ b/kernel/time/posix-timers.c
@@ -39,7 +39,7 @@
  * Management arrays for POSIX timers. Timers are now kept in static hash table
  * with 512 entries.
  * Timer ids are allocated by local routine, which selects proper hash head by
- * key, constructed from current->signal address and per signal struct counter.
+ * key, constructed from sysiso_current->signal address and per signal struct counter.
  * This keeps timer ids unique per process, but now they can intersect between
  * processes.
  */
@@ -131,7 +131,7 @@ static struct k_itimer *__posix_timers_find(struct hlist_head *head,
 
 static struct k_itimer *posix_timer_by_id(timer_t id)
 {
-	struct signal_struct *sig = current->signal;
+	struct signal_struct *sig = sysiso_current->signal;
 	struct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];
 
 	return __posix_timers_find(head, sig, id);
@@ -139,7 +139,7 @@ static struct k_itimer *posix_timer_by_id(timer_t id)
 
 static int posix_timer_add(struct k_itimer *timer)
 {
-	struct signal_struct *sig = current->signal;
+	struct signal_struct *sig = sysiso_current->signal;
 	int first_free_id = sig->posix_timer_id;
 	struct hlist_head *head;
 	int ret = -ENOENT;
@@ -437,7 +437,7 @@ static struct pid *good_sigevent(sigevent_t * event)
 	case SIGEV_SIGNAL | SIGEV_THREAD_ID:
 		pid = find_vpid(event->sigev_notify_thread_id);
 		rtn = pid_task(pid, PIDTYPE_PID);
-		if (!rtn || !same_thread_group(rtn, current))
+		if (!rtn || !same_thread_group(rtn, sysiso_current))
 			return NULL;
 		fallthrough;
 	case SIGEV_SIGNAL:
@@ -557,10 +557,10 @@ static int do_timer_create(clockid_t which_clock, struct sigevent *event,
 	if (error)
 		goto out;
 
-	spin_lock_irq(&current->sighand->siglock);
-	new_timer->it_signal = current->signal;
+	spin_lock_irq(&sysiso_current->sighand->siglock);
+	new_timer->it_signal = sysiso_current->signal;
 	list_add(&new_timer->list, &current->signal->posix_timers);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	return 0;
 	/*
@@ -626,7 +626,7 @@ static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)
 	timr = posix_timer_by_id(timer_id);
 	if (timr) {
 		spin_lock_irqsave(&timr->it_lock, *flags);
-		if (timr->it_signal == current->signal) {
+		if (timr->it_signal == sysiso_current->signal) {
 			rcu_read_unlock();
 			return timr;
 		}
@@ -1018,9 +1018,9 @@ SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)
 		goto retry_delete;
 	}
 
-	spin_lock(&current->sighand->siglock);
+	spin_lock(&sysiso_current->sighand->siglock);
 	list_del(&timer->list);
-	spin_unlock(&current->sighand->siglock);
+	spin_unlock(&sysiso_current->sighand->siglock);
 	/*
 	 * This keeps any tasks waiting on the spin lock from thinking
 	 * they got something (see the lock code above).
@@ -1261,8 +1261,8 @@ SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,
 		return -EINVAL;
 	if (flags & TIMER_ABSTIME)
 		rmtp = NULL;
-	current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
-	current->restart_block.nanosleep.rmtp = rmtp;
+	sysiso_current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
+	sysiso_current->restart_block.nanosleep.rmtp = rmtp;
 
 	return kc->nsleep(which_clock, flags, &t);
 }
@@ -1288,8 +1288,8 @@ SYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,
 		return -EINVAL;
 	if (flags & TIMER_ABSTIME)
 		rmtp = NULL;
-	current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
-	current->restart_block.nanosleep.compat_rmtp = rmtp;
+	sysiso_current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
+	sysiso_current->restart_block.nanosleep.compat_rmtp = rmtp;
 
 	return kc->nsleep(which_clock, flags, &t);
 }
diff --git a/kernel/time/timer.c b/kernel/time/timer.c
index e3d2c23c4..d8b24afcb 100644
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@ -2046,7 +2046,7 @@ unsigned long msleep_interruptible(unsigned int msecs)
 {
 	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
 
-	while (timeout && !signal_pending(current))
+	while (timeout && !signal_pending(sysiso_current))
 		timeout = schedule_timeout_interruptible(timeout);
 	return jiffies_to_msecs(timeout);
 }
diff --git a/kernel/trace/blktrace.c b/kernel/trace/blktrace.c
index fa91f398f..32044ef07 100644
--- a/kernel/trace/blktrace.c
+++ b/kernel/trace/blktrace.c
@@ -173,10 +173,10 @@ void __trace_note_message(struct blk_trace *bt, struct blkcg *blkcg,
 	if (!(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))
 		blkcg = NULL;
 #ifdef CONFIG_BLK_CGROUP
-	trace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n,
+	trace_note(bt, sysiso_current->pid, BLK_TN_MESSAGE, buf, n,
 		   blkcg ? cgroup_id(blkcg->css.cgroup) : 1);
 #else
-	trace_note(bt, current->pid, BLK_TN_MESSAGE, buf, n, 0);
+	trace_note(bt, sysiso_current->pid, BLK_TN_MESSAGE, buf, n, 0);
 #endif
 	local_irq_restore(flags);
 }
@@ -216,7 +216,7 @@ static void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,
 		     int op, int op_flags, u32 what, int error, int pdu_len,
 		     void *pdu_data, u64 cgid)
 {
-	struct task_struct *tsk = current;
+	struct task_struct *tsk = sysiso_current;
 	struct ring_buffer_event *event = NULL;
 	struct trace_buffer *buffer = NULL;
 	struct blk_io_trace *t;
diff --git a/kernel/trace/bpf_trace.c b/kernel/trace/bpf_trace.c
index 8e2eb950a..c64c31be3 100644
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@ -330,7 +330,7 @@ BPF_CALL_3(bpf_probe_write_user, void __user *, unsafe_ptr, const void *, src,
 	 */
 
 	if (unlikely(in_interrupt() ||
-		     current->flags & (PF_KTHREAD | PF_EXITING)))
+		     sysiso_current->flags & (PF_KTHREAD | PF_EXITING)))
 		return -EPERM;
 	if (unlikely(uaccess_kernel()))
 		return -EPERM;
@@ -355,7 +355,7 @@ static const struct bpf_func_proto *bpf_get_probe_write_proto(void)
 		return NULL;
 
 	pr_warn_ratelimited("%s[%d] is installing a program with bpf_probe_write_user helper that may corrupt user memory!",
-			    current->comm, task_pid_nr(current));
+			    sysiso_current->comm, task_pid_nr(sysiso_current));
 
 	return &bpf_probe_write_user_proto;
 }
@@ -787,7 +787,7 @@ static int bpf_send_signal_common(u32 sig, enum pid_type type)
 	 * permitted in order to send signal to the current
 	 * task.
 	 */
-	if (unlikely(current->flags & (PF_KTHREAD | PF_EXITING)))
+	if (unlikely(sysiso_current->flags & (PF_KTHREAD | PF_EXITING)))
 		return -EPERM;
 	if (unlikely(uaccess_kernel()))
 		return -EPERM;
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index feebf57c6..e29b2e5c4 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -150,7 +150,7 @@ static void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,
 		if (pid == FTRACE_PID_IGNORE)
 			return;
 		if (pid != FTRACE_PID_TRACE &&
-		    pid != current->pid)
+		    pid != sysiso_current->pid)
 			return;
 	}
 
@@ -7374,7 +7374,7 @@ static void ignore_task_cpu(void *data)
 			       FTRACE_PID_IGNORE);
 	else
 		this_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,
-			       current->pid);
+			       sysiso_current->pid);
 }
 
 static ssize_t
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index c5a3fbf19..40e077016 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -952,7 +952,7 @@ int ring_buffer_wait(struct trace_buffer *buffer, int cpu, int full)
 		else
 			work->waiters_pending = true;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
@@ -1570,7 +1570,7 @@ static int __rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 		bpage->page = page_address(page);
 		rb_init_page(bpage->page);
 
-		if (user_thread && fatal_signal_pending(current))
+		if (user_thread && fatal_signal_pending(sysiso_current))
 			goto free_pages;
 	}
 	if (user_thread)
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index bc677cd64..fbacca6fa 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -3168,7 +3168,7 @@ ftrace_trace_userstack(struct trace_array *tr,
 		goto out_drop_count;
 	entry	= ring_buffer_event_data(event);
 
-	entry->tgid		= current->tgid;
+	entry->tgid		= sysiso_current->tgid;
 	memset(&entry->caller, 0, sizeof(entry->caller));
 
 	stack_trace_save_user(entry->caller, FTRACE_STACK_ENTRIES);
diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c
index c9124038b..225eecd58 100644
--- a/kernel/trace/trace_events_filter.c
+++ b/kernel/trace/trace_events_filter.c
@@ -737,7 +737,7 @@ static int filter_pred_comm(struct filter_pred *pred, void *event)
 {
 	int cmp;
 
-	cmp = pred->regex.match(current->comm, &pred->regex,
+	cmp = pred->regex.match(sysiso_current->comm, &pred->regex,
 				TASK_COMM_LEN);
 	return cmp ^ pred->not;
 }
diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c
index 3a64ba4bb..96b20a89e 100644
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@ -1346,7 +1346,7 @@ process_fetch_insn(struct fetch_insn *code, void *rec, void *dest,
 		val = code->immediate;
 		break;
 	case FETCH_OP_COMM:
-		val = (unsigned long)current->comm;
+		val = (unsigned long)sysiso_current->comm;
 		break;
 	case FETCH_OP_DATA:
 		val = (unsigned long)code->data;
diff --git a/kernel/trace/trace_osnoise.c b/kernel/trace/trace_osnoise.c
index ce053619f..593f4fd77 100644
--- a/kernel/trace/trace_osnoise.c
+++ b/kernel/trace/trace_osnoise.c
@@ -1111,7 +1111,7 @@ static int run_osnoise(void)
 	/*
 	 * Considers the current thread as the workload.
 	 */
-	osn_var->pid = current->pid;
+	osn_var->pid = sysiso_current->pid;
 
 	/*
 	 * Save the current stats for the diff
@@ -1436,7 +1436,7 @@ static int timerlat_main(void *data)
 	hrtimer_init(&tlat->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED_HARD);
 	tlat->timer.function = timerlat_irq;
 	tlat->kthread = current;
-	osn_var->pid = current->pid;
+	osn_var->pid = sysiso_current->pid;
 	/*
 	 * Anotate the arrival time.
 	 */
diff --git a/kernel/trace/trace_uprobe.c b/kernel/trace/trace_uprobe.c
index 225ce569b..14b3fe908 100644
--- a/kernel/trace/trace_uprobe.c
+++ b/kernel/trace/trace_uprobe.c
@@ -154,7 +154,7 @@ fetch_store_string(unsigned long addr, void *dest, void *base)
 		return -ENOMEM;
 
 	if (addr == FETCH_TOKEN_COMM)
-		ret = strlcpy(dst, current->comm, maxlen);
+		ret = strlcpy(dst, sysiso_current->comm, maxlen);
 	else
 		ret = strncpy_from_user(dst, src, maxlen);
 	if (ret >= 0) {
@@ -187,7 +187,7 @@ fetch_store_strlen(unsigned long addr)
 	void __user *vaddr = (void __force __user *) addr;
 
 	if (addr == FETCH_TOKEN_COMM)
-		len = strlen(current->comm) + 1;
+		len = strlen(sysiso_current->comm) + 1;
 	else
 		len = strnlen_user(vaddr, MAX_STRING_SIZE);
 
diff --git a/kernel/umh.c b/kernel/umh.c
index 36c123360..aa4beb84a 100644
--- a/kernel/umh.c
+++ b/kernel/umh.c
@@ -69,9 +69,9 @@ static int call_usermodehelper_exec_async(void *data)
 	struct cred *new;
 	int retval;
 
-	spin_lock_irq(&current->sighand->siglock);
+	spin_lock_irq(&sysiso_current->sighand->siglock);
 	flush_signal_handlers(current, 1);
-	spin_unlock_irq(&current->sighand->siglock);
+	spin_unlock_irq(&sysiso_current->sighand->siglock);
 
 	/*
 	 * Initial kernel threads share ther FS with init, in order to
@@ -79,7 +79,7 @@ static int call_usermodehelper_exec_async(void *data)
 	 * thread that is going to execve a user process and has its own
 	 * 'struct fs_struct'. Reset umask to the default.
 	 */
-	current->fs->umask = 0022;
+	sysiso_current->fs->umask = 0022;
 
 	/*
 	 * Our parent (unbound workqueue) runs with elevated scheduling
diff --git a/kernel/user_namespace.c b/kernel/user_namespace.c
index 6b2e3ca7e..09f46e656 100644
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@ -1331,7 +1331,7 @@ static int userns_install(struct nsset *nsset, struct ns_common *ns)
 	if (!thread_group_empty(current))
 		return -EINVAL;
 
-	if (current->fs->users != 1)
+	if (sysiso_current->fs->users != 1)
 		return -EINVAL;
 
 	if (!ns_capable(user_ns, CAP_SYS_ADMIN))
diff --git a/kernel/usermode_driver.c b/kernel/usermode_driver.c
index 9dae1f648..fc8be1029 100644
--- a/kernel/usermode_driver.c
+++ b/kernel/usermode_driver.c
@@ -127,7 +127,7 @@ static int umd_setup(struct subprocess_info *info, struct cred *new)
 		return err;
 	}
 
-	set_fs_pwd(current->fs, &umd_info->wd);
+	set_fs_pwd(sysiso_current->fs, &umd_info->wd);
 	umd_info->pipe_to_umh = to_umh[1];
 	umd_info->pipe_from_umh = from_umh[0];
 	umd_info->tgid = get_pid(task_tgid(current));
diff --git a/kernel/utsname_sysctl.c b/kernel/utsname_sysctl.c
index 4ca61d498..aa2b044a1 100644
--- a/kernel/utsname_sysctl.c
+++ b/kernel/utsname_sysctl.c
@@ -19,7 +19,7 @@ static void *get_uts(struct ctl_table *table)
 	char *which = table->data;
 	struct uts_namespace *uts_ns;
 
-	uts_ns = current->nsproxy->uts_ns;
+	uts_ns = sysiso_current->nsproxy->uts_ns;
 	which = (which - (char *)&init_uts_ns) + (char *)uts_ns;
 
 	return which;
diff --git a/kernel/watchdog.c b/kernel/watchdog.c
index ad912511a..5b7b4a275 100644
--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@ -426,7 +426,7 @@ static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)
 
 		pr_emerg("BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\n",
 			smp_processor_id(), duration,
-			current->comm, task_pid_nr(current));
+			sysiso_current->comm, task_pid_nr(sysiso_current));
 		print_modules();
 		print_irqtrace_events(current);
 		if (regs)
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 1b3eb1e95..82b844cf2 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -52,6 +52,8 @@
 #include <linux/nmi.h>
 #include <linux/kvm_para.h>
 
+/* #include <linux/sysiso.h> */
+
 #include "workqueue_internal.h"
 
 enum {
@@ -1439,10 +1441,14 @@ static void __queue_work(int cpu, struct workqueue_struct *wq,
 	if (unlikely(wq->flags & __WQ_DRAINING) &&
 	    WARN_ON_ONCE(!is_chained_work(wq)))
 		return;
+
+	sysiso__queue_work(work);
+
 	rcu_read_lock();
 retry:
 	/* pwq which will be used unless @work is executing elsewhere */
 	if (wq->flags & WQ_UNBOUND) {
+		/* SYSISO_TODO ensure that we run on an isolated CPU here! */
 		if (req_cpu == WORK_CPU_UNBOUND)
 			cpu = wq_select_unbound_cpu(raw_smp_processor_id());
 		pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));
@@ -2207,6 +2213,7 @@ __acquires(&pool->lock)
 
 	lockdep_copy_map(&lockdep_map, &work->lockdep_map);
 #endif
+
 	/* ensure we're on the correct CPU */
 	WARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&
 		     raw_smp_processor_id() != pool->cpu);
@@ -2306,7 +2313,7 @@ __acquires(&pool->lock)
 	if (unlikely(in_atomic() || lockdep_depth(current) > 0)) {
 		pr_err("BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"
 		       "     last function: %ps\n",
-		       current->comm, preempt_count(), task_pid_nr(current),
+		       sysiso_current->comm, preempt_count(), task_pid_nr(current),
 		       worker->current_func);
 		debug_show_held_locks(current);
 		dump_stack();
@@ -2365,9 +2372,9 @@ static void set_pf_worker(bool val)
 {
 	mutex_lock(&wq_pool_attach_mutex);
 	if (val)
-		current->flags |= PF_WQ_WORKER;
+		sysiso_current->flags |= PF_WQ_WORKER;
 	else
-		current->flags &= ~PF_WQ_WORKER;
+		sysiso_current->flags &= ~PF_WQ_WORKER;
 	mutex_unlock(&wq_pool_attach_mutex);
 }
 
@@ -2630,9 +2637,10 @@ static void check_flush_dependency(struct workqueue_struct *target_wq,
 
 	worker = current_wq_worker();
 
-	WARN_ONCE(current->flags & PF_MEMALLOC,
+	WARN_ONCE(sysiso_current->flags & PF_MEMALLOC,
 		  "workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%ps",
-		  current->pid, current->comm, target_wq->name, target_func);
+		  sysiso_current->pid, sysiso_current->comm, target_wq->name,
+		  target_func);
 	WARN_ONCE(worker && ((worker->current_pwq->wq->flags &
 			      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),
 		  "workqueue: WQ_MEM_RECLAIM %s:%ps is flushing !WQ_MEM_RECLAIM %s:%ps",
diff --git a/kernel/workqueue_internal.h b/kernel/workqueue_internal.h
index e00b1204a..2bae1a262 100644
--- a/kernel/workqueue_internal.h
+++ b/kernel/workqueue_internal.h
@@ -65,7 +65,7 @@ struct worker {
  */
 static inline struct worker *current_wq_worker(void)
 {
-	if (in_task() && (current->flags & PF_WQ_WORKER))
+	if (in_task() && (sysiso_current->flags & PF_WQ_WORKER))
 		return kthread_data(current);
 	return NULL;
 }
diff --git a/lib/dump_stack.c b/lib/dump_stack.c
index 6b7f1bf67..3fb3d6654 100644
--- a/lib/dump_stack.c
+++ b/lib/dump_stack.c
@@ -55,7 +55,8 @@ void __init dump_stack_set_arch_desc(const char *fmt, ...)
 void dump_stack_print_info(const char *log_lvl)
 {
 	printk("%sCPU: %d PID: %d Comm: %.20s %s%s %s %.*s" BUILD_ID_FMT "\n",
-	       log_lvl, raw_smp_processor_id(), current->pid, current->comm,
+	       log_lvl, raw_smp_processor_id(), sysiso_current->pid,
+	       sysiso_current->comm,
 	       kexec_crash_loaded() ? "Kdump: loaded " : "",
 	       print_tainted(),
 	       init_utsname()->release,
diff --git a/lib/dynamic_debug.c b/lib/dynamic_debug.c
index cb5abb42c..93564564f 100644
--- a/lib/dynamic_debug.c
+++ b/lib/dynamic_debug.c
@@ -596,7 +596,7 @@ static char *__dynamic_emit_prefix(const struct _ddebug *desc, char *buf)
 			pos += snprintf(buf + pos, remaining(pos), "<intr> ");
 		else
 			pos += snprintf(buf + pos, remaining(pos), "[%d] ",
-					task_pid_vnr(current));
+					task_pid_vnr(sysiso_current));
 	}
 	pos_after_tid = pos;
 	if (desc->flags & _DPRINTK_FLAGS_INCL_MODNAME)
diff --git a/lib/nlattr.c b/lib/nlattr.c
index 86029ad5e..20dff88aa 100644
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@ -193,7 +193,7 @@ static int nla_validate_range_unsigned(const struct nla_policy *pt,
 	if (pt->validation_type == NLA_VALIDATE_RANGE_WARN_TOO_LONG &&
 	    pt->type == NLA_BINARY && value > range.max) {
 		pr_warn_ratelimited("netlink: '%s': attribute type %d has an invalid length.\n",
-				    current->comm, pt->type);
+				    sysiso_current->comm, pt->type);
 		if (validate & NL_VALIDATE_STRICT_ATTRS) {
 			NL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,
 						"invalid attribute length");
@@ -375,7 +375,7 @@ static int validate_nla(const struct nlattr *nla, int maxtype,
 
 	if (nla_attr_len[pt->type] && attrlen != nla_attr_len[pt->type]) {
 		pr_warn_ratelimited("netlink: '%s': attribute type %d has an invalid length.\n",
-				    current->comm, type);
+				    sysiso_current->comm, type);
 		if (validate & NL_VALIDATE_STRICT_ATTRS) {
 			NL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,
 						"invalid attribute length");
@@ -598,7 +598,7 @@ static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,
 
 	if (unlikely(rem > 0)) {
 		pr_warn_ratelimited("netlink: %d bytes leftover after parsing attributes in process `%s'.\n",
-				    rem, current->comm);
+				    rem, sysiso_current->comm);
 		NL_SET_ERR_MSG(extack, "bytes leftover after parsing attributes");
 		if (validate & NL_VALIDATE_TRAILING)
 			return -EINVAL;
diff --git a/lib/smp_processor_id.c b/lib/smp_processor_id.c
index 046ac6297..955c17594 100644
--- a/lib/smp_processor_id.c
+++ b/lib/smp_processor_id.c
@@ -43,7 +43,8 @@ unsigned int check_preemption_disabled(const char *what1, const char *what2)
 		goto out_enable;
 
 	printk(KERN_ERR "BUG: using %s%s() in preemptible [%08x] code: %s/%d\n",
-		what1, what2, preempt_count() - 1, current->comm, current->pid);
+		what1, what2, preempt_count() - 1, sysiso_current->comm,
+		sysiso_current->pid);
 
 	printk("caller is %pS\n", __builtin_return_address(0));
 	dump_stack();
diff --git a/mm/compaction.c b/mm/compaction.c
index bfc93da1c..42443b80f 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -532,7 +532,7 @@ static bool compact_unlock_should_abort(spinlock_t *lock,
 		*locked = false;
 	}
 
-	if (fatal_signal_pending(current)) {
+	if (fatal_signal_pending(sysiso_current)) {
 		cc->contended = true;
 		return true;
 	}
@@ -824,7 +824,7 @@ isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,
 
 		congestion_wait(BLK_RW_ASYNC, HZ/10);
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return -EINTR;
 	}
 
@@ -871,7 +871,7 @@ isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,
 				locked = NULL;
 			}
 
-			if (fatal_signal_pending(current)) {
+			if (fatal_signal_pending(sysiso_current)) {
 				cc->contended = true;
 				ret = -EINTR;
 
@@ -2127,7 +2127,7 @@ static enum compact_result __compact_finished(struct compact_control *cc)
 	}
 
 out:
-	if (cc->contended || fatal_signal_pending(current))
+	if (cc->contended || fatal_signal_pending(sysiso_current))
 		ret = COMPACT_CONTENDED;
 
 	return ret;
@@ -2608,7 +2608,7 @@ enum compact_result try_to_compact_pages(gfp_t gfp_mask, unsigned int order,
 		 * case do not try further zones
 		 */
 		if ((prio == COMPACT_PRIO_ASYNC && need_resched())
-					|| fatal_signal_pending(current))
+					|| fatal_signal_pending(sysiso_current))
 			break;
 	}
 
diff --git a/mm/filemap.c b/mm/filemap.c
index dae481293..7e3ca17a3 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -168,7 +168,7 @@ static void unaccount_page_cache_page(struct address_space *mapping,
 		int mapcount;
 
 		pr_alert("BUG: Bad page cache in process %s  pfn:%05lx\n",
-			 current->comm, page_to_pfn(page));
+			 sysiso_current->comm, page_to_pfn(page));
 		dump_page(page, "still mapped when deleted");
 		dump_stack();
 		add_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);
@@ -1190,6 +1190,9 @@ static void wake_up_page_bit(struct page *page, int bit_nr)
 	bookmark.flags = 0;
 	bookmark.private = NULL;
 	bookmark.func = NULL;
+#ifdef CONFIG_SYSISO
+	bookmark.sysiso_task = NULL;
+#endif
 	INIT_LIST_HEAD(&bookmark.entry);
 
 	spin_lock_irqsave(&q->lock, flags);
@@ -1350,7 +1353,7 @@ static inline int wait_on_page_bit_common(wait_queue_head_t *q,
 		/* Loop until we've been woken or interrupted */
 		flags = smp_load_acquire(&wait->flags);
 		if (!(flags & WQ_FLAG_WOKEN)) {
-			if (signal_pending_state(state, current))
+			if (signal_pending_state(state, sysiso_current))
 				break;
 
 			io_schedule();
@@ -2535,7 +2538,7 @@ static int filemap_get_pages(struct kiocb *iocb, struct iov_iter *iter,
 
 	last_index = DIV_ROUND_UP(iocb->ki_pos + iter->count, PAGE_SIZE);
 retry:
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 	filemap_get_read_batch(mapping, index, last_index, pvec);
@@ -3620,8 +3623,9 @@ void dio_warn_stale_pagecache(struct file *filp)
 		if (IS_ERR(path))
 			path = "(unknown)";
 		pr_crit("Page cache invalidation failure on direct I/O.  Possible data corruption due to collision with buffered I/O!\n");
-		pr_crit("File: %s PID: %d Comm: %.20s\n", path, current->pid,
-			current->comm);
+		pr_crit("File: %s PID: %d Comm: %.20s\n", path,
+			sysiso_current->pid,
+			sysiso_current->comm);
 	}
 }
 
@@ -3762,7 +3766,7 @@ ssize_t generic_perform_write(struct file *file,
 			break;
 		}
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			status = -EINTR;
 			break;
 		}
diff --git a/mm/gup.c b/mm/gup.c
index 886d6148d..60bd61601 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -1147,7 +1147,7 @@ static long __get_user_pages(struct mm_struct *mm,
 		 * If we have a pending SIGKILL, don't keep faulting pages and
 		 * potentially allocating memory.
 		 */
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			goto out;
 		}
@@ -1277,7 +1277,7 @@ int fixup_user_fault(struct mm_struct *mm,
 		return -EFAULT;
 
 	if ((fault_flags & FAULT_FLAG_KILLABLE) &&
-	    fatal_signal_pending(current))
+	    fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 	ret = handle_mm_fault(vma, address, fault_flags, NULL);
@@ -1385,7 +1385,7 @@ static __always_inline long __get_user_pages_locked(struct mm_struct *mm,
 		 * start trying again otherwise it can loop forever.
 		 */
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			if (!pages_done)
 				pages_done = -EINTR;
 			break;
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 95dc7b833..1962d5854 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -1083,7 +1083,7 @@ static void enqueue_huge_page(struct hstate *h, struct page *page)
 static struct page *dequeue_huge_page_node_exact(struct hstate *h, int nid)
 {
 	struct page *page;
-	bool pin = !!(current->flags & PF_MEMALLOC_PIN);
+	bool pin = !!(sysiso_current->flags & PF_MEMALLOC_PIN);
 
 	lockdep_assert_held(&hugetlb_lock);
 	list_for_each_entry(page, &h->hugepage_freelists[nid], lru) {
@@ -3182,7 +3182,7 @@ static int set_max_huge_pages(struct hstate *h, unsigned long count, int nid,
 			goto out;
 
 		/* Bail for signals. Probably ctrl-c from user */
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out;
 	}
 
@@ -4882,7 +4882,7 @@ static vm_fault_t hugetlb_no_page(struct mm_struct *mm,
 	 */
 	if (is_vma_resv_set(vma, HPAGE_RESV_UNMAPPED)) {
 		pr_warn_ratelimited("PID %d killed due to inadequate hugepage pool\n",
-			   current->pid);
+			   sysiso_current->pid);
 		return ret;
 	}
 
@@ -5436,7 +5436,7 @@ long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,
 		 * If we have a pending SIGKILL, don't keep faulting pages and
 		 * potentially allocating memory.
 		 */
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			remainder = 0;
 			break;
 		}
diff --git a/mm/kasan/common.c b/mm/kasan/common.c
index 2baf121fb..5b82a3a60 100644
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@ -42,7 +42,7 @@ depot_stack_handle_t kasan_save_stack(gfp_t flags)
 
 void kasan_set_track(struct kasan_track *track, gfp_t flags)
 {
-	track->pid = current->pid;
+	track->pid = sysiso_current->pid;
 	track->stack = kasan_save_stack(flags);
 }
 
diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index 884a950c7..8bd4d7094 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -91,11 +91,13 @@ static void print_error_description(struct kasan_access_info *info)
 	if (info->access_size)
 		pr_err("%s of size %zu at addr %px by task %s/%d\n",
 			info->is_write ? "Write" : "Read", info->access_size,
-			info->access_addr, current->comm, task_pid_nr(current));
+			info->access_addr, sysiso_current->comm,
+			task_pid_nr(sysiso_current));
 	else
 		pr_err("%s at addr %px by task %s/%d\n",
 			info->is_write ? "Write" : "Read",
-			info->access_addr, current->comm, task_pid_nr(current));
+			info->access_addr, sysiso_current->comm,
+			task_pid_nr(sysiso_current));
 }
 
 static DEFINE_SPINLOCK(report_lock);
diff --git a/mm/kasan/report_generic.c b/mm/kasan/report_generic.c
index 139615ef3..033865d66 100644
--- a/mm/kasan/report_generic.c
+++ b/mm/kasan/report_generic.c
@@ -279,7 +279,7 @@ void kasan_print_address_stack_frame(const void *addr)
 	 */
 	pr_err("\n");
 	pr_err("addr %px is located in stack of task %s/%d at offset %lu in frame:\n",
-	       addr, current->comm, task_pid_nr(current), offset);
+	       addr, sysiso_current->comm, task_pid_nr(sysiso_current), offset);
 	pr_err(" %pS\n", frame_pc);
 
 	if (!frame_descr)
diff --git a/mm/kfence/core.c b/mm/kfence/core.c
index 7a97db8bc..bbdd2253d 100644
--- a/mm/kfence/core.c
+++ b/mm/kfence/core.c
@@ -196,7 +196,7 @@ static noinline void metadata_update_state(struct kfence_metadata *meta,
 	 * skip over the caller by never inlining.
 	 */
 	track->num_stack_entries = stack_trace_save(track->stack_entries, KFENCE_STACK_DEPTH, 1);
-	track->pid = task_pid_nr(current);
+	track->pid = task_pid_nr(sysiso_current);
 	track->cpu = raw_smp_processor_id();
 	track->ts_nsec = local_clock(); /* Same source as printk timestamps. */
 
diff --git a/mm/kmemleak.c b/mm/kmemleak.c
index b57383c17..fb0020df9 100644
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -606,14 +606,14 @@ static struct kmemleak_object *create_object(unsigned long ptr, size_t size,
 		object->pid = 0;
 		strncpy(object->comm, "softirq", sizeof(object->comm));
 	} else {
-		object->pid = current->pid;
+		object->pid = sysiso_current->pid;
 		/*
 		 * There is a small chance of a race with set_task_comm(),
 		 * however using get_task_comm() here may cause locking
 		 * dependency issues with current->alloc_lock. In the worst
 		 * case, the command line is not correct.
 		 */
-		strncpy(object->comm, current->comm, sizeof(object->comm));
+		strncpy(object->comm, sysiso_current->comm, sizeof(object->comm));
 	}
 
 	/* kernel backtrace */
@@ -1217,7 +1217,7 @@ static int scan_should_stop(void)
 	 * hence the need to check for both stop conditions.
 	 */
 	if (current->mm)
-		return signal_pending(current);
+		return signal_pending(sysiso_current);
 	else
 		return kthread_should_stop();
 
diff --git a/mm/ksm.c b/mm/ksm.c
index a5716fdec..cdf0c9651 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -844,7 +844,7 @@ static int unmerge_ksm_pages(struct vm_area_struct *vma,
 	for (addr = start; addr < end && !err; addr += PAGE_SIZE) {
 		if (ksm_test_exit(vma->vm_mm))
 			break;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			err = -ERESTARTSYS;
 		else
 			err = break_ksm(vma, addr);
@@ -2382,7 +2382,7 @@ static void ksm_do_scan(unsigned int scan_npages)
 	struct rmap_item *rmap_item;
 	struct page *page;
 
-	while (scan_npages-- && likely(!freezing(current))) {
+	while (scan_npages-- && likely(!freezing(sysiso_current))) {
 		cond_resched();
 		rmap_item = scan_get_next_rmap_item(&page);
 		if (!rmap_item)
diff --git a/mm/madvise.c b/mm/madvise.c
index 0734db8d5..d03d94b7b 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -319,7 +319,7 @@ static int madvise_cold_or_pageout_pte_range(pmd_t *pmd,
 	struct page *page = NULL;
 	LIST_HEAD(page_list);
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return -EINTR;
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 6da5020a8..1582ff024 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -241,8 +241,8 @@ enum res_type {
 
 static inline bool should_force_charge(void)
 {
-	return tsk_is_oom_victim(current) || fatal_signal_pending(current) ||
-		(current->flags & PF_EXITING);
+	return tsk_is_oom_victim(sysiso_current) || fatal_signal_pending(sysiso_current) ||
+		(sysiso_current->flags & PF_EXITING);
 }
 
 /* Some nice accessors for the vmpressure. */
@@ -936,7 +936,7 @@ static __always_inline bool memcg_kmem_bypass(void)
 		return false;
 
 	/* Memcg to charge can't be determined. */
-	if (!in_task() || !current->mm || (current->flags & PF_KTHREAD))
+	if (!in_task() || !current->mm || (sysiso_current->flags & PF_KTHREAD))
 		return true;
 
 	return false;
@@ -2579,7 +2579,7 @@ static int try_charge_memcg(struct mem_cgroup *memcg, gfp_t gfp_mask,
 	 * but we prefer facilitating memory reclaim and getting back
 	 * under the limit over triggering OOM kills in these cases.
 	 */
-	if (unlikely(current->flags & PF_MEMALLOC))
+	if (unlikely(sysiso_current->flags & PF_MEMALLOC))
 		goto force;
 
 	if (unlikely(task_in_memcg_oom(current)))
@@ -2630,7 +2630,7 @@ static int try_charge_memcg(struct mem_cgroup *memcg, gfp_t gfp_mask,
 	if (gfp_mask & __GFP_RETRY_MAYFAIL)
 		goto nomem;
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		goto force;
 
 	/*
@@ -3322,7 +3322,7 @@ static int mem_cgroup_resize_max(struct mem_cgroup *memcg,
 	struct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;
 
 	do {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
@@ -3467,7 +3467,7 @@ static int mem_cgroup_force_empty(struct mem_cgroup *memcg)
 	while (nr_retries && page_counter_read(&memcg->memory)) {
 		int progress;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -EINTR;
 
 		progress = try_to_free_mem_cgroup_pages(memcg, 1,
@@ -6249,7 +6249,7 @@ static ssize_t memory_high_write(struct kernfs_open_file *of,
 		if (nr_pages <= high)
 			break;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		if (!drained) {
@@ -6297,7 +6297,7 @@ static ssize_t memory_max_write(struct kernfs_open_file *of,
 		if (nr_pages <= max)
 			break;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		if (!drained) {
diff --git a/mm/memory.c b/mm/memory.c
index c52be6d6b..39f221800 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -545,7 +545,7 @@ static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,
 	index = linear_page_index(vma, addr);
 
 	pr_alert("BUG: Bad page map in process %s  pte:%08llx pmd:%08llx\n",
-		 current->comm,
+		 sysiso_current->comm,
 		 (long long)pte_val(pte), (long long)pmd_val(*pmd));
 	if (page)
 		dump_page(page, "bad pte");
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index 9fd0be32a..dbb4425f6 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -1950,7 +1950,7 @@ int __ref offline_pages(unsigned long start_pfn, unsigned long nr_pages,
 	do {
 		pfn = start_pfn;
 		do {
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				ret = -EINTR;
 				reason = "signal backoff";
 				goto failed_removal_isolated;
diff --git a/mm/mempolicy.c b/mm/mempolicy.c
index d12e0608f..7c6a86aed 100644
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@ -861,12 +861,12 @@ static long do_set_mempolicy(unsigned short mode, unsigned short flags,
 		mpol_put(new);
 		goto out;
 	}
-	task_lock(current);
+	task_lock(sysiso_current);
 	old = current->mempolicy;
 	current->mempolicy = new;
 	if (new && new->mode == MPOL_INTERLEAVE)
 		current->il_prev = MAX_NUMNODES-1;
-	task_unlock(current);
+	task_unlock(sysiso_current);
 	mpol_put(old);
 	ret = 0;
 out:
@@ -933,9 +933,9 @@ static long do_get_mempolicy(int *policy, nodemask_t *nmask,
 		if (flags & (MPOL_F_NODE|MPOL_F_ADDR))
 			return -EINVAL;
 		*policy = 0;	/* just so it's initialized */
-		task_lock(current);
+		task_lock(sysiso_current);
 		*nmask  = cpuset_current_mems_allowed;
-		task_unlock(current);
+		task_unlock(sysiso_current);
 		return 0;
 	}
 
@@ -998,9 +998,9 @@ static long do_get_mempolicy(int *policy, nodemask_t *nmask,
 		if (mpol_store_user_nodemask(pol)) {
 			*nmask = pol->w.user_nodemask;
 		} else {
-			task_lock(current);
+			task_lock(sysiso_current);
 			get_policy_nodemask(pol, nmask);
-			task_unlock(current);
+			task_unlock(sysiso_current);
 		}
 	}
 
@@ -1975,7 +1975,7 @@ bool init_nodemask_of_mempolicy(nodemask_t *mask)
 	if (!(mask && current->mempolicy))
 		return false;
 
-	task_lock(current);
+	task_lock(sysiso_current);
 	mempolicy = current->mempolicy;
 	switch (mempolicy->mode) {
 	case MPOL_PREFERRED:
@@ -1992,7 +1992,7 @@ bool init_nodemask_of_mempolicy(nodemask_t *mask)
 	default:
 		BUG();
 	}
-	task_unlock(current);
+	task_unlock(sysiso_current);
 
 	return true;
 }
@@ -2227,9 +2227,9 @@ struct mempolicy *__mpol_dup(struct mempolicy *old)
 
 	/* task's mempolicy is protected by alloc_lock */
 	if (old == current->mempolicy) {
-		task_lock(current);
+		task_lock(sysiso_current);
 		*new = *old;
-		task_unlock(current);
+		task_unlock(sysiso_current);
 	} else
 		*new = *old;
 
@@ -2600,9 +2600,9 @@ void mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)
 		if (IS_ERR(new))
 			goto free_scratch; /* no valid nodemask intersection */
 
-		task_lock(current);
+		task_lock(sysiso_current);
 		ret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);
-		task_unlock(current);
+		task_unlock(sysiso_current);
 		if (ret)
 			goto put_new;
 
diff --git a/mm/migrate.c b/mm/migrate.c
index 1852d787e..e9171e87c 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -981,7 +981,7 @@ static int __unmap_and_move(struct page *page, struct page *newpage,
 		 * avoid the use of lock_page for direct compaction
 		 * altogether.
 		 */
-		if (current->flags & PF_MEMALLOC)
+		if (sysiso_current->flags & PF_MEMALLOC)
 			goto out;
 
 		lock_page(page);
@@ -1454,7 +1454,7 @@ int migrate_pages(struct list_head *from, new_page_t get_new_page,
 	bool is_thp = false;
 	struct page *page;
 	struct page *page2;
-	int swapwrite = current->flags & PF_SWAPWRITE;
+	int swapwrite = sysiso_current->flags & PF_SWAPWRITE;
 	int rc, nr_subpages;
 	LIST_HEAD(ret_pages);
 	bool nosplit = (reason == MR_NUMA_MISPLACED);
@@ -1462,7 +1462,7 @@ int migrate_pages(struct list_head *from, new_page_t get_new_page,
 	trace_mm_migrate_pages_start(mode, reason);
 
 	if (!swapwrite)
-		current->flags |= PF_SWAPWRITE;
+		sysiso_current->flags |= PF_SWAPWRITE;
 
 	for (pass = 0; pass < 10 && (retry || thp_retry); pass++) {
 		retry = 0;
@@ -1594,7 +1594,7 @@ int migrate_pages(struct list_head *from, new_page_t get_new_page,
 			       nr_thp_failed, nr_thp_split, mode, reason);
 
 	if (!swapwrite)
-		current->flags &= ~PF_SWAPWRITE;
+		sysiso_current->flags &= ~PF_SWAPWRITE;
 
 	if (ret_succeeded)
 		*ret_succeeded = nr_succeeded;
diff --git a/mm/mmap.c b/mm/mmap.c
index 88dcc5c25..7594dbf1b 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1421,7 +1421,7 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 	 * (the exception is when the underlying filesystem is noexec
 	 *  mounted, in which case we dont add PROT_EXEC.)
 	 */
-	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+	if ((prot & PROT_READ) && (sysiso_current->personality & READ_IMPLIES_EXEC))
 		if (!(file && path_noexec(&file->f_path)))
 			prot |= PROT_EXEC;
 
@@ -2948,7 +2948,7 @@ SYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,
 	struct file *file;
 
 	pr_warn_once("%s (%d) uses deprecated remap_file_pages() syscall. See Documentation/vm/remap_file_pages.rst.\n",
-		     current->comm, current->pid);
+		     sysiso_current->comm, current->pid);
 
 	if (prot)
 		return ret;
@@ -3318,7 +3318,7 @@ bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)
 			return true;
 
 		pr_warn_once("%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\n",
-			     current->comm, current->pid,
+			     sysiso_current->comm, sysiso_current->pid,
 			     (mm->data_vm + npages) << PAGE_SHIFT,
 			     rlimit(RLIMIT_DATA),
 			     ignore_rlimit_data ? "" : " or use boot option ignore_rlimit_data");
@@ -3589,7 +3589,7 @@ int mm_take_all_locks(struct mm_struct *mm)
 	mutex_lock(&mm_all_locks_mutex);
 
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out_unlock;
 		if (vma->vm_file && vma->vm_file->f_mapping &&
 				is_vm_hugetlb_page(vma))
@@ -3597,7 +3597,7 @@ int mm_take_all_locks(struct mm_struct *mm)
 	}
 
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out_unlock;
 		if (vma->vm_file && vma->vm_file->f_mapping &&
 				!is_vm_hugetlb_page(vma))
@@ -3605,7 +3605,7 @@ int mm_take_all_locks(struct mm_struct *mm)
 	}
 
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out_unlock;
 		if (vma->anon_vma)
 			list_for_each_entry(avc, &vma->anon_vma_chain, same_vma)
diff --git a/mm/mprotect.c b/mm/mprotect.c
index 883e2cc85..a4805d426 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -526,7 +526,7 @@ static int do_mprotect_pkey(unsigned long start, size_t len,
 	struct vm_area_struct *vma, *prev;
 	int error = -EINVAL;
 	const int grows = prot & (PROT_GROWSDOWN|PROT_GROWSUP);
-	const bool rier = (current->personality & READ_IMPLIES_EXEC) &&
+	const bool rier = (sysiso_current->personality & READ_IMPLIES_EXEC) &&
 				(prot & PROT_READ);
 
 	start = untagged_addr(start);
diff --git a/mm/mremap.c b/mm/mremap.c
index badfe17ad..269b25b80 100644
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@ -728,7 +728,8 @@ static struct vm_area_struct *vma_to_resize(unsigned long addr,
 	 * behavior.  As a result, fail such attempts.
 	 */
 	if (!old_len && !(vma->vm_flags & (VM_SHARED | VM_MAYSHARE))) {
-		pr_warn_once("%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\n", current->comm, current->pid);
+		pr_warn_once("%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\n", sysiso_current->comm,
+			     sysiso_current->pid);
 		return ERR_PTR(-EINVAL);
 	}
 
diff --git a/mm/nommu.c b/mm/nommu.c
index 02d2427b8..f583414ae 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -863,7 +863,7 @@ static int validate_mmap_request(struct file *file,
 				return -EPERM;
 		} else if ((prot & PROT_READ) && !(prot & PROT_EXEC)) {
 			/* handle implication of PROT_EXEC by PROT_READ */
-			if (current->personality & READ_IMPLIES_EXEC) {
+			if (sysiso_current->personality & READ_IMPLIES_EXEC) {
 				if (capabilities & NOMMU_MAP_EXEC)
 					prot |= PROT_EXEC;
 			}
@@ -882,7 +882,7 @@ static int validate_mmap_request(struct file *file,
 
 		/* handle PROT_EXEC implication by PROT_READ */
 		if ((prot & PROT_READ) &&
-		    (current->personality & READ_IMPLIES_EXEC))
+		    (sysiso_current->personality & READ_IMPLIES_EXEC))
 			prot |= PROT_EXEC;
 	}
 
@@ -1045,7 +1045,7 @@ static int do_mmap_private(struct vm_area_struct *vma,
 
 enomem:
 	pr_err("Allocation of length %lu from process %d (%s) failed\n",
-	       len, current->pid, current->comm);
+	       len, sysiso_current->pid, sysiso_current->comm);
 	show_free_areas(0, NULL);
 	return -ENOMEM;
 }
@@ -1268,13 +1268,13 @@ unsigned long do_mmap(struct file *file,
 error_getting_vma:
 	kmem_cache_free(vm_region_jar, region);
 	pr_warn("Allocation of vma for %lu byte allocation from process %d failed\n",
-			len, current->pid);
+			len, sysiso_current->pid);
 	show_free_areas(0, NULL);
 	return -ENOMEM;
 
 error_getting_region:
 	pr_warn("Allocation of vm region for %lu byte allocation from process %d failed\n",
-			len, current->pid);
+			len, sysiso_current->pid);
 	show_free_areas(0, NULL);
 	return -ENOMEM;
 }
@@ -1456,7 +1456,7 @@ int do_munmap(struct mm_struct *mm, unsigned long start, size_t len, struct list
 		static int limit;
 		if (limit < 5) {
 			pr_warn("munmap of memory not mmapped by process %d (%s): 0x%lx-0x%lx\n",
-					current->pid, current->comm,
+					sysiso_current->pid, sysiso_current->comm,
 					start, start + len - 1);
 			limit++;
 		}
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 989f35a2b..629fd946f 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -455,8 +455,8 @@ static void dump_oom_summary(struct oom_control *oc, struct task_struct *victim)
 static void dump_header(struct oom_control *oc, struct task_struct *p)
 {
 	pr_warn("%s invoked oom-killer: gfp_mask=%#x(%pGg), order=%d, oom_score_adj=%hd\n",
-		current->comm, oc->gfp_mask, &oc->gfp_mask, oc->order,
-			current->signal->oom_score_adj);
+		sysiso_current->comm, oc->gfp_mask, &oc->gfp_mask, oc->order,
+			sysiso_current->signal->oom_score_adj);
 	if (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)
 		pr_warn("COMPACTION is disabled!!!\n");
 
@@ -1093,7 +1093,7 @@ bool out_of_memory(struct oom_control *oc)
 	if (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&
 	    current->mm && !oom_unkillable_task(current) &&
 	    oom_cpuset_eligible(current, oc) &&
-	    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {
+	    sysiso_current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {
 		get_task_struct(current);
 		oc->chosen = current;
 		oom_kill_process(oc, "Out of memory (oom_kill_allocating_task)");
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 4812a17b2..e825cbdc0 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -1672,7 +1672,7 @@ static void balance_dirty_pages(struct bdi_writeback *wb,
 		if (!strictlimit) {
 			wb_dirty_limits(gdtc);
 
-			if ((current->flags & PF_LOCAL_THROTTLE) &&
+			if ((sysiso_current->flags & PF_LOCAL_THROTTLE) &&
 			    gdtc->wb_dirty <
 			    dirty_freerun_ceiling(gdtc->wb_thresh,
 						  gdtc->wb_bg_thresh))
@@ -1699,7 +1699,7 @@ static void balance_dirty_pages(struct bdi_writeback *wb,
 			if (!strictlimit) {
 				wb_dirty_limits(mdtc);
 
-				if ((current->flags & PF_LOCAL_THROTTLE) &&
+				if ((sysiso_current->flags & PF_LOCAL_THROTTLE) &&
 				    mdtc->wb_dirty <
 				    dirty_freerun_ceiling(mdtc->wb_thresh,
 							  mdtc->wb_bg_thresh))
@@ -1820,7 +1820,7 @@ static void balance_dirty_pages(struct bdi_writeback *wb,
 		if (sdtc->wb_dirty <= wb_stat_error())
 			break;
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			break;
 	}
 
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 23d3339ac..ef5f822c5 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -645,7 +645,7 @@ static void bad_page(struct page *page, const char *reason)
 		resume = jiffies + 60 * HZ;
 
 	pr_alert("BUG: Bad page state in process %s  pfn:%05lx\n",
-		current->comm, page_to_pfn(page));
+		sysiso_current->comm, page_to_pfn(page));
 	dump_page(page, reason);
 
 	print_modules();
@@ -915,7 +915,7 @@ static inline struct capture_control *task_capc(struct zone *zone)
 	struct capture_control *capc = current->capture_control;
 
 	return unlikely(capc) &&
-		!(current->flags & PF_KTHREAD) &&
+		!(sysiso_current->flags & PF_KTHREAD) &&
 		!capc->page &&
 		capc->cc->zone == zone ? capc : NULL;
 }
@@ -4196,7 +4196,7 @@ static void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)
 	 */
 	if (!(gfp_mask & __GFP_NOMEMALLOC))
 		if (tsk_is_oom_victim(current) ||
-		    (current->flags & (PF_MEMALLOC | PF_EXITING)))
+		    (sysiso_current->flags & (PF_MEMALLOC | PF_EXITING)))
 			filter &= ~SHOW_MEM_FILTER_NODES;
 	if (!in_task() || !(gfp_mask & __GFP_DIRECT_RECLAIM))
 		filter &= ~SHOW_MEM_FILTER_NODES;
@@ -4217,7 +4217,7 @@ void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)
 	vaf.fmt = fmt;
 	vaf.va = &args;
 	pr_warn("%s: %pV, mode:%#x(%pGg), nodemask=%*pbl",
-			current->comm, &vaf, gfp_mask, &gfp_mask,
+			sysiso_current->comm, &vaf, gfp_mask, &gfp_mask,
 			nodemask_pr_args(nodemask));
 	va_end(args);
 
@@ -4286,7 +4286,7 @@ __alloc_pages_may_oom(gfp_t gfp_mask, unsigned int order,
 		goto out;
 
 	/* Coredumps can quickly deplete all memory reserves */
-	if (current->flags & PF_DUMPCORE)
+	if (sysiso_current->flags & PF_DUMPCORE)
 		goto out;
 	/* The OOM killer will not help higher order allocs */
 	if (order > PAGE_ALLOC_COSTLY_ORDER)
@@ -4413,7 +4413,7 @@ should_compact_retry(struct alloc_context *ac, int order, int alloc_flags,
 	if (!order)
 		return false;
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return false;
 
 	if (compaction_made_progress(compact_result))
@@ -4527,7 +4527,7 @@ static bool __need_reclaim(gfp_t gfp_mask)
 		return false;
 
 	/* this guy won't enter reclaim */
-	if (current->flags & PF_MEMALLOC)
+	if (sysiso_current->flags & PF_MEMALLOC)
 		return false;
 
 	if (gfp_mask & __GFP_NOLOCKDEP)
@@ -4717,10 +4717,10 @@ static inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)
 		return 0;
 	if (gfp_mask & __GFP_MEMALLOC)
 		return ALLOC_NO_WATERMARKS;
-	if (in_serving_softirq() && (current->flags & PF_MEMALLOC))
+	if (in_serving_softirq() && (sysiso_current->flags & PF_MEMALLOC))
 		return ALLOC_NO_WATERMARKS;
 	if (!in_interrupt()) {
-		if (current->flags & PF_MEMALLOC)
+		if (sysiso_current->flags & PF_MEMALLOC)
 			return ALLOC_NO_WATERMARKS;
 		else if (oom_reserves_allowed(current))
 			return ALLOC_OOM;
@@ -4828,7 +4828,7 @@ should_reclaim_retry(gfp_t gfp_mask, unsigned order,
 	 * looping without ever sleeping. Therefore we have to do a short sleep
 	 * here rather than calling cond_resched().
 	 */
-	if (current->flags & PF_WQ_WORKER)
+	if (sysiso_current->flags & PF_WQ_WORKER)
 		schedule_timeout_uninterruptible(1);
 	else
 		cond_resched();
@@ -5012,7 +5012,7 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
 		goto nopage;
 
 	/* Avoid recursion of direct reclaim */
-	if (current->flags & PF_MEMALLOC)
+	if (sysiso_current->flags & PF_MEMALLOC)
 		goto nopage;
 
 	/* Try direct reclaim and then allocating */
@@ -5098,7 +5098,7 @@ __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
 		 * because we cannot reclaim anything and only can loop waiting
 		 * for somebody to do a work for us
 		 */
-		WARN_ON_ONCE(current->flags & PF_MEMALLOC);
+		WARN_ON_ONCE(sysiso_current->flags & PF_MEMALLOC);
 
 		/*
 		 * non failing costly orders are a hard requirement which we
@@ -8959,7 +8959,7 @@ static int __alloc_contig_migrate_range(struct compact_control *cc,
 	lru_cache_disable();
 
 	while (pfn < end || !list_empty(&cc->migratepages)) {
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			ret = -EINTR;
 			break;
 		}
diff --git a/mm/page_owner.c b/mm/page_owner.c
index 62402d225..37a84b2ba 100644
--- a/mm/page_owner.c
+++ b/mm/page_owner.c
@@ -160,7 +160,7 @@ static inline void __set_page_owner_handle(struct page_ext *page_ext,
 		page_owner->order = order;
 		page_owner->gfp_mask = gfp_mask;
 		page_owner->last_migrate_reason = -1;
-		page_owner->pid = current->pid;
+		page_owner->pid = sysiso_current->pid;
 		page_owner->ts_nsec = local_clock();
 		__set_bit(PAGE_EXT_OWNER, &page_ext->flags);
 		__set_bit(PAGE_EXT_OWNER_ALLOCATED, &page_ext->flags);
diff --git a/mm/shmem.c b/mm/shmem.c
index b5860f4a2..542bbcc41 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -2727,7 +2727,7 @@ static long shmem_fallocate(struct file *file, int mode, loff_t offset,
 		 * Good, the fallocate(2) manpage permits EINTR: we may have
 		 * been interrupted because we are using up too much memory.
 		 */
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			error = -EINTR;
 		else if (shmem_falloc.nr_unswapped > shmem_falloc.nr_falloced)
 			error = -ENOMEM;
diff --git a/mm/slab.c b/mm/slab.c
index 874b3f8fe..cd7d52d8f 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -1403,8 +1403,8 @@ static void kmem_freepages(struct kmem_cache *cachep, struct page *page)
 	/* In union with page->mapping where page allocator expects NULL */
 	page->slab_cache = NULL;
 
-	if (current->reclaim_state)
-		current->reclaim_state->reclaimed_slab += 1 << order;
+	if (sysiso_current->reclaim_state)
+		sysiso_current->reclaim_state->reclaimed_slab += 1 << order;
 	unaccount_slab_page(page, order, cachep);
 	__free_pages(page, order);
 }
diff --git a/mm/slob.c b/mm/slob.c
index 74d3f6e60..922510c28 100644
--- a/mm/slob.c
+++ b/mm/slob.c
@@ -211,8 +211,8 @@ static void slob_free_pages(void *b, int order)
 {
 	struct page *sp = virt_to_page(b);
 
-	if (current->reclaim_state)
-		current->reclaim_state->reclaimed_slab += 1 << order;
+	if (sysiso_current->reclaim_state)
+		sysiso_current->reclaim_state->reclaimed_slab += 1 << order;
 
 	mod_node_page_state(page_pgdat(sp), NR_SLAB_UNRECLAIMABLE_B,
 			    -(PAGE_SIZE << order));
diff --git a/mm/slub.c b/mm/slub.c
index d8f773463..4b3bb3f83 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -716,7 +716,7 @@ static void set_track(struct kmem_cache *s, void *object,
 #endif
 		p->addr = addr;
 		p->cpu = smp_processor_id();
-		p->pid = current->pid;
+		p->pid = sysiso_current->pid;
 		p->when = jiffies;
 	} else {
 		memset(p, 0, sizeof(struct track));
@@ -1989,8 +1989,8 @@ static void __free_slab(struct kmem_cache *s, struct page *page)
 	__ClearPageSlab(page);
 	/* In union with page->mapping where page allocator expects NULL */
 	page->slab_cache = NULL;
-	if (current->reclaim_state)
-		current->reclaim_state->reclaimed_slab += pages;
+	if (sysiso_current->reclaim_state)
+		sysiso_current->reclaim_state->reclaimed_slab += pages;
 	unaccount_slab_page(page, order, s);
 	__free_pages(page, order);
 }
diff --git a/mm/swapfile.c b/mm/swapfile.c
index 22d10f713..906a18bbf 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -2183,7 +2183,7 @@ int try_to_unuse(unsigned int type, bool frontswap,
 	spin_lock(&mmlist_lock);
 	p = &init_mm.mmlist;
 	while (READ_ONCE(si->inuse_pages) &&
-	       !signal_pending(current) &&
+	       !signal_pending(sysiso_current) &&
 	       (p = p->next) != &init_mm.mmlist) {
 
 		mm = list_entry(p, struct mm_struct, mmlist);
@@ -2212,7 +2212,7 @@ int try_to_unuse(unsigned int type, bool frontswap,
 
 	i = 0;
 	while (READ_ONCE(si->inuse_pages) &&
-	       !signal_pending(current) &&
+	       !signal_pending(sysiso_current) &&
 	       (i = find_next_to_unuse(si, i, frontswap)) != 0) {
 
 		entry = swp_entry(type, i);
@@ -2254,7 +2254,7 @@ int try_to_unuse(unsigned int type, bool frontswap,
 	 * It's easy and robust (though cpu-intensive) just to keep retrying.
 	 */
 	if (READ_ONCE(si->inuse_pages)) {
-		if (!signal_pending(current))
+		if (!signal_pending(sysiso_current))
 			goto retry;
 		retval = -EINTR;
 	}
diff --git a/mm/userfaultfd.c b/mm/userfaultfd.c
index 7a9008415..4ba65f15d 100644
--- a/mm/userfaultfd.c
+++ b/mm/userfaultfd.c
@@ -406,7 +406,7 @@ static __always_inline ssize_t __mcopy_atomic_hugetlb(struct mm_struct *dst_mm,
 			src_addr += vma_hpagesize;
 			copied += vma_hpagesize;
 
-			if (fatal_signal_pending(current))
+			if (fatal_signal_pending(sysiso_current))
 				err = -EINTR;
 		}
 		if (err)
@@ -630,7 +630,7 @@ static __always_inline ssize_t __mcopy_atomic(struct mm_struct *dst_mm,
 			src_addr += PAGE_SIZE;
 			copied += PAGE_SIZE;
 
-			if (fatal_signal_pending(current))
+			if (fatal_signal_pending(sysiso_current))
 				err = -EINTR;
 		}
 		if (err)
diff --git a/mm/util.c b/mm/util.c
index bacabe446..570e2215d 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -331,7 +331,7 @@ unsigned long randomize_stack_top(unsigned long stack_top)
 {
 	unsigned long random_variable = 0;
 
-	if (current->flags & PF_RANDOMIZE) {
+	if (sysiso_current->flags & PF_RANDOMIZE) {
 		random_variable = get_random_long();
 		random_variable &= STACK_RND_MASK;
 		random_variable <<= PAGE_SHIFT;
@@ -369,7 +369,7 @@ unsigned long arch_mmap_rnd(void)
 
 static int mmap_is_legacy(struct rlimit *rlim_stack)
 {
-	if (current->personality & ADDR_COMPAT_LAYOUT)
+	if (sysiso_current->personality & ADDR_COMPAT_LAYOUT)
 		return 1;
 
 	if (rlim_stack->rlim_cur == RLIM_INFINITY)
@@ -391,7 +391,7 @@ static unsigned long mmap_base(unsigned long rnd, struct rlimit *rlim_stack)
 	unsigned long pad = stack_guard_gap;
 
 	/* Account for stack randomization if necessary */
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		pad += (STACK_RND_MASK << PAGE_SHIFT);
 
 	/* Values close to RLIM_INFINITY can overflow. */
@@ -410,7 +410,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack)
 {
 	unsigned long random_factor = 0UL;
 
-	if (current->flags & PF_RANDOMIZE)
+	if (sysiso_current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
 	if (mmap_is_legacy(rlim_stack)) {
diff --git a/mm/vmacache.c b/mm/vmacache.c
index 01a6e6688..252f1eada 100644
--- a/mm/vmacache.c
+++ b/mm/vmacache.c
@@ -29,7 +29,7 @@
  */
 static inline bool vmacache_valid_mm(struct mm_struct *mm)
 {
-	return current->mm == mm && !(current->flags & PF_KTHREAD);
+	return current->mm == mm && !(sysiso_current->flags & PF_KTHREAD);
 }
 
 void vmacache_update(unsigned long addr, struct vm_area_struct *newvma)
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 74296c2d1..df829fe7d 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -944,7 +944,7 @@ void drop_slab_node(int nid)
 	do {
 		struct mem_cgroup *memcg = NULL;
 
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return;
 
 		freed = 0;
@@ -976,7 +976,7 @@ static inline int is_page_cache_freeable(struct page *page)
 
 static int may_write_to_inode(struct inode *inode)
 {
-	if (current->flags & PF_SWAPWRITE)
+	if (sysiso_current->flags & PF_SWAPWRITE)
 		return 1;
 	if (!inode_write_congested(inode))
 		return 1;
@@ -2223,7 +2223,7 @@ static unsigned int move_pages_to_lru(struct lruvec *lruvec,
  */
 static int current_may_throttle(void)
 {
-	return !(current->flags & PF_LOCAL_THROTTLE) ||
+	return !(sysiso_current->flags & PF_LOCAL_THROTTLE) ||
 		current->backing_dev_info == NULL ||
 		bdi_write_congested(current->backing_dev_info);
 }
@@ -2255,7 +2255,7 @@ shrink_inactive_list(unsigned long nr_to_scan, struct lruvec *lruvec,
 		stalled = true;
 
 		/* We are about to die and free our memory. Return now. */
-		if (fatal_signal_pending(current))
+		if (fatal_signal_pending(sysiso_current))
 			return SWAP_CLUSTER_MAX;
 	}
 
@@ -3028,7 +3028,7 @@ static void shrink_node_memcgs(pg_data_t *pgdat, struct scan_control *sc)
 
 static void shrink_node(pg_data_t *pgdat, struct scan_control *sc)
 {
-	struct reclaim_state *reclaim_state = current->reclaim_state;
+	struct reclaim_state *reclaim_state = sysiso_current->reclaim_state;
 	unsigned long nr_reclaimed, nr_scanned;
 	struct lruvec *target_lruvec;
 	bool reclaimable = false;
@@ -3528,14 +3528,14 @@ static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,
 	 * committing a transaction where throttling it could forcing other
 	 * processes to block on log_wait_commit().
 	 */
-	if (current->flags & PF_KTHREAD)
+	if (sysiso_current->flags & PF_KTHREAD)
 		goto out;
 
 	/*
 	 * If a fatal signal is pending, this process should not throttle.
 	 * It should return quickly so it can exit and free its memory
 	 */
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		goto out;
 
 	/*
@@ -3587,7 +3587,7 @@ static bool throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,
 		wait_event_killable(zone->zone_pgdat->pfmemalloc_wait,
 			allow_direct_reclaim(pgdat));
 
-	if (fatal_signal_pending(current))
+	if (fatal_signal_pending(sysiso_current))
 		return true;
 
 out:
@@ -3655,7 +3655,7 @@ unsigned long mem_cgroup_shrink_node(struct mem_cgroup *memcg,
 		.may_swap = !noswap,
 	};
 
-	WARN_ON_ONCE(!current->reclaim_state);
+	WARN_ON_ONCE(!sysiso_current->reclaim_state);
 
 	sc.gfp_mask = (gfp_mask & GFP_RECLAIM_MASK) |
 			(GFP_HIGHUSER_MOVABLE & ~GFP_RECLAIM_MASK);
@@ -4167,7 +4167,7 @@ static void kswapd_try_to_sleep(pg_data_t *pgdat, int alloc_order, int reclaim_o
 	long remaining = 0;
 	DEFINE_WAIT(wait);
 
-	if (freezing(current) || kthread_should_stop())
+	if (freezing(sysiso_current) || kthread_should_stop())
 		return;
 
 	prepare_to_wait(&pgdat->kswapd_wait, &wait, TASK_INTERRUPTIBLE);
@@ -4590,7 +4590,7 @@ static int __node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned in
 	}
 
 	set_task_reclaim_state(p, NULL);
-	current->flags &= ~PF_SWAPWRITE;
+	sysiso_current->flags &= ~PF_SWAPWRITE;
 	memalloc_noreclaim_restore(noreclaim_flag);
 	fs_reclaim_release(sc.gfp_mask);
 	psi_memstall_leave(&pflags);
@@ -4622,7 +4622,7 @@ int node_reclaim(struct pglist_data *pgdat, gfp_t gfp_mask, unsigned int order)
 	/*
 	 * Do not scan if the allocation should not be delayed.
 	 */
-	if (!gfpflags_allow_blocking(gfp_mask) || (current->flags & PF_MEMALLOC))
+	if (!gfpflags_allow_blocking(gfp_mask) || (sysiso_current->flags & PF_MEMALLOC))
 		return NODE_RECLAIM_NOSCAN;
 
 	/*
diff --git a/net/9p/client.c b/net/9p/client.c
index 213f12ed7..b29cef6bc 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -742,7 +742,7 @@ p9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...)
 	if (IS_ERR(req))
 		return req;
 
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		sigpending = 1;
 		clear_thread_flag(TIF_SIGPENDING);
 	} else
@@ -791,9 +791,9 @@ p9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...)
 	}
 recalc_sigpending:
 	if (sigpending) {
-		spin_lock_irqsave(&current->sighand->siglock, flags);
+		spin_lock_irqsave(&sysiso_current->sighand->siglock, flags);
 		recalc_sigpending();
-		spin_unlock_irqrestore(&current->sighand->siglock, flags);
+		spin_unlock_irqrestore(&sysiso_current->sighand->siglock, flags);
 	}
 	if (err < 0)
 		goto reterr;
@@ -841,7 +841,7 @@ static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,
 	if (IS_ERR(req))
 		return req;
 
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		sigpending = 1;
 		clear_thread_flag(TIF_SIGPENDING);
 	} else
@@ -873,9 +873,9 @@ static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,
 	}
 recalc_sigpending:
 	if (sigpending) {
-		spin_lock_irqsave(&current->sighand->siglock, flags);
+		spin_lock_irqsave(&sysiso_current->sighand->siglock, flags);
 		recalc_sigpending();
-		spin_unlock_irqrestore(&current->sighand->siglock, flags);
+		spin_unlock_irqrestore(&sysiso_current->sighand->siglock, flags);
 	}
 	if (err < 0)
 		goto reterr;
@@ -1466,7 +1466,7 @@ int p9_client_clunk(struct p9_fid *fid)
 
 	if (!fid || IS_ERR(fid)) {
 		pr_warn("%s (%d): Trying to clunk with invalid fid\n",
-			__func__, task_pid_nr(current));
+			__func__, task_pid_nr(sysiso_current));
 		dump_stack();
 		return 0;
 	}
diff --git a/net/9p/mod.c b/net/9p/mod.c
index 512656685..31cee8100 100644
--- a/net/9p/mod.c
+++ b/net/9p/mod.c
@@ -44,9 +44,10 @@ void _p9_debug(enum p9_debug_flags level, const char *func,
 	vaf.va = &args;
 
 	if (level == P9_DEBUG_9P)
-		pr_notice("(%8.8d) %pV", task_pid_nr(current), &vaf);
+		pr_notice("(%8.8d) %pV", task_pid_nr(sysiso_current), &vaf);
 	else
-		pr_notice("-- %s (%d): %pV", func, task_pid_nr(current), &vaf);
+		pr_notice("-- %s (%d): %pV", func,
+			  task_pid_nr(sysiso_current), &vaf);
 
 	va_end(args);
 }
diff --git a/net/9p/trans_fd.c b/net/9p/trans_fd.c
index 007bbcc68..19eb97422 100644
--- a/net/9p/trans_fd.c
+++ b/net/9p/trans_fd.c
@@ -855,7 +855,7 @@ static int p9_socket_open(struct p9_client *client, struct socket *csocket)
 	file = sock_alloc_file(csocket, 0, NULL);
 	if (IS_ERR(file)) {
 		pr_err("%s (%d): failed to map fd\n",
-		       __func__, task_pid_nr(current));
+		       __func__, task_pid_nr(sysiso_current));
 		kfree(p);
 		return PTR_ERR(file);
 	}
@@ -985,11 +985,11 @@ p9_fd_create_tcp(struct p9_client *client, const char *addr, char *args)
 	sin_server.sin_family = AF_INET;
 	sin_server.sin_addr.s_addr = in_aton(addr);
 	sin_server.sin_port = htons(opts.port);
-	err = __sock_create(current->nsproxy->net_ns, PF_INET,
+	err = __sock_create(sysiso_current->nsproxy->net_ns, PF_INET,
 			    SOCK_STREAM, IPPROTO_TCP, &csocket, 1);
 	if (err) {
 		pr_err("%s (%d): problem creating socket\n",
-		       __func__, task_pid_nr(current));
+		       __func__, task_pid_nr(sysiso_current));
 		return err;
 	}
 
@@ -997,7 +997,7 @@ p9_fd_create_tcp(struct p9_client *client, const char *addr, char *args)
 		err = p9_bind_privport(csocket);
 		if (err < 0) {
 			pr_err("%s (%d): problem binding to privport\n",
-			       __func__, task_pid_nr(current));
+			       __func__, task_pid_nr(sysiso_current));
 			sock_release(csocket);
 			return err;
 		}
@@ -1008,7 +1008,7 @@ p9_fd_create_tcp(struct p9_client *client, const char *addr, char *args)
 				    sizeof(struct sockaddr_in), 0);
 	if (err < 0) {
 		pr_err("%s (%d): problem connecting socket to %s\n",
-		       __func__, task_pid_nr(current), addr);
+		       __func__, task_pid_nr(sysiso_current), addr);
 		sock_release(csocket);
 		return err;
 	}
@@ -1030,17 +1030,17 @@ p9_fd_create_unix(struct p9_client *client, const char *addr, char *args)
 
 	if (strlen(addr) >= UNIX_PATH_MAX) {
 		pr_err("%s (%d): address too long: %s\n",
-		       __func__, task_pid_nr(current), addr);
+		       __func__, task_pid_nr(sysiso_current), addr);
 		return -ENAMETOOLONG;
 	}
 
 	sun_server.sun_family = PF_UNIX;
 	strcpy(sun_server.sun_path, addr);
-	err = __sock_create(current->nsproxy->net_ns, PF_UNIX,
+	err = __sock_create(sysiso_current->nsproxy->net_ns, PF_UNIX,
 			    SOCK_STREAM, 0, &csocket, 1);
 	if (err < 0) {
 		pr_err("%s (%d): problem creating socket\n",
-		       __func__, task_pid_nr(current));
+		       __func__, task_pid_nr(sysiso_current));
 
 		return err;
 	}
@@ -1048,7 +1048,7 @@ p9_fd_create_unix(struct p9_client *client, const char *addr, char *args)
 			sizeof(struct sockaddr_un) - 1, 0);
 	if (err < 0) {
 		pr_err("%s (%d): problem connecting socket: %s: %d\n",
-		       __func__, task_pid_nr(current), addr, err);
+		       __func__, task_pid_nr(sysiso_current), addr, err);
 		sock_release(csocket);
 		return err;
 	}
diff --git a/net/9p/trans_rdma.c b/net/9p/trans_rdma.c
index af0a8a6cd..6d538ed51 100644
--- a/net/9p/trans_rdma.c
+++ b/net/9p/trans_rdma.c
@@ -661,7 +661,7 @@ rdma_create_trans(struct p9_client *client, const char *addr, char *args)
 		err = p9_rdma_bind_privport(rdma);
 		if (err < 0) {
 			pr_err("%s (%d): problem binding to privport: %d\n",
-			       __func__, task_pid_nr(current), -err);
+			       __func__, task_pid_nr(sysiso_current), -err);
 			goto error;
 		}
 	}
diff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c
index bf5736c1d..b7799a183 100644
--- a/net/appletalk/ddp.c
+++ b/net/appletalk/ddp.c
@@ -1213,7 +1213,7 @@ static int atalk_connect(struct socket *sock, struct sockaddr *uaddr,
 	    !sock_flag(sk, SOCK_BROADCAST)) {
 #if 1
 		pr_warn("atalk_connect: %s is broken and did not set SO_BROADCAST.\n",
-			current->comm);
+			sysiso_current->comm);
 #else
 		return -EACCES;
 #endif
diff --git a/net/atm/common.c b/net/atm/common.c
index 1cfa9bf1d..9cf2a1024 100644
--- a/net/atm/common.c
+++ b/net/atm/common.c
@@ -608,7 +608,7 @@ int vcc_sendmsg(struct socket *sock, struct msghdr *m, size_t size)
 			break;
 		}
 		schedule();
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			error = -ERESTARTSYS;
 			break;
 		}
diff --git a/net/atm/ioctl.c b/net/atm/ioctl.c
index 838ebf0ca..3f69a4221 100644
--- a/net/atm/ioctl.c
+++ b/net/atm/ioctl.c
@@ -85,7 +85,7 @@ static int do_vcc_ioctl(struct socket *sock, unsigned int cmd,
 	}
 	case ATM_SETSC:
 		net_warn_ratelimited("ATM_SETSC is obsolete; used by %s:%d\n",
-				     current->comm, task_pid_nr(current));
+				     sysiso_current->comm, task_pid_nr(current));
 		error = 0;
 		goto done;
 	case ATMSIGD_CTRL:
diff --git a/net/atm/svc.c b/net/atm/svc.c
index 4a02bcaad..d65bac8f5 100644
--- a/net/atm/svc.c
+++ b/net/atm/svc.c
@@ -214,7 +214,7 @@ static int svc_connect(struct socket *sock, struct sockaddr *sockaddr,
 		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 		while (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {
 			schedule();
-			if (!signal_pending(current)) {
+			if (!signal_pending(sysiso_current)) {
 				prepare_to_wait(sk_sleep(sk), &wait,
 						TASK_INTERRUPTIBLE);
 				continue;
@@ -357,7 +357,7 @@ static int svc_accept(struct socket *sock, struct socket *newsock, int flags,
 			release_sock(sk);
 			schedule();
 			lock_sock(sk);
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				error = -ERESTARTSYS;
 				break;
 			}
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 2631efc6e..169d83fbf 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -1225,7 +1225,7 @@ static int __must_check ax25_connect(struct socket *sock,
 	if (sock_flag(sk, SOCK_ZAPPED)) {
 		/* check if we can remove this feature. It is broken. */
 		printk(KERN_WARNING "ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\n",
-			current->comm);
+			sysiso_current->comm);
 		if ((err = ax25_rt_autobind(ax25, &fsa->fsa_ax25.sax25_call)) < 0) {
 			kfree(digi);
 			goto out_release;
@@ -1300,7 +1300,7 @@ static int __must_check ax25_connect(struct socket *sock,
 					TASK_INTERRUPTIBLE);
 			if (sk->sk_state != TCP_SYN_SENT)
 				break;
-			if (!signal_pending(current)) {
+			if (!signal_pending(sysiso_current)) {
 				release_sock(sk);
 				schedule();
 				lock_sock(sk);
@@ -1371,7 +1371,7 @@ static int ax25_accept(struct socket *sock, struct socket *newsock, int flags,
 			err = -EWOULDBLOCK;
 			break;
 		}
-		if (!signal_pending(current)) {
+		if (!signal_pending(sysiso_current)) {
 			release_sock(sk);
 			schedule();
 			lock_sock(sk);
@@ -1801,7 +1801,7 @@ static int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
 			static int warned = 0;
 			if (!warned) {
 				printk(KERN_INFO "%s uses old SIOCAX25GETINFO\n",
-					current->comm);
+					sysiso_current->comm);
 				warned=1;
 			}
 
diff --git a/net/bluetooth/af_bluetooth.c b/net/bluetooth/af_bluetooth.c
index 1661979b6..3ea957441 100644
--- a/net/bluetooth/af_bluetooth.c
+++ b/net/bluetooth/af_bluetooth.c
@@ -314,7 +314,7 @@ static long bt_sock_data_wait(struct sock *sk, long timeo)
 		if (sk->sk_err || (sk->sk_shutdown & RCV_SHUTDOWN))
 			break;
 
-		if (signal_pending(current) || !timeo)
+		if (signal_pending(sysiso_current) || !timeo)
 			break;
 
 		sk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);
@@ -368,7 +368,7 @@ int bt_sock_stream_recvmsg(struct socket *sock, struct msghdr *msg,
 
 			timeo = bt_sock_data_wait(sk, timeo);
 
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				err = sock_intr_errno(timeo);
 				goto out;
 			}
@@ -547,7 +547,7 @@ int bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo)
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
@@ -586,7 +586,7 @@ int bt_sock_wait_ready(struct sock *sk, unsigned long flags)
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
diff --git a/net/bluetooth/cmtp/capi.c b/net/bluetooth/cmtp/capi.c
index f3bedc3b6..692506c43 100644
--- a/net/bluetooth/cmtp/capi.c
+++ b/net/bluetooth/cmtp/capi.c
@@ -429,7 +429,7 @@ static void cmtp_register_appl(struct capi_ctr *ctrl, __u16 appl, capi_register_
 		if (application->state == BT_CONNECTED)
 			break;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -EINTR;
 			break;
 		}
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index c99d65ef1..31f0b506f 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -346,7 +346,7 @@ static int l2cap_sock_accept(struct socket *sock, struct socket *newsock,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
@@ -1245,7 +1245,7 @@ static int __l2cap_wait_ack(struct sock *sk, struct l2cap_chan *chan)
 		if (!timeo)
 			timeo = L2CAP_WAIT_ACK_POLL_PERIOD;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
@@ -1355,7 +1355,7 @@ static int l2cap_sock_shutdown(struct socket *sock, int how)
 	lock_sock(sk);
 
 	if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&
-	    !(current->flags & PF_EXITING))
+	    !(sysiso_current->flags & PF_EXITING))
 		err = bt_sock_wait_state(sk, BT_CLOSED,
 					 sk->sk_lingertime);
 
diff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c
index 2c95bb58f..56fec825b 100644
--- a/net/bluetooth/rfcomm/sock.c
+++ b/net/bluetooth/rfcomm/sock.c
@@ -506,7 +506,7 @@ static int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int f
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
@@ -931,7 +931,7 @@ static int rfcomm_sock_shutdown(struct socket *sock, int how)
 		__rfcomm_sock_close(sk);
 
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&
-		    !(current->flags & PF_EXITING))
+		    !(sysiso_current->flags & PF_EXITING))
 			err = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);
 	}
 	release_sock(sk);
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 98a881586..3300eecca 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -679,7 +679,7 @@ static int sco_sock_accept(struct socket *sock, struct socket *newsock,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
@@ -1056,7 +1056,7 @@ static int sco_sock_shutdown(struct socket *sock, int how)
 		__sco_sock_close(sk);
 
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&
-		    !(current->flags & PF_EXITING))
+		    !(sysiso_current->flags & PF_EXITING))
 			err = bt_sock_wait_state(sk, BT_CLOSED,
 						 sk->sk_lingertime);
 	}
@@ -1080,7 +1080,7 @@ static int sco_sock_release(struct socket *sock)
 	sco_sock_close(sk);
 
 	if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&
-	    !(current->flags & PF_EXITING)) {
+	    !(sysiso_current->flags & PF_EXITING)) {
 		lock_sock(sk);
 		err = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);
 		release_sock(sk);
diff --git a/net/bpf/test_run.c b/net/bpf/test_run.c
index b5f4ef353..10f45e39b 100644
--- a/net/bpf/test_run.c
+++ b/net/bpf/test_run.c
@@ -64,7 +64,7 @@ static bool bpf_test_timer_continue(struct bpf_test_timer *t, u32 repeat, int *e
 		goto reset;
 	}
 
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		/* During iteration: we've been cancelled, abort. */
 		*err = -EINTR;
 		goto reset;
@@ -562,7 +562,7 @@ int bpf_prog_test_run_skb(struct bpf_prog *prog, const union bpf_attr *kattr,
 			  union bpf_attr __user *uattr)
 {
 	bool is_l2 = false, is_direct_pkt_access = false;
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct net_device *dev = net->loopback_dev;
 	u32 size = kattr->test.data_size_in;
 	u32 repeat = kattr->test.repeat;
@@ -711,7 +711,7 @@ static int xdp_convert_md_to_buff(struct xdp_md *xdp_md, struct xdp_buff *xdp)
 		return -EINVAL;
 
 	if (ingress_ifindex) {
-		device = dev_get_by_index(current->nsproxy->net_ns,
+		device = dev_get_by_index(sysiso_current->nsproxy->net_ns,
 					  ingress_ifindex);
 		if (!device)
 			return -ENODEV;
@@ -792,7 +792,8 @@ int bpf_prog_test_run_xdp(struct bpf_prog *prog, const union bpf_attr *kattr,
 		goto free_ctx;
 	}
 
-	rxqueue = __netif_get_rx_queue(current->nsproxy->net_ns->loopback_dev, 0);
+	rxqueue = __netif_get_rx_queue(sysiso_current->nsproxy->net_ns->loopback_dev,
+				       0);
 	xdp_init_buff(&xdp, headroom + max_data_sz + tailroom,
 		      &rxqueue->xdp_rxq);
 	xdp_prepare_buff(&xdp, data, headroom, size, true);
diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index 51a941b56..5bd274d0f 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -65,7 +65,7 @@ static int bpfilter_process_sockopt(struct sock *sk, int optname,
 {
 	struct mbox_request req = {
 		.is_set		= is_set,
-		.pid		= current->pid,
+		.pid		= sysiso_current->pid,
 		.cmd		= optname,
 		.addr		= (uintptr_t)optval.user,
 		.len		= optlen,
@@ -79,7 +79,7 @@ static int bpfilter_process_sockopt(struct sock *sk, int optname,
 
 static int start_umh(void)
 {
-	struct mbox_request req = { .pid = current->pid };
+	struct mbox_request req = { .pid = sysiso_current->pid };
 	int err;
 
 	/* fork usermode process */
diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c
index e12fd3cad..1f1f0d96b 100644
--- a/net/caif/caif_socket.c
+++ b/net/caif/caif_socket.c
@@ -319,7 +319,7 @@ static long caif_stream_data_wait(struct sock *sk, long timeo)
 			sk->sk_state != CAIF_CONNECTED ||
 			sock_flag(sk, SOCK_DEAD) ||
 			(sk->sk_shutdown & RCV_SHUTDOWN) ||
-			signal_pending(current) ||
+			signal_pending(sysiso_current) ||
 			!timeo)
 			break;
 
@@ -410,7 +410,7 @@ static int caif_stream_recvmsg(struct socket *sock, struct msghdr *msg,
 
 			timeo = caif_stream_data_wait(sk, timeo);
 
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				err = sock_intr_errno(timeo);
 				goto out;
 			}
@@ -475,7 +475,7 @@ static long caif_wait_for_flow_on(struct caifsock *cf_sk,
 		if (!timeo)
 			break;
 		*err = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 		*err = -ECONNRESET;
diff --git a/net/ceph/ceph_common.c b/net/ceph/ceph_common.c
index 97d6ea763..904b30c3c 100644
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@ -141,7 +141,7 @@ int ceph_compare_options(struct ceph_options *new_opt,
 	 * Don't bother comparing options if network namespaces don't
 	 * match.
 	 */
-	if (!net_eq(current->nsproxy->net_ns, read_pnet(&client->msgr.net)))
+	if (!net_eq(sysiso_current->nsproxy->net_ns, read_pnet(&client->msgr.net)))
 		return -1;
 
 	ret = memcmp(opt1, opt2, ofs);
diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c
index 57d043b38..015563a5e 100644
--- a/net/ceph/messenger.c
+++ b/net/ceph/messenger.c
@@ -1221,7 +1221,7 @@ static int ceph_dns_resolve_name(const char *name, size_t namelen,
 		return -EINVAL;
 
 	/* do dns_resolve upcall */
-	ip_len = dns_query(current->nsproxy->net_ns,
+	ip_len = dns_query(sysiso_current->nsproxy->net_ns,
 			   NULL, name, end - name, NULL, &ip_addr, NULL, false);
 	if (ip_len > 0)
 		ret = ceph_pton(ip_addr, ip_len, addr, -1, NULL);
@@ -1644,7 +1644,7 @@ void ceph_messenger_init(struct ceph_messenger *msgr,
 	ceph_encode_my_addr(msgr);
 
 	atomic_set(&msgr->stopping, 0);
-	write_pnet(&msgr->net, get_net(current->nsproxy->net_ns));
+	write_pnet(&msgr->net, get_net(sysiso_current->nsproxy->net_ns));
 
 	dout("%s %p\n", __func__, msgr);
 }
diff --git a/net/core/datagram.c b/net/core/datagram.c
index 15ab9ffb2..44734c455 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -115,7 +115,7 @@ int __skb_wait_for_more_packets(struct sock *sk, struct sk_buff_head *queue,
 		goto out_err;
 
 	/* handle signals */
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		goto interrupted;
 
 	error = 0;
diff --git a/net/core/dev.c b/net/core/dev.c
index eb3a366bf..6924a7d74 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -9663,7 +9663,7 @@ static const struct bpf_link_ops bpf_xdp_link_lops = {
 
 int bpf_xdp_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct bpf_link_primer link_primer;
 	struct bpf_xdp_link *link;
 	struct net_device *dev;
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index b2e49eb70..05c178a98 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -1772,14 +1772,14 @@ static void remove_queue_kobjects(struct net_device *dev)
 
 static bool net_current_may_mount(void)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 
 	return ns_capable(net->user_ns, CAP_SYS_ADMIN);
 }
 
 static void *net_grab_current_ns(void)
 {
-	struct net *ns = current->nsproxy->net_ns;
+	struct net *ns = sysiso_current->nsproxy->net_ns;
 #ifdef CONFIG_NET_NS
 	if (ns)
 		refcount_inc(&ns->passive);
diff --git a/net/core/netpoll.c b/net/core/netpoll.c
index edfc0f801..97b28de93 100644
--- a/net/core/netpoll.c
+++ b/net/core/netpoll.c
@@ -665,7 +665,7 @@ int netpoll_setup(struct netpoll *np)
 
 	rtnl_lock();
 	if (np->dev_name[0]) {
-		struct net *net = current->nsproxy->net_ns;
+		struct net *net = sysiso_current->nsproxy->net_ns;
 		ndev = __dev_get_by_name(net, np->dev_name);
 	}
 	if (!ndev) {
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index a3d74e270..a7256ffe7 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -515,7 +515,8 @@ static ssize_t pgctrl_write(struct file *file, const char __user *buf,
 			    size_t count, loff_t *ppos)
 {
 	char data[128];
-	struct pktgen_net *pn = net_generic(current->nsproxy->net_ns, pg_net_id);
+	struct pktgen_net *pn = net_generic(sysiso_current->nsproxy->net_ns,
+					    pg_net_id);
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
@@ -2284,7 +2285,7 @@ static void spin(struct pktgen_dev *pkt_dev, ktime_t spin_until)
 				schedule();
 
 			hrtimer_cancel(&t.timer);
-		} while (t.task && pkt_dev->running && !signal_pending(current));
+		} while (t.task && pkt_dev->running && !signal_pending(sysiso_current));
 		__set_current_state(TASK_RUNNING);
 		end_time = ktime_get();
 	}
@@ -3212,7 +3213,7 @@ static int pktgen_wait_thread_run(struct pktgen_thread *t)
 		msleep_interruptible(100);
 		mutex_lock(&pktgen_thread_lock);
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto signal;
 	}
 	return 1;
@@ -3428,7 +3429,7 @@ static void pktgen_wait_for_skb(struct pktgen_dev *pkt_dev)
 	ktime_t idle_start = ktime_get();
 
 	while (refcount_read(&(pkt_dev->skb->users)) != 1) {
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		if (need_resched())
@@ -3611,7 +3612,8 @@ static int pktgen_thread_worker(void *arg)
 	init_waitqueue_head(&t->queue);
 	complete(&t->start_done);
 
-	pr_debug("starting pktgen/%d:  pid=%d\n", cpu, task_pid_nr(current));
+	pr_debug("starting pktgen/%d:  pid=%d\n", cpu,
+		 task_pid_nr(sysiso_current));
 
 	set_freezable();
 
diff --git a/net/core/scm.c b/net/core/scm.c
index 5c356f0de..a45874e5f 100644
--- a/net/core/scm.c
+++ b/net/core/scm.c
@@ -51,8 +51,8 @@ static __inline__ int scm_check_creds(struct ucred *creds)
 	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
-	if ((creds->pid == task_tgid_vnr(current) ||
-	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
+	if ((creds->pid == task_tgid_vnr(sysiso_current) ||
+	     ns_capable(task_active_pid_ns(sysiso_current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || ns_capable(cred->user_ns, CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
diff --git a/net/core/sock.c b/net/core/sock.c
index c1601f75e..e9cb0f322 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -420,7 +420,8 @@ static int sock_set_timeout(long *timeo_p, sockptr_t optval, int optlen,
 		if (warned < 10 && net_ratelimit()) {
 			warned++;
 			pr_info("%s: `%s' (pid %d) tries to set negative timeout\n",
-				__func__, current->comm, task_pid_nr(current));
+				__func__, sysiso_current->comm,
+				task_pid_nr(sysiso_current));
 		}
 		return 0;
 	}
@@ -2439,7 +2440,7 @@ static long sock_wait_for_wmem(struct sock *sk, long timeo)
 	for (;;) {
 		if (!timeo)
 			break;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
@@ -2486,7 +2487,7 @@ struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
 		err = -EAGAIN;
 		if (!timeo)
 			goto failure;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto interrupted;
 		timeo = sock_wait_for_wmem(sk, timeo);
 	}
diff --git a/net/core/stream.c b/net/core/stream.c
index 4f1d4aa5f..7339b146a 100644
--- a/net/core/stream.c
+++ b/net/core/stream.c
@@ -103,7 +103,7 @@ void sk_stream_wait_close(struct sock *sk, long timeout)
 		do {
 			if (sk_wait_event(sk, &timeout, !sk_stream_closing(sk), &wait))
 				break;
-		} while (!signal_pending(current) && timeout);
+		} while (!signal_pending(sysiso_current) && timeout);
 
 		remove_wait_queue(sk_sleep(sk), &wait);
 	}
@@ -134,7 +134,7 @@ int sk_stream_wait_memory(struct sock *sk, long *timeo_p)
 			goto do_error;
 		if (!*timeo_p)
 			goto do_eagain;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto do_interrupted;
 		sk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);
 		if (sk_stream_memory_free(sk) && !vm_wait)
diff --git a/net/dccp/output.c b/net/dccp/output.c
index b8a247343..8df6427ed 100644
--- a/net/dccp/output.c
+++ b/net/dccp/output.c
@@ -231,7 +231,7 @@ static int dccp_wait_for_ccid(struct sock *sk, unsigned long delay)
 	sk->sk_write_pending--;
 	finish_wait(sk_sleep(sk), &wait);
 
-	if (signal_pending(current) || sk->sk_err)
+	if (signal_pending(sysiso_current) || sk->sk_err)
 		return -1;
 	return remaining;
 }
diff --git a/net/dccp/proto.c b/net/dccp/proto.c
index abb5c596a..4ed503b59 100644
--- a/net/dccp/proto.c
+++ b/net/dccp/proto.c
@@ -878,7 +878,7 @@ int dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			len = sock_intr_errno(timeo);
 			break;
 		}
diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c
index dc92a67ba..a669fb6b6 100644
--- a/net/decnet/af_decnet.c
+++ b/net/decnet/af_decnet.c
@@ -839,7 +839,7 @@ static int dn_confirm_accept(struct sock *sk, long *timeo, gfp_t allocation)
 		if (err)
 			break;
 		err = sock_intr_errno(*timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		err = -EAGAIN;
 		if (!*timeo)
@@ -879,7 +879,7 @@ static int dn_wait_run(struct sock *sk, long *timeo)
 		if (err)
 			break;
 		err = sock_intr_errno(*timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		err = -ETIMEDOUT;
 		if (!*timeo)
@@ -1049,7 +1049,7 @@ static struct sk_buff *dn_wait_for_connect(struct sock *sk, long *timeo)
 		if (sk->sk_state != TCP_LISTEN)
 			break;
 		err = sock_intr_errno(*timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		err = -EAGAIN;
 		if (!*timeo)
@@ -1731,7 +1731,7 @@ static int dn_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
 		if (scp->state != DN_RUN)
 			goto out;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rv = sock_intr_errno(timeo);
 			goto out;
 		}
@@ -1976,7 +1976,7 @@ static int dn_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		if (err)
 			goto out;
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			goto out;
 		}
diff --git a/net/dns_resolver/internal.h b/net/dns_resolver/internal.h
index 0c570d40e..07c9ef963 100644
--- a/net/dns_resolver/internal.h
+++ b/net/dns_resolver/internal.h
@@ -44,7 +44,7 @@ extern unsigned int dns_resolver_debug;
 do {							\
 	if (unlikely(dns_resolver_debug))		\
 		printk(KERN_DEBUG "[%-6.6s] "FMT"\n",	\
-		       current->comm, ##__VA_ARGS__);	\
+		       sysiso_current->comm, ##__VA_ARGS__);	\
 } while (0)
 
 #define kenter(FMT, ...) kdebug("==> %s("FMT")", __func__, ##__VA_ARGS__)
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index f2abc3152..6d5ba7e65 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1998,7 +1998,7 @@ static int ethtool_phys_id(struct net_device *dev, void __user *useraddr)
 			if (rc)
 				break;
 			schedule_timeout_interruptible(interval);
-		} while (!signal_pending(current) && (!id.data || i < count));
+		} while (!signal_pending(sysiso_current) && (!id.data || i < count));
 	}
 
 	rtnl_lock();
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 1d816a5fd..9b74ffd6a 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -426,7 +426,7 @@ int inet_release(struct socket *sock)
 		 */
 		timeout = 0;
 		if (sock_flag(sk, SOCK_LINGER) &&
-		    !(current->flags & PF_EXITING))
+		    !(sysiso_current->flags & PF_EXITING))
 			timeout = sk->sk_lingertime;
 		sk->sk_prot->close(sk, timeout);
 		sock->sk = NULL;
@@ -597,7 +597,7 @@ static long inet_wait_for_connect(struct sock *sk, long timeo, int writebias)
 		release_sock(sk);
 		timeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);
 		lock_sock(sk);
-		if (signal_pending(current) || !timeo)
+		if (signal_pending(sysiso_current) || !timeo)
 			break;
 	}
 	remove_wait_queue(sk_sleep(sk), &wait);
@@ -690,7 +690,7 @@ int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
 			goto out;
 
 		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out;
 	}
 
diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index f4468980b..e8bb9cafa 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -2676,10 +2676,11 @@ static __net_init int devinet_init_net(struct net *net)
 		if (IS_ENABLED(CONFIG_SYSCTL) &&
 		    sysctl_devconf_inherit_init_net == 3) {
 			/* copy from the current netns */
-			memcpy(all, current->nsproxy->net_ns->ipv4.devconf_all,
+			memcpy(all,
+			       sysiso_current->nsproxy->net_ns->ipv4.devconf_all,
 			       sizeof(ipv4_devconf));
 			memcpy(dflt,
-			       current->nsproxy->net_ns->ipv4.devconf_dflt,
+			       sysiso_current->nsproxy->net_ns->ipv4.devconf_dflt,
 			       sizeof(ipv4_devconf_dflt));
 		} else if (!IS_ENABLED(CONFIG_SYSCTL) ||
 			   sysctl_devconf_inherit_init_net != 2) {
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index f25d02ad4..a13ad7ca5 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -455,7 +455,7 @@ static int inet_csk_wait_for_connect(struct sock *sk, long timeo)
 		if (sk->sk_state != TCP_LISTEN)
 			break;
 		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		err = -EAGAIN;
 		if (!timeo)
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index bb446e60c..f0f205c87 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -541,7 +541,7 @@ static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 			goto out;
 		if (usin->sin_family != AF_INET) {
 			pr_info_once("%s: %s forgot to set AF_INET. Fix it!\n",
-				     __func__, current->comm);
+				     __func__, sysiso_current->comm);
 			err = -EAFNOSUPPORT;
 			if (usin->sin_family)
 				goto out;
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index f5c336f8b..e0fe4f337 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -829,7 +829,7 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 			if (!skb_queue_empty(&sk->sk_receive_queue))
 				break;
 			sk_wait_data(sk, &timeo, NULL);
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				ret = sock_intr_errno(timeo);
 				break;
 			}
@@ -845,7 +845,7 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 
 		if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
 		    (sk->sk_shutdown & RCV_SHUTDOWN) ||
-		    signal_pending(current))
+		    signal_pending(sysiso_current))
 			break;
 	}
 
@@ -2347,7 +2347,7 @@ static int tcp_recvmsg_locked(struct sock *sk, struct msghdr *msg, size_t len,
 		if (tp->urg_data && tp->urg_seq == *seq) {
 			if (copied)
 				break;
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
 				break;
 			}
@@ -2391,7 +2391,7 @@ static int tcp_recvmsg_locked(struct sock *sk, struct msghdr *msg, size_t len,
 			    sk->sk_state == TCP_CLOSE ||
 			    (sk->sk_shutdown & RCV_SHUTDOWN) ||
 			    !timeo ||
-			    signal_pending(current))
+			    signal_pending(sysiso_current))
 				break;
 		} else {
 			if (sock_flag(sk, SOCK_DONE))
@@ -2418,7 +2418,7 @@ static int tcp_recvmsg_locked(struct sock *sk, struct msghdr *msg, size_t len,
 				break;
 			}
 
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = sock_intr_errno(timeo);
 				break;
 			}
@@ -2437,8 +2437,8 @@ static int tcp_recvmsg_locked(struct sock *sk, struct msghdr *msg, size_t len,
 		if ((flags & MSG_PEEK) &&
 		    (peek_seq - copied - urg_hole != tp->copied_seq)) {
 			net_dbg_ratelimited("TCP(%s:%d): Application bug, race in MSG_PEEK\n",
-					    current->comm,
-					    task_pid_nr(current));
+					    sysiso_current->comm,
+					    task_pid_nr(sysiso_current));
 			peek_seq = tp->copied_seq;
 		}
 		continue;
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index c6a90b7bb..1c77b982a 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -7101,10 +7101,11 @@ static int __net_init addrconf_init_net(struct net *net)
 			       sizeof(ipv6_devconf_dflt));
 			break;
 		case 3: /* copy from the current netns */
-			memcpy(all, current->nsproxy->net_ns->ipv6.devconf_all,
+			memcpy(all,
+			       sysiso_current->nsproxy->net_ns->ipv6.devconf_all,
 			       sizeof(ipv6_devconf));
 			memcpy(dflt,
-			       current->nsproxy->net_ns->ipv6.devconf_dflt,
+			       sysiso_current->nsproxy->net_ns->ipv6.devconf_dflt,
 			       sizeof(ipv6_devconf_dflt));
 			break;
 		case 0:
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 4b098521a..a24618542 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1841,8 +1841,8 @@ static void ndisc_warn_deprecated_sysctl(struct ctl_table *ctl,
 {
 	static char warncomm[TASK_COMM_LEN];
 	static int warned;
-	if (strcmp(warncomm, current->comm) && warned < 5) {
-		strcpy(warncomm, current->comm);
+	if (strcmp(warncomm, sysiso_current->comm) && warned < 5) {
+		strcpy(warncomm, sysiso_current->comm);
 		pr_warn("process `%s' is using deprecated sysctl (%s) net.ipv6.neigh.%s.%s - use net.ipv6.neigh.%s.%s_ms instead\n",
 			warncomm, func,
 			dev_name, ctl->procname,
diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c
index 18316ee3c..50d7908f1 100644
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -63,7 +63,7 @@ do {									\
 			ret = -EAGAIN;					\
 			break;						\
 		}							\
-		if (signal_pending(current)) {				\
+		if (signal_pending(sysiso_current)) {				\
 			ret = sock_intr_errno(__timeo);			\
 			break;						\
 		}							\
@@ -830,7 +830,7 @@ static int iucv_sock_accept(struct socket *sock, struct socket *newsock,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
diff --git a/net/kcm/kcmsock.c b/net/kcm/kcmsock.c
index 11a715d76..9a399531d 100644
--- a/net/kcm/kcmsock.c
+++ b/net/kcm/kcmsock.c
@@ -1101,7 +1101,7 @@ static struct sk_buff *kcm_wait_data(struct sock *sk, int flags,
 		sk_wait_data(sk, &timeo, NULL);
 
 		/* Handle signals */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			*err = sock_intr_errno(timeo);
 			return NULL;
 		}
diff --git a/net/l2tp/l2tp_debugfs.c b/net/l2tp/l2tp_debugfs.c
index bca75bef8..2ecdb1076 100644
--- a/net/l2tp/l2tp_debugfs.c
+++ b/net/l2tp/l2tp_debugfs.c
@@ -279,7 +279,7 @@ static int l2tp_dfs_seq_open(struct inode *inode, struct file *file)
 	/* Derive the network namespace from the pid opening the
 	 * file.
 	 */
-	pd->net = get_net_ns_by_pid(current->pid);
+	pd->net = get_net_ns_by_pid(sysiso_current->pid);
 	if (IS_ERR(pd->net)) {
 		rc = PTR_ERR(pd->net);
 		goto err_free_pd;
diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c
index bf3571012..fc9cca1ea 100644
--- a/net/l2tp/l2tp_ppp.c
+++ b/net/l2tp/l2tp_ppp.c
@@ -548,7 +548,7 @@ static void pppol2tp_session_init(struct l2tp_session *session)
 
 	ps = l2tp_session_priv(session);
 	mutex_init(&ps->sk_lock);
-	ps->owner = current->pid;
+	ps->owner = sysiso_current->pid;
 }
 
 struct l2tp_connect_info {
diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index 3086f4a6a..9029b7434 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -504,7 +504,7 @@ static int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,
 			goto out;
 
 		rc = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out;
 	}
 
@@ -568,7 +568,7 @@ static int llc_ui_wait_for_disc(struct sock *sk, long timeout)
 		if (sk_wait_event(sk, &timeout, sk->sk_state == TCP_CLOSE, &wait))
 			break;
 		rc = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		rc = -EAGAIN;
 		if (!timeout)
@@ -587,7 +587,7 @@ static bool llc_ui_wait_for_conn(struct sock *sk, long timeout)
 	while (1) {
 		if (sk_wait_event(sk, &timeout, sk->sk_state != TCP_SYN_SENT, &wait))
 			break;
-		if (signal_pending(current) || !timeout)
+		if (signal_pending(sysiso_current) || !timeout)
 			break;
 	}
 	remove_wait_queue(sk_sleep(sk), &wait);
@@ -610,7 +610,7 @@ static int llc_ui_wait_for_busy_core(struct sock *sk, long timeout)
 				   !llc->p_flag), &wait))
 			break;
 		rc = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		rc = -EAGAIN;
 		if (!timeout)
@@ -638,7 +638,7 @@ static int llc_wait_data(struct sock *sk, long timeo)
 		if (!timeo)
 			break;
 		rc = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		rc = 0;
 		if (sk_wait_data(sk, &timeo, NULL))
@@ -774,7 +774,7 @@ static int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
 		 * handling. FIXME: Need to check this doesn't impact 1003.1g
 		 * and move it down to the bottom of the loop
 		 */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			if (copied)
 				break;
 			copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;
@@ -836,8 +836,8 @@ static int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
 
 		if ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {
 			net_dbg_ratelimited("LLC(%s:%d): Application bug, race in MSG_PEEK\n",
-					    current->comm,
-					    task_pid_nr(current));
+					    sysiso_current->comm,
+					    task_pid_nr(sysiso_current));
 			peek_seq = llc->copied_seq;
 		}
 		continue;
diff --git a/net/mptcp/protocol.c b/net/mptcp/protocol.c
index d073b2111..4949f9718 100644
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@ -2022,7 +2022,7 @@ static int mptcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 			    sk->sk_state == TCP_CLOSE ||
 			    (sk->sk_shutdown & RCV_SHUTDOWN) ||
 			    !timeo ||
-			    signal_pending(current))
+			    signal_pending(sysiso_current))
 				break;
 		} else {
 			if (sk->sk_err) {
@@ -2052,7 +2052,7 @@ static int mptcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 				break;
 			}
 
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				copied = sock_intr_errno(timeo);
 				break;
 			}
diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c
index 9d43277b8..f2248b7fa 100644
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@ -1759,7 +1759,7 @@ int start_sync_thread(struct netns_ipvs *ipvs, struct ipvs_sync_daemon_cfg *c,
 	int result = -ENOMEM;
 	u16 mtu, min_mtu;
 
-	IP_VS_DBG(7, "%s(): pid %d\n", __func__, task_pid_nr(current));
+	IP_VS_DBG(7, "%s(): pid %d\n", __func__, task_pid_nr(sysiso_current));
 	IP_VS_DBG(7, "Each ip_vs_sync_conn entry needs %zd bytes\n",
 		  sizeof(struct ip_vs_sync_conn_v0));
 
@@ -1947,7 +1947,7 @@ int stop_sync_thread(struct netns_ipvs *ipvs, int state)
 	int id;
 	int retc = -EINVAL;
 
-	IP_VS_DBG(7, "%s(): pid %d\n", __func__, task_pid_nr(current));
+	IP_VS_DBG(7, "%s(): pid %d\n", __func__, task_pid_nr(sysiso_current));
 
 	mutex_lock(&ipvs->sync_mutex);
 	if (state == IP_VS_STATE_MASTER) {
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 770a63103..51bea94cc 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -2612,7 +2612,7 @@ int nf_conntrack_set_hashsize(const char *val, const struct kernel_param *kp)
 	unsigned int hashsize;
 	int rc;
 
-	if (current->nsproxy->net_ns != &init_net)
+	if (sysiso_current->nsproxy->net_ns != &init_net)
 		return -EOPNOTSUPP;
 
 	/* On boot, we can set this without any fancy locking. */
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index c0851fec1..566aba045 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -7836,7 +7836,7 @@ static int nf_tables_fill_gen_info(struct sk_buff *skb, struct net *net,
 		goto nla_put_failure;
 
 	if (nla_put_be32(skb, NFTA_GEN_ID, htonl(nft_net->base_seq)) ||
-	    nla_put_be32(skb, NFTA_GEN_PROC_PID, htonl(task_pid_nr(current))) ||
+	    nla_put_be32(skb, NFTA_GEN_PROC_PID, htonl(task_pid_nr(sysiso_current))) ||
 	    nla_put_string(skb, NFTA_GEN_PROC_NAME, get_task_comm(buf, current)))
 		goto nla_put_failure;
 
diff --git a/net/netfilter/nfnetlink.c b/net/netfilter/nfnetlink.c
index 7e2c8dd01..3832642cc 100644
--- a/net/netfilter/nfnetlink.c
+++ b/net/netfilter/nfnetlink.c
@@ -424,7 +424,7 @@ static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,
 	while (skb->len >= nlmsg_total_size(0)) {
 		int msglen, type;
 
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			nfnl_err_reset(&err_list);
 			err = -EINTR;
 			status = NFNL_BATCH_FAILURE;
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index ada47e596..a0fd05230 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -821,7 +821,7 @@ static int netlink_autobind(struct socket *sock)
 	struct sock *sk = sock->sk;
 	struct net *net = sock_net(sk);
 	struct netlink_table *table = &nl_table[sk->sk_protocol];
-	s32 portid = task_tgid_vnr(current);
+	s32 portid = task_tgid_vnr(sysiso_current);
 	int err;
 	s32 rover = -4096;
 	bool ok;
@@ -1246,7 +1246,7 @@ int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
 		remove_wait_queue(&nlk->wait, &wait);
 		sock_put(sk);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			kfree_skb(skb);
 			return sock_intr_errno(*timeo);
 		}
diff --git a/net/netrom/af_netrom.c b/net/netrom/af_netrom.c
index 6d16e1ab1..fe6018b66 100644
--- a/net/netrom/af_netrom.c
+++ b/net/netrom/af_netrom.c
@@ -734,7 +734,7 @@ static int nr_connect(struct socket *sock, struct sockaddr *uaddr,
 					TASK_INTERRUPTIBLE);
 			if (sk->sk_state != TCP_SYN_SENT)
 				break;
-			if (!signal_pending(current)) {
+			if (!signal_pending(sysiso_current)) {
 				release_sock(sk);
 				schedule();
 				lock_sock(sk);
@@ -799,7 +799,7 @@ static int nr_accept(struct socket *sock, struct socket *newsock, int flags,
 			err = -EWOULDBLOCK;
 			break;
 		}
-		if (!signal_pending(current)) {
+		if (!signal_pending(sysiso_current)) {
 			release_sock(sk);
 			schedule();
 			lock_sock(sk);
diff --git a/net/nfc/llcp_sock.c b/net/nfc/llcp_sock.c
index 6cfd30fc0..e0cd61737 100644
--- a/net/nfc/llcp_sock.c
+++ b/net/nfc/llcp_sock.c
@@ -30,7 +30,7 @@ static int sock_wait_state(struct sock *sk, int state, unsigned long timeo)
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			break;
 		}
@@ -470,7 +470,7 @@ static int llcp_sock_accept(struct socket *sock, struct socket *newsock,
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			ret = sock_intr_errno(timeo);
 			break;
 		}
diff --git a/net/phonet/pep.c b/net/phonet/pep.c
index a15259168..82702c2e6 100644
--- a/net/phonet/pep.c
+++ b/net/phonet/pep.c
@@ -1163,7 +1163,7 @@ static int pep_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 			err = -EAGAIN;
 			goto out;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeo);
 			goto out;
 		}
diff --git a/net/rds/tcp.c b/net/rds/tcp.c
index abf19c0e3..4c53edba6 100644
--- a/net/rds/tcp.c
+++ b/net/rds/tcp.c
@@ -668,7 +668,7 @@ static void rds_tcp_sysctl_reset(struct net *net)
 static int rds_tcp_skbuf_handler(struct ctl_table *ctl, int write,
 				 void *buffer, size_t *lenp, loff_t *fpos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	int err;
 
 	err = proc_dointvec_minmax(ctl, write, buffer, lenp, fpos);
diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c
index cf7d974e0..0697604bd 100644
--- a/net/rose/af_rose.c
+++ b/net/rose/af_rose.c
@@ -842,7 +842,7 @@ static int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_le
 					TASK_INTERRUPTIBLE);
 			if (sk->sk_state != TCP_SYN_SENT)
 				break;
-			if (!signal_pending(current)) {
+			if (!signal_pending(sysiso_current)) {
 				release_sock(sk);
 				schedule();
 				lock_sock(sk);
@@ -909,7 +909,7 @@ static int rose_accept(struct socket *sock, struct socket *newsock, int flags,
 			err = -EWOULDBLOCK;
 			break;
 		}
-		if (!signal_pending(current)) {
+		if (!signal_pending(sysiso_current)) {
 			release_sock(sk);
 			schedule();
 			lock_sock(sk);
diff --git a/net/rxrpc/ar-internal.h b/net/rxrpc/ar-internal.h
index 7bd6f8a66..579808b67 100644
--- a/net/rxrpc/ar-internal.h
+++ b/net/rxrpc/ar-internal.h
@@ -1137,7 +1137,7 @@ static inline bool after_eq(u32 seq1, u32 seq2)
 extern unsigned int rxrpc_debug;
 
 #define dbgprintk(FMT,...) \
-	printk("[%-6.6s] "FMT"\n", current->comm ,##__VA_ARGS__)
+	printk("[%-6.6s] "FMT"\n", sysiso_current->comm ,##__VA_ARGS__)
 
 #define kenter(FMT,...)	dbgprintk("==> %s("FMT")",__func__ ,##__VA_ARGS__)
 #define kleave(FMT,...)	dbgprintk("<== %s()"FMT"",__func__ ,##__VA_ARGS__)
diff --git a/net/rxrpc/conn_client.c b/net/rxrpc/conn_client.c
index dbea0bfee..062f324a9 100644
--- a/net/rxrpc/conn_client.c
+++ b/net/rxrpc/conn_client.c
@@ -669,7 +669,7 @@ static int rxrpc_wait_for_channel(struct rxrpc_bundle *bundle,
 			break;
 		if ((call->interruptibility == RXRPC_INTERRUPTIBLE ||
 		     call->interruptibility == RXRPC_PREINTERRUPTIBLE) &&
-		    signal_pending(current)) {
+		    signal_pending(sysiso_current)) {
 			ret = -ERESTARTSYS;
 			break;
 		}
diff --git a/net/rxrpc/recvmsg.c b/net/rxrpc/recvmsg.c
index eca6dda26..fc6ab9eef 100644
--- a/net/rxrpc/recvmsg.c
+++ b/net/rxrpc/recvmsg.c
@@ -532,7 +532,7 @@ int rxrpc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
 			goto wait_error;
 
 		if (list_empty(&rx->recvmsg_q)) {
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				goto wait_interrupted;
 			trace_rxrpc_recvmsg(NULL, rxrpc_recvmsg_wait,
 					    0, 0, 0, 0);
diff --git a/net/rxrpc/sendmsg.c b/net/rxrpc/sendmsg.c
index af8ad6c30..49c3186f0 100644
--- a/net/rxrpc/sendmsg.c
+++ b/net/rxrpc/sendmsg.c
@@ -47,7 +47,7 @@ static int rxrpc_wait_for_tx_window_intr(struct rxrpc_sock *rx,
 		if (call->state >= RXRPC_CALL_COMPLETE)
 			return call->error;
 
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return sock_intr_errno(*timeo);
 
 		trace_rxrpc_transmit(call, rxrpc_transmit_wait);
@@ -87,7 +87,7 @@ static int rxrpc_wait_for_tx_window_waitall(struct rxrpc_sock *rx,
 			return call->error;
 
 		if (timeout == 0 &&
-		    tx_win == tx_start && signal_pending(current))
+		    tx_win == tx_start && signal_pending(sysiso_current))
 			return -EINTR;
 
 		if (tx_win != tx_start) {
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index 6b937bfd4..69a34868d 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -2829,7 +2829,8 @@ static int sctp_setsockopt_delayed_ack(struct sock *sk,
 				    "%s (pid %d) "
 				    "Use of struct sctp_assoc_value in delayed_ack socket option.\n"
 				    "Use struct sctp_sack_info instead\n",
-				    current->comm, task_pid_nr(current));
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 
 		p.sack_assoc_id = v->assoc_id;
 		p.sack_delay = v->assoc_value;
@@ -3252,7 +3253,8 @@ static int sctp_setsockopt_maxseg(struct sock *sk,
 				    "%s (pid %d) "
 				    "Use of int in maxseg socket option.\n"
 				    "Use struct sctp_assoc_value instead\n",
-				    current->comm, task_pid_nr(current));
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 		assoc_id = SCTP_FUTURE_ASSOC;
 		val = *(int *)params;
 	} else if (optlen == sizeof(struct sctp_assoc_value)) {
@@ -3518,7 +3520,8 @@ static int sctp_setsockopt_maxburst(struct sock *sk,
 				    "%s (pid %d) "
 				    "Use of int in max_burst socket option deprecated.\n"
 				    "Use struct sctp_assoc_value instead\n",
-				    current->comm, task_pid_nr(current));
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 		assoc_id = SCTP_FUTURE_ASSOC;
 		assoc_value = *((int *)params);
 	} else if (optlen == sizeof(struct sctp_assoc_value)) {
@@ -5603,7 +5606,7 @@ int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	int err = 0;
 
 	/* Do not peel off from one netns to another one. */
-	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
+	if (!net_eq(sysiso_current->nsproxy->net_ns, sock_net(sk)))
 		return -EINVAL;
 
 	if (!asoc)
@@ -6042,7 +6045,8 @@ static int sctp_getsockopt_delayed_ack(struct sock *sk, int len,
 				    "%s (pid %d) "
 				    "Use of struct sctp_assoc_value in delayed_ack socket option.\n"
 				    "Use struct sctp_sack_info instead\n",
-				    current->comm, task_pid_nr(current));
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 		if (copy_from_user(&params, optval, len))
 			return -EFAULT;
 	} else
@@ -6736,7 +6740,8 @@ static int sctp_getsockopt_maxseg(struct sock *sk, int len,
 				    "%s (pid %d) "
 				    "Use of int in maxseg socket option.\n"
 				    "Use struct sctp_assoc_value instead\n",
-				    current->comm, task_pid_nr(current));
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 		params.assoc_id = SCTP_FUTURE_ASSOC;
 	} else if (len >= sizeof(struct sctp_assoc_value)) {
 		len = sizeof(struct sctp_assoc_value);
@@ -6831,7 +6836,8 @@ static int sctp_getsockopt_maxburst(struct sock *sk, int len,
 				    "%s (pid %d) "
 				    "Use of int in max_burst socket option.\n"
 				    "Use struct sctp_assoc_value instead\n",
-				    current->comm, task_pid_nr(current));
+				    sysiso_current->comm,
+				    task_pid_nr(sysiso_current));
 		params.assoc_id = SCTP_FUTURE_ASSOC;
 	} else if (len >= sizeof(struct sctp_assoc_value)) {
 		len = sizeof(struct sctp_assoc_value);
@@ -8939,7 +8945,7 @@ static int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p)
 		goto out;
 
 	/* Handle signals.  */
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		goto interrupted;
 
 	/* Let another process have a go.  Since we are going to sleep
@@ -9184,7 +9190,7 @@ static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
 			goto do_nonblock;
 		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING)
 			goto do_error;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto do_interrupted;
 		if (sk_under_memory_pressure(sk))
 			sk_mem_reclaim(sk);
@@ -9294,7 +9300,7 @@ static int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)
 		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
 		    asoc->base.dead)
 			goto do_error;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto do_interrupted;
 
 		if (sctp_state(asoc, ESTABLISHED))
@@ -9362,7 +9368,7 @@ static int sctp_wait_for_accept(struct sock *sk, long timeo)
 			break;
 
 		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		err = -EAGAIN;
@@ -9386,7 +9392,7 @@ static void sctp_wait_for_close(struct sock *sk, long timeout)
 		release_sock(sk);
 		timeout = schedule_timeout(timeout);
 		lock_sock(sk);
-	} while (!signal_pending(current) && timeout);
+	} while (!signal_pending(sysiso_current) && timeout);
 
 	finish_wait(sk_sleep(sk), &wait);
 }
diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c
index b46a41678..4667cceb6 100644
--- a/net/sctp/sysctl.c
+++ b/net/sctp/sysctl.c
@@ -370,7 +370,7 @@ static struct ctl_table sctp_net_table[] = {
 static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,
 				 void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct ctl_table tbl;
 	bool changed = false;
 	char *none = "none";
@@ -415,7 +415,7 @@ static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,
 static int proc_sctp_do_rto_min(struct ctl_table *ctl, int write,
 				void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	unsigned int min = *(unsigned int *) ctl->extra1;
 	unsigned int max = *(unsigned int *) ctl->extra2;
 	struct ctl_table tbl;
@@ -443,7 +443,7 @@ static int proc_sctp_do_rto_min(struct ctl_table *ctl, int write,
 static int proc_sctp_do_rto_max(struct ctl_table *ctl, int write,
 				void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	unsigned int min = *(unsigned int *) ctl->extra1;
 	unsigned int max = *(unsigned int *) ctl->extra2;
 	struct ctl_table tbl;
@@ -481,7 +481,7 @@ static int proc_sctp_do_alpha_beta(struct ctl_table *ctl, int write,
 static int proc_sctp_do_auth(struct ctl_table *ctl, int write,
 			     void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct ctl_table tbl;
 	int new_value, ret;
 
@@ -510,7 +510,7 @@ static int proc_sctp_do_auth(struct ctl_table *ctl, int write,
 static int proc_sctp_do_udp_port(struct ctl_table *ctl, int write,
 				 void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	unsigned int min = *(unsigned int *)ctl->extra1;
 	unsigned int max = *(unsigned int *)ctl->extra2;
 	struct ctl_table tbl;
@@ -551,7 +551,7 @@ static int proc_sctp_do_udp_port(struct ctl_table *ctl, int write,
 static int proc_sctp_do_probe_interval(struct ctl_table *ctl, int write,
 				       void *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct net *net = current->nsproxy->net_ns;
+	struct net *net = sysiso_current->nsproxy->net_ns;
 	struct ctl_table tbl;
 	int ret, new_value;
 
diff --git a/net/smc/af_smc.c b/net/smc/af_smc.c
index 78b663dbf..705c748a6 100644
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@ -1070,7 +1070,7 @@ static void smc_connect_work(struct work_struct *work)
 		smc->sk.sk_state = SMC_CLOSED;
 		if (rc == -EPIPE || rc == -EAGAIN)
 			smc->sk.sk_err = EPIPE;
-		else if (signal_pending(current))
+		else if (signal_pending(sysiso_current))
 			smc->sk.sk_err = -sock_intr_errno(timeo);
 		sock_put(&smc->sk); /* passive closing */
 		goto out;
@@ -1958,7 +1958,7 @@ static int smc_accept(struct socket *sock, struct socket *new_sock,
 		/* wakeup by sk_data_ready in smc_listen_work() */
 		sched_annotate_sleep();
 		lock_sock(sk);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = sock_intr_errno(timeo);
 			break;
 		}
diff --git a/net/smc/smc_clc.c b/net/smc/smc_clc.c
index 6ec1ebe87..c29697e6d 100644
--- a/net/smc/smc_clc.c
+++ b/net/smc/smc_clc.c
@@ -360,7 +360,7 @@ int smc_clc_wait_msg(struct smc_sock *smc, void *buf, int buflen,
 	iov_iter_kvec(&msg.msg_iter, READ, &vec, 1,
 			sizeof(struct smc_clc_msg_hdr));
 	len = sock_recvmsg(smc->clcsock, &msg, krflags);
-	if (signal_pending(current)) {
+	if (signal_pending(sysiso_current)) {
 		reason_code = -EINTR;
 		clc_sk->sk_err = EINTR;
 		smc->sk.sk_err = EINTR;
diff --git a/net/smc/smc_close.c b/net/smc/smc_close.c
index 0f9ffba07..fd4e5cb00 100644
--- a/net/smc/smc_close.c
+++ b/net/smc/smc_close.c
@@ -59,7 +59,7 @@ static void smc_close_stream_wait(struct smc_sock *smc, long timeout)
 
 	smc->wait_close_tx_prepared = 1;
 	add_wait_queue(sk_sleep(sk), &wait);
-	while (!signal_pending(current) && timeout) {
+	while (!signal_pending(sysiso_current) && timeout) {
 		int rc;
 
 		rc = sk_wait_event(sk, &timeout,
@@ -196,7 +196,7 @@ int smc_close_active(struct smc_sock *smc)
 	long timeout;
 	int rc = 0;
 
-	timeout = current->flags & PF_EXITING ?
+	timeout = sysiso_current->flags & PF_EXITING ?
 		  0 : sock_flag(sk, SOCK_LINGER) ?
 		      sk->sk_lingertime : SMC_MAX_STREAM_WAIT_TIMEOUT;
 
@@ -435,7 +435,7 @@ int smc_close_shutdown_write(struct smc_sock *smc)
 	long timeout;
 	int rc = 0;
 
-	timeout = current->flags & PF_EXITING ?
+	timeout = sysiso_current->flags & PF_EXITING ?
 		  0 : sock_flag(sk, SOCK_LINGER) ?
 		      sk->sk_lingertime : SMC_MAX_STREAM_WAIT_TIMEOUT;
 
diff --git a/net/smc/smc_rx.c b/net/smc/smc_rx.c
index 170b733bc..e3e56f57e 100644
--- a/net/smc/smc_rx.c
+++ b/net/smc/smc_rx.c
@@ -337,7 +337,7 @@ int smc_rx_recvmsg(struct smc_sock *smc, struct msghdr *msg,
 			if (sk->sk_err ||
 			    sk->sk_state == SMC_CLOSED ||
 			    !timeo ||
-			    signal_pending(current))
+			    signal_pending(sysiso_current))
 				break;
 		} else {
 			if (sk->sk_err) {
@@ -354,7 +354,7 @@ int smc_rx_recvmsg(struct smc_sock *smc, struct msghdr *msg,
 				}
 				break;
 			}
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				read_done = sock_intr_errno(timeo);
 				break;
 			}
diff --git a/net/smc/smc_tx.c b/net/smc/smc_tx.c
index 738a4a99c..9fc5de4ff 100644
--- a/net/smc/smc_tx.c
+++ b/net/smc/smc_tx.c
@@ -104,7 +104,7 @@ static int smc_tx_wait(struct smc_sock *smc, int flags)
 			rc = -EAGAIN;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = sock_intr_errno(timeo);
 			break;
 		}
diff --git a/net/socket.c b/net/socket.c
index 7f64a6ecc..2b9261782 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -1412,7 +1412,7 @@ int __sock_create(struct net *net, int family, int type, int protocol,
 	 */
 	if (family == PF_INET && type == SOCK_PACKET) {
 		pr_info_once("%s uses obsolete (PF_INET,SOCK_PACKET)\n",
-			     current->comm);
+			     sysiso_current->comm);
 		family = PF_PACKET;
 	}
 
@@ -1512,7 +1512,8 @@ EXPORT_SYMBOL(__sock_create);
 
 int sock_create(int family, int type, int protocol, struct socket **res)
 {
-	return __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);
+	return __sock_create(sysiso_current->nsproxy->net_ns, family, type,
+			     protocol, res, 0);
 }
 EXPORT_SYMBOL(sock_create);
 
@@ -1696,6 +1697,7 @@ int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)
 		}
 		fput_light(sock->file, fput_needed);
 	}
+
 	return err;
 }
 
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index 5f42aa5fc..fcbd5de07 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -663,7 +663,7 @@ gss_create_upcall(struct gss_auth *gss_auth, struct gss_cred *gss_cred)
 			break;
 		}
 		spin_unlock(&pipe->lock);
-		if (fatal_signal_pending(current)) {
+		if (fatal_signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto out_intr;
 		}
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index f056ff931..1bdd69269 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -1803,7 +1803,7 @@ call_allocate(struct rpc_task *task)
 		return;
 	}
 
-	if (RPC_IS_ASYNC(task) || !fatal_signal_pending(current)) {
+	if (RPC_IS_ASYNC(task) || !fatal_signal_pending(sysiso_current)) {
 		task->tk_action = call_allocate;
 		rpc_delay(task, HZ>>4);
 		return;
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index c045f63d1..28ae3fbe6 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -269,7 +269,7 @@ EXPORT_SYMBOL_GPL(rpc_destroy_wait_queue);
 static int rpc_wait_bit_killable(struct wait_bit_key *key, int mode)
 {
 	freezable_schedule_unsafe();
-	if (signal_pending_state(mode, current))
+	if (signal_pending_state(mode, sysiso_current))
 		return -ERESTARTSYS;
 	return 0;
 }
@@ -1065,7 +1065,7 @@ static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *ta
 	INIT_LIST_HEAD(&task->tk_task);
 
 	task->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;
-	task->tk_owner = current->tgid;
+	task->tk_owner = sysiso_current->tgid;
 
 	/* Initialize workqueue for async tasks */
 	task->tk_workqueue = task_setup_data->workqueue;
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index a3bbe5ce4..ef7bc5c2b 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -1157,9 +1157,9 @@ static void svc_unregister(const struct svc_serv *serv, struct net *net)
 		}
 	}
 
-	spin_lock_irqsave(&current->sighand->siglock, flags);
+	spin_lock_irqsave(&sysiso_current->sighand->siglock, flags);
 	recalc_sigpending();
-	spin_unlock_irqrestore(&current->sighand->siglock, flags);
+	spin_unlock_irqrestore(&sysiso_current->sighand->siglock, flags);
 }
 
 /*
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index 6316bd2b8..a4021836a 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -722,7 +722,7 @@ rqst_should_sleep(struct svc_rqst *rqstp)
 		return false;
 
 	/* are we freezing? */
-	if (freezing(current))
+	if (freezing(sysiso_current))
 		return false;
 
 	return true;
diff --git a/net/sysctl_net.c b/net/sysctl_net.c
index f6cb0d4d1..fd6e5a3c0 100644
--- a/net/sysctl_net.c
+++ b/net/sysctl_net.c
@@ -30,12 +30,12 @@
 static struct ctl_table_set *
 net_ctl_header_lookup(struct ctl_table_root *root)
 {
-	return &current->nsproxy->net_ns->sysctls;
+	return &sysiso_current->nsproxy->net_ns->sysctls;
 }
 
 static int is_seen(struct ctl_table_set *set)
 {
-	return &current->nsproxy->net_ns->sysctls == set;
+	return &sysiso_current->nsproxy->net_ns->sysctls == set;
 }
 
 /* Return standard mode bits for table entry. */
diff --git a/net/tipc/socket.c b/net/tipc/socket.c
index ad570c245..ebb13910d 100644
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@ -416,7 +416,7 @@ static int tipc_sk_sock_err(struct socket *sock, long *timeout)
 	}
 	if (!*timeout)
 		return -EAGAIN;
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		return sock_intr_errno(*timeout);
 
 	return 0;
@@ -1856,7 +1856,7 @@ static int tipc_wait_for_rcvmsg(struct socket *sock, long *timeop)
 		if (!timeo)
 			break;
 		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 
 		err = sock_error(sk);
@@ -2532,7 +2532,7 @@ static int tipc_wait_for_connect(struct socket *sock, long *timeo_p)
 			return err;
 		if (!*timeo_p)
 			return -ETIMEDOUT;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return sock_intr_errno(*timeo_p);
 		if (sk->sk_state == TIPC_DISCONNECTING)
 			break;
@@ -2695,7 +2695,7 @@ static int tipc_wait_for_accept(struct socket *sock, long timeo)
 		if (!timeo)
 			break;
 		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 	return err;
diff --git a/net/tls/tls_main.c b/net/tls/tls_main.c
index 9ab81db8a..f86cba94e 100644
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@ -85,7 +85,7 @@ int wait_on_pending_writer(struct sock *sk, long *timeo)
 			break;
 		}
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			rc = sock_intr_errno(*timeo);
 			break;
 		}
diff --git a/net/tls/tls_sw.c b/net/tls/tls_sw.c
index 1b08b877a..ea083388f 100644
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@ -1331,7 +1331,7 @@ static struct sk_buff *tls_wait_data(struct sock *sk, struct sk_psock *psock,
 		remove_wait_queue(sk_sleep(sk), &wait);
 
 		/* Handle signals */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			*err = sock_intr_errno(timeo);
 			return NULL;
 		}
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 78e08e82c..ebe799cc3 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1393,7 +1393,7 @@ static int unix_stream_connect(struct socket *sock, struct sockaddr *uaddr,
 		timeo = unix_wait_for_peer(other, timeo);
 
 		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			goto out;
 		sock_put(other);
 		goto restart;
@@ -1905,7 +1905,7 @@ static int unix_dgram_sendmsg(struct socket *sock, struct msghdr *msg,
 			timeo = unix_wait_for_peer(other, timeo);
 
 			err = sock_intr_errno(timeo);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				goto out_free;
 
 			goto restart;
@@ -2455,7 +2455,7 @@ static long unix_stream_data_wait(struct sock *sk, long timeo,
 		    (tail && tail->len != last_len) ||
 		    sk->sk_err ||
 		    (sk->sk_shutdown & RCV_SHUTDOWN) ||
-		    signal_pending(current) ||
+		    signal_pending(sysiso_current) ||
 		    !timeo)
 			break;
 
@@ -2668,7 +2668,7 @@ static int unix_stream_read_generic(struct unix_stream_read_state *state,
 			timeo = unix_stream_data_wait(sk, timeo, last,
 						      last_len, freezable);
 
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				err = sock_intr_errno(timeo);
 				scm_destroy(&scm);
 				goto out;
diff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c
index e2c0cfb33..89f42c5c6 100644
--- a/net/vmw_vsock/af_vsock.c
+++ b/net/vmw_vsock/af_vsock.c
@@ -1393,7 +1393,7 @@ static int vsock_connect(struct socket *sock, struct sockaddr *addr,
 		timeout = schedule_timeout(timeout);
 		lock_sock(sk);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeout);
 			sk->sk_state = sk->sk_state == TCP_ESTABLISHED ? TCP_CLOSING : TCP_CLOSE;
 			sock->state = SS_UNCONNECTED;
@@ -1463,7 +1463,7 @@ static int vsock_accept(struct socket *sock, struct socket *newsock, int flags,
 		finish_wait(sk_sleep(listener), &wait);
 		lock_sock(listener);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeout);
 			goto out;
 		} else if (timeout == 0) {
@@ -1796,7 +1796,7 @@ static int vsock_connectible_sendmsg(struct socket *sock, struct msghdr *msg,
 			release_sock(sk);
 			timeout = wait_woken(&wait, TASK_INTERRUPTIBLE, timeout);
 			lock_sock(sk);
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				err = sock_intr_errno(timeout);
 				remove_wait_queue(sk_sleep(sk), &wait);
 				goto out_err;
@@ -1906,7 +1906,7 @@ static int vsock_connectible_wait_data(struct sock *sk,
 		timeout = schedule_timeout(timeout);
 		lock_sock(sk);
 
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = sock_intr_errno(timeout);
 			break;
 		} else if (timeout == 0) {
diff --git a/net/vmw_vsock/virtio_transport_common.c b/net/vmw_vsock/virtio_transport_common.c
index 59ee1be5a..7da159ae2 100644
--- a/net/vmw_vsock/virtio_transport_common.c
+++ b/net/vmw_vsock/virtio_transport_common.c
@@ -885,7 +885,7 @@ static void virtio_transport_wait_close(struct sock *sk, long timeout)
 			if (sk_wait_event(sk, &timeout,
 					  sock_flag(sk, SOCK_DONE), &wait))
 				break;
-		} while (!signal_pending(current) && timeout);
+		} while (!signal_pending(sysiso_current) && timeout);
 
 		remove_wait_queue(sk_sleep(sk), &wait);
 	}
@@ -952,7 +952,7 @@ static bool virtio_transport_close(struct vsock_sock *vsk)
 	if ((sk->sk_shutdown & SHUTDOWN_MASK) != SHUTDOWN_MASK)
 		(void)virtio_transport_shutdown(vsk, SHUTDOWN_MASK);
 
-	if (sock_flag(sk, SOCK_LINGER) && !(current->flags & PF_EXITING))
+	if (sock_flag(sk, SOCK_LINGER) && !(sysiso_current->flags & PF_EXITING))
 		virtio_transport_wait_close(sk, sk->sk_lingertime);
 
 	if (sock_flag(sk, SOCK_DONE)) {
diff --git a/net/x25/af_x25.c b/net/x25/af_x25.c
index 3583354a7..3a61382d4 100644
--- a/net/x25/af_x25.c
+++ b/net/x25/af_x25.c
@@ -712,7 +712,7 @@ static int x25_wait_for_connection_establishment(struct sock *sk)
 	for (;;) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		rc = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		rc = sock_error(sk);
 		if (rc) {
@@ -842,7 +842,7 @@ static int x25_wait_for_data(struct sock *sk, long timeout)
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			break;
 		rc = -ERESTARTSYS;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 		rc = -EAGAIN;
 		if (!timeout)
diff --git a/security/Kconfig b/security/Kconfig
index 0ced7fd33..254e2e228 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -54,6 +54,11 @@ config SECURITY_NETWORK
 	  implement socket and networking access controls.
 	  If you are unsure how to answer this question, answer N.
 
+config SYSISO
+       bool "Physically isolate kernel entry points"
+
+source "security/sysiso/Kconfig"
+
 config PAGE_TABLE_ISOLATION
 	bool "Remove the kernel mapping in user mode"
 	default y
@@ -293,4 +298,3 @@ config LSM
 source "security/Kconfig.hardening"
 
 endmenu
-
diff --git a/security/Makefile b/security/Makefile
index 18121f8f8..dc051e881 100644
--- a/security/Makefile
+++ b/security/Makefile
@@ -27,3 +27,5 @@ obj-$(CONFIG_SECURITY_LANDLOCK)		+= landlock/
 
 # Object integrity file lists
 obj-$(CONFIG_INTEGRITY)			+= integrity/
+
+obj-$(CONFIG_SYSISO)			+= sysiso/
diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c
index f72406fe1..bb52d54ea 100644
--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -418,7 +418,7 @@ static int apparmor_file_open(struct file *file)
 	 * implicit read and executable mmap which are required to
 	 * actually execute the image.
 	 */
-	if (current->in_execve) {
+	if (sysiso_current->in_execve) {
 		fctx->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;
 		return 0;
 	}
@@ -708,7 +708,7 @@ static void apparmor_bprm_committing_creds(struct linux_binprm *bprm)
 	    (unconfined(new_label)))
 		return;
 
-	aa_inherit_files(bprm->cred, current->files);
+	aa_inherit_files(bprm->cred, sysiso_current->files);
 
 	current->pdeath_signal = 0;
 
diff --git a/security/apparmor/path.c b/security/apparmor/path.c
index b02dfdbff..6b8ac9e60 100644
--- a/security/apparmor/path.c
+++ b/security/apparmor/path.c
@@ -118,7 +118,7 @@ static int d_namespace_path(const struct path *path, char *buf, char **name,
 	/* resolve paths relative to chroot?*/
 	if (flags & PATH_CHROOT_REL) {
 		struct path root;
-		get_fs_root(current->fs, &root);
+		get_fs_root(sysiso_current->fs, &root);
 		res = __d_path(path, &root, buf, buflen);
 		path_put(&root);
 	} else {
diff --git a/security/apparmor/procattr.c b/security/apparmor/procattr.c
index c929bf4a3..6f82960a9 100644
--- a/security/apparmor/procattr.c
+++ b/security/apparmor/procattr.c
@@ -127,12 +127,14 @@ int aa_setprocattr_changehat(char *args, size_t size, int flags)
 			char *next = hat + strlen(hat) + 1;
 			hats[count] = hat;
 			AA_DEBUG("%s: (pid %d) Magic 0x%llx count %d hat '%s'\n"
-				 , __func__, current->pid, token, count, hat);
+				 , __func__, sysiso_current->pid, token,
+				 count, hat);
 			hat = next;
 		}
 	} else
 		AA_DEBUG("%s: (pid %d) Magic 0x%llx count %d Hat '%s'\n",
-			 __func__, current->pid, token, count, "<NULL>");
+			 __func__, sysiso_current->pid, token, count,
+			 "<NULL>");
 
 	return aa_change_hat(hats, count, token, flags);
 }
diff --git a/security/apparmor/resource.c b/security/apparmor/resource.c
index 1ae487425..c844888fc 100644
--- a/security/apparmor/resource.c
+++ b/security/apparmor/resource.c
@@ -158,7 +158,7 @@ void __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)
 			for (j = 0, mask = 1; j < RLIM_NLIMITS; j++,
 				     mask <<= 1) {
 				if (old->rlimits.mask & mask) {
-					rlim = current->signal->rlim + j;
+					rlim = sysiso_current->signal->rlim + j;
 					initrlim = init_task.signal->rlim + j;
 					rlim->rlim_cur = min(rlim->rlim_max,
 							    initrlim->rlim_cur);
@@ -177,7 +177,7 @@ void __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)
 			if (!(new->rlimits.mask & mask))
 				continue;
 
-			rlim = current->signal->rlim + j;
+			rlim = sysiso_current->signal->rlim + j;
 			rlim->rlim_max = min(rlim->rlim_max,
 					     new->rlimits.limits[j].rlim_max);
 			/* soft limit should not exceed hard limit */
diff --git a/security/commoncap.c b/security/commoncap.c
index 3f810d37b..f1a44b3a2 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -1430,7 +1430,7 @@ int cap_mmap_addr(unsigned long addr)
 				  CAP_OPT_NONE);
 		/* set PF_SUPERPRIV if it turns out we allow the low mmap */
 		if (ret == 0)
-			current->flags |= PF_SUPERPRIV;
+			sysiso_current->flags |= PF_SUPERPRIV;
 	}
 	return ret;
 }
diff --git a/security/integrity/integrity_audit.c b/security/integrity/integrity_audit.c
index 292200562..c66a699ae 100644
--- a/security/integrity/integrity_audit.c
+++ b/security/integrity/integrity_audit.c
@@ -46,7 +46,7 @@ void integrity_audit_message(int audit_msgno, struct inode *inode,
 
 	ab = audit_log_start(audit_context(), GFP_KERNEL, audit_msgno);
 	audit_log_format(ab, "pid=%d uid=%u auid=%u ses=%u",
-			 task_pid_nr(current),
+			 task_pid_nr(sysiso_current),
 			 from_kuid(&init_user_ns, current_uid()),
 			 from_kuid(&init_user_ns, audit_get_loginuid(current)),
 			 audit_get_sessionid(current));
diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 5e6a90760..a255c7ed4 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -220,7 +220,7 @@ void key_set_index_key(struct keyring_index_key *index_key)
 
 	if (!index_key->domain_tag) {
 		if (index_key->type->flags & KEY_TYPE_NET_DOMAIN)
-			index_key->domain_tag = current->nsproxy->net_ns->key_domain;
+			index_key->domain_tag = sysiso_current->nsproxy->net_ns->key_domain;
 		else
 			index_key->domain_tag = &default_domain_tag;
 	}
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index b5d5333ab..387e87a19 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -913,7 +913,7 @@ void key_change_session_keyring(struct callback_head *twork)
 	const struct cred *old = current_cred();
 	struct cred *new = container_of(twork, struct cred, rcu);
 
-	if (unlikely(current->flags & PF_EXITING)) {
+	if (unlikely(sysiso_current->flags & PF_EXITING)) {
 		put_cred(new);
 		return;
 	}
diff --git a/security/keys/request_key_auth.c b/security/keys/request_key_auth.c
index 41e973500..34bb8ff75 100644
--- a/security/keys/request_key_auth.c
+++ b/security/keys/request_key_auth.c
@@ -204,7 +204,7 @@ struct key *request_key_auth_new(struct key *target, const char *op,
 	else {
 		/* it isn't - use this process as the context */
 		rka->cred = get_cred(cred);
-		rka->pid = current->pid;
+		rka->pid = sysiso_current->pid;
 	}
 
 	rka->target_key = key_get(target);
diff --git a/security/loadpin/loadpin.c b/security/loadpin/loadpin.c
index b12f7d986..44a561706 100644
--- a/security/loadpin/loadpin.c
+++ b/security/loadpin/loadpin.c
@@ -31,7 +31,7 @@ static void report_load(const char *origin, struct file *file, char *operation)
 		  (pathname && pathname[0] != '<') ? "\"" : "",
 		  pathname,
 		  (pathname && pathname[0] != '<') ? "\"" : "",
-		  task_pid_nr(current),
+		  task_pid_nr(sysiso_current),
 		  cmdline ? "\"" : "", cmdline, cmdline ? "\"" : "");
 
 	kfree(cmdline);
diff --git a/security/lockdown/lockdown.c b/security/lockdown/lockdown.c
index 87cbdc64d..6278e9258 100644
--- a/security/lockdown/lockdown.c
+++ b/security/lockdown/lockdown.c
@@ -64,7 +64,7 @@ static int lockdown_is_locked_down(enum lockdown_reason what)
 	if (kernel_locked_down >= what) {
 		if (lockdown_reasons[what])
 			pr_notice("Lockdown: %s: %s is restricted; see man kernel_lockdown.7\n",
-				  current->comm, lockdown_reasons[what]);
+				  sysiso_current->comm, lockdown_reasons[what]);
 		return -EPERM;
 	}
 
diff --git a/security/lsm_audit.c b/security/lsm_audit.c
index 5a5016ef4..186d7929a 100644
--- a/security/lsm_audit.c
+++ b/security/lsm_audit.c
@@ -208,7 +208,7 @@ static inline void print_ipv4_addr(struct audit_buffer *ab, __be32 addr,
 static void dump_common_audit_data(struct audit_buffer *ab,
 				   struct common_audit_data *a)
 {
-	char comm[sizeof(current->comm)];
+	char comm[sizeof(sysiso_current->comm)];
 
 	/*
 	 * To keep stack sizes in check force programers to notice if they
@@ -217,8 +217,8 @@ static void dump_common_audit_data(struct audit_buffer *ab,
 	 */
 	BUILD_BUG_ON(sizeof(a->u) > sizeof(void *)*2);
 
-	audit_log_format(ab, " pid=%d comm=", task_tgid_nr(current));
-	audit_log_untrustedstring(ab, memcpy(comm, current->comm, sizeof(comm)));
+	audit_log_format(ab, " pid=%d comm=", task_tgid_nr(sysiso_current));
+	audit_log_untrustedstring(ab, memcpy(comm, sysiso_current->comm, sizeof(comm)));
 
 	switch (a->type) {
 	case LSM_AUDIT_DATA_NONE:
diff --git a/security/security.c b/security/security.c
index 9ffa9e9c5..bda1a1297 100644
--- a/security/security.c
+++ b/security/security.c
@@ -355,7 +355,7 @@ static void __init ordered_lsm_init(void)
 						    blob_sizes.lbs_inode, 0,
 						    SLAB_PANIC, NULL);
 
-	lsm_early_cred((struct cred *) current->cred);
+	lsm_early_cred((struct cred *) sysiso_current->cred);
 	lsm_early_task(current);
 	for (lsm = ordered_lsms; *lsm; lsm++)
 		initialize_lsm(*lsm);
@@ -1549,7 +1549,7 @@ static inline unsigned long mmap_prot(struct file *file, unsigned long prot)
 	 */
 	if ((prot & (PROT_READ | PROT_EXEC)) != PROT_READ)
 		return prot;
-	if (!(current->personality & READ_IMPLIES_EXEC))
+	if (!(sysiso_current->personality & READ_IMPLIES_EXEC))
 		return prot;
 	/*
 	 * if that's an anonymous mapping, let it.
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index e7ebd45ca..fe37dd3bb 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -2532,7 +2532,7 @@ static void selinux_bprm_committing_creds(struct linux_binprm *bprm)
 		return;
 
 	/* Close files for which the new task SID is not authorized. */
-	flush_unauthorized_files(bprm->cred, current->files);
+	flush_unauthorized_files(bprm->cred, sysiso_current->files);
 
 	/* Always clear parent death signal on SID transitions. */
 	current->pdeath_signal = 0;
@@ -2552,13 +2552,13 @@ static void selinux_bprm_committing_creds(struct linux_binprm *bprm)
 			  PROCESS__RLIMITINH, NULL);
 	if (rc) {
 		/* protect against do_prlimit() */
-		task_lock(current);
+		task_lock(sysiso_current);
 		for (i = 0; i < RLIM_NLIMITS; i++) {
-			rlim = current->signal->rlim + i;
+			rlim = sysiso_current->signal->rlim + i;
 			initrlim = init_task.signal->rlim + i;
 			rlim->rlim_cur = min(rlim->rlim_max, initrlim->rlim_cur);
 		}
-		task_unlock(current);
+		task_unlock(sysiso_current);
 		if (IS_ENABLED(CONFIG_POSIX_TIMERS))
 			update_rlimit_cpu(current, rlimit(RLIMIT_CPU));
 	}
@@ -2592,21 +2592,21 @@ static void selinux_bprm_committed_creds(struct linux_binprm *bprm)
 	if (rc) {
 		clear_itimer();
 
-		spin_lock_irq(&current->sighand->siglock);
-		if (!fatal_signal_pending(current)) {
-			flush_sigqueue(&current->pending);
-			flush_sigqueue(&current->signal->shared_pending);
+		spin_lock_irq(&sysiso_current->sighand->siglock);
+		if (!fatal_signal_pending(sysiso_current)) {
+			flush_sigqueue(&sysiso_current->pending);
+			flush_sigqueue(&sysiso_current->signal->shared_pending);
 			flush_signal_handlers(current, 1);
-			sigemptyset(&current->blocked);
+			sigemptyset(&sysiso_current->blocked);
 			recalc_sigpending();
 		}
-		spin_unlock_irq(&current->sighand->siglock);
+		spin_unlock_irq(&sysiso_current->sighand->siglock);
 	}
 
 	/* Wake up the parent if it is waiting so that it can recheck
 	 * wait permission to the new task SID. */
 	read_lock(&tasklist_lock);
-	__wake_up_parent(current, current->real_parent);
+	__wake_up_parent(current, sysiso_current->real_parent);
 	read_unlock(&tasklist_lock);
 }
 
@@ -6047,7 +6047,7 @@ static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)
 				" pid=%d comm=%s\n",
 				sk->sk_protocol, nlh->nlmsg_type,
 				secclass_map[sclass - 1].name,
-				task_pid_nr(current), current->comm);
+				task_pid_nr(sysiso_current), sysiso_current->comm);
 			if (enforcing_enabled(&selinux_state) &&
 			    !security_get_allow_unknown(&selinux_state))
 				return rc;
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index e4cd7cb85..b60a03b5f 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -752,11 +752,11 @@ static ssize_t sel_write_checkreqprot(struct file *file, const char __user *buf,
 		goto out;
 
 	if (new_value) {
-		char comm[sizeof(current->comm)];
+		char comm[sizeof(sysiso_current->comm)];
 
-		memcpy(comm, current->comm, sizeof(comm));
+		memcpy(comm, sysiso_current->comm, sizeof(comm));
 		pr_warn_once("SELinux: %s (%d) set checkreqprot to 1. This is deprecated and will be rejected in a future kernel release.\n",
-			     comm, current->pid);
+			     comm, sysiso_current->pid);
 	}
 
 	checkreqprot_set(fsi->state, (new_value ? 1 : 0));
diff --git a/security/smack/smack_access.c b/security/smack/smack_access.c
index d2186e275..438d2c47a 100644
--- a/security/smack/smack_access.c
+++ b/security/smack/smack_access.c
@@ -692,7 +692,7 @@ bool smack_privileged(int cap)
 	/*
 	 * All kernel tasks are privileged
 	 */
-	if (unlikely(current->flags & PF_KTHREAD))
+	if (unlikely(sysiso_current->flags & PF_KTHREAD))
 		return true;
 
 	return smack_privileged_cred(cap, current_cred());
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 21a0e7c3b..6ae49f999 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -148,7 +148,7 @@ static int smk_bu_current(char *note, struct smack_known *oskp,
 	smk_bu_mode(mode, acc);
 	pr_info("Smack %s: (%s %s %s) %s %s\n", smk_bu_mess[rc],
 		tsp->smk_task->smk_known, oskp->smk_known,
-		acc, current->comm, note);
+		acc, sysiso_current->comm, note);
 	return 0;
 }
 #else
@@ -170,7 +170,7 @@ static int smk_bu_task(struct task_struct *otp, int mode, int rc)
 	smk_bu_mode(mode, acc);
 	pr_info("Smack %s: (%s %s %s) %s to %s\n", smk_bu_mess[rc],
 		tsp->smk_task->smk_known, smk_task->smk_known, acc,
-		current->comm, otp->comm);
+		sysiso_current->comm, otp->comm);
 	return 0;
 }
 #else
@@ -186,7 +186,7 @@ static int smk_bu_inode(struct inode *inode, int mode, int rc)
 
 	if (isp->smk_flags & SMK_INODE_IMPURE)
 		pr_info("Smack Unconfined Corruption: inode=(%s %ld) %s\n",
-			inode->i_sb->s_id, inode->i_ino, current->comm);
+			inode->i_sb->s_id, inode->i_ino, sysiso_current->comm);
 
 	if (rc <= 0)
 		return rc;
@@ -200,7 +200,7 @@ static int smk_bu_inode(struct inode *inode, int mode, int rc)
 
 	pr_info("Smack %s: (%s %s %s) inode=(%s %ld) %s\n", smk_bu_mess[rc],
 		tsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,
-		inode->i_sb->s_id, inode->i_ino, current->comm);
+		inode->i_sb->s_id, inode->i_ino, sysiso_current->comm);
 	return 0;
 }
 #else
@@ -218,7 +218,7 @@ static int smk_bu_file(struct file *file, int mode, int rc)
 
 	if (isp->smk_flags & SMK_INODE_IMPURE)
 		pr_info("Smack Unconfined Corruption: inode=(%s %ld) %s\n",
-			inode->i_sb->s_id, inode->i_ino, current->comm);
+			inode->i_sb->s_id, inode->i_ino, sysiso_current->comm);
 
 	if (rc <= 0)
 		return rc;
@@ -229,7 +229,7 @@ static int smk_bu_file(struct file *file, int mode, int rc)
 	pr_info("Smack %s: (%s %s %s) file=(%s %ld %pD) %s\n", smk_bu_mess[rc],
 		sskp->smk_known, smk_of_inode(inode)->smk_known, acc,
 		inode->i_sb->s_id, inode->i_ino, file,
-		current->comm);
+		sysiso_current->comm);
 	return 0;
 }
 #else
@@ -248,7 +248,7 @@ static int smk_bu_credfile(const struct cred *cred, struct file *file,
 
 	if (isp->smk_flags & SMK_INODE_IMPURE)
 		pr_info("Smack Unconfined Corruption: inode=(%s %ld) %s\n",
-			inode->i_sb->s_id, inode->i_ino, current->comm);
+			inode->i_sb->s_id, inode->i_ino, sysiso_current->comm);
 
 	if (rc <= 0)
 		return rc;
@@ -259,7 +259,7 @@ static int smk_bu_credfile(const struct cred *cred, struct file *file,
 	pr_info("Smack %s: (%s %s %s) file=(%s %ld %pD) %s\n", smk_bu_mess[rc],
 		sskp->smk_known, smk_of_inode(inode)->smk_known, acc,
 		inode->i_sb->s_id, inode->i_ino, file,
-		current->comm);
+		sysiso_current->comm);
 	return 0;
 }
 #else
@@ -2241,7 +2241,7 @@ static int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)
 	/*
 	 * Sockets created by kernel threads receive web label.
 	 */
-	if (unlikely(current->flags & PF_KTHREAD)) {
+	if (unlikely(sysiso_current->flags & PF_KTHREAD)) {
 		ssp->smk_in = &smack_known_web;
 		ssp->smk_out = &smack_known_web;
 	} else {
@@ -2757,7 +2757,7 @@ static int smack_socket_post_create(struct socket *sock, int family,
 	/*
 	 * Sockets created by kernel threads receive web label.
 	 */
-	if (unlikely(current->flags & PF_KTHREAD)) {
+	if (unlikely(sysiso_current->flags & PF_KTHREAD)) {
 		ssp = sock->sk->sk_security;
 		ssp->smk_in = &smack_known_web;
 		ssp->smk_out = &smack_known_web;
@@ -4881,7 +4881,7 @@ static __init void init_smack_known_list(void)
  */
 static __init int smack_init(void)
 {
-	struct cred *cred = (struct cred *) current->cred;
+	struct cred *cred = (struct cred *) sysiso_current->cred;
 	struct task_smack *tsp;
 
 	smack_rule_cache = KMEM_CACHE(smack_rule, 0);
diff --git a/security/sysiso/Kconfig b/security/sysiso/Kconfig
new file mode 100644
index 000000000..9ef9487d8
--- /dev/null
+++ b/security/sysiso/Kconfig
@@ -0,0 +1,12 @@
+
+config SYSISO_USERSPACE
+       bool "Build user space tools"
+       depends on SYSISO
+
+config SYSISO_DEBUG
+       bool "Sysiso debugging"
+       depends on SYSISO
+
+config SYSISO_DEBUG_TRACE
+       bool "Debug via ftrace"
+       depends on SYSISO_DEBUG
diff --git a/security/sysiso/Makefile b/security/sysiso/Makefile
new file mode 100644
index 000000000..818d51b81
--- /dev/null
+++ b/security/sysiso/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_SYSISO) += init.o syscall_client.o sysisod.o proc.o task_queue.o sysisod_asm.o kernel_interface.o sysfs.o
+
+obj-$(CONFIG_SYSISO) += tests/
+obj-$(CONFIG_SYSISO_USERSPACE) += userspace/
+
+ccflags-$(CONFIG_SYSISO_DEBUG)    += -DDEBUG
diff --git a/security/sysiso/debug.h b/security/sysiso/debug.h
new file mode 100644
index 000000000..95a39d2d3
--- /dev/null
+++ b/security/sysiso/debug.h
@@ -0,0 +1,22 @@
+#include <linux/kernel.h>
+
+#ifndef CONFIG_SYSISO_DEBUG_TRACE
+
+#define sysiso_debug(fmt, ...)			\
+	pr_debug("SYSISO " fmt,			\
+		 ##__VA_ARGS__)
+#else
+#define sysiso_debug(fmt, ...)			\
+	trace_printk(fmt,			\
+		 ##__VA_ARGS__)
+#endif
+
+#define sysiso_debug_task(task, action)					\
+	sysiso_debug("%s %d for %s(%d) %x|%x CPU %d\n",			\
+		     action,						\
+		     task->id,						\
+		     task->client->comm,				\
+		     task->client->pid,					\
+		     sysiso_task_read_state(task),			\
+		     task->client->__state,				\
+		     smp_processor_id())
diff --git a/security/sysiso/init.c b/security/sysiso/init.c
new file mode 100644
index 000000000..d114de5b1
--- /dev/null
+++ b/security/sysiso/init.c
@@ -0,0 +1,84 @@
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/sysiso.h>
+
+#include <linux/cpumask.h>
+#include <linux/topology.h>
+
+#include "internal.h"
+#include "debug.h"
+
+/* cpumasks for each physical core */
+cpumask_var_t cpu_cores[MAX_CORES];
+
+/* cpumaks for cores sysiso servers may run */
+cpumask_var_t sysiso_server_cores;
+
+/* total number of clients */
+static atomic_t active_clients = ATOMIC_INIT(0);
+
+/* globals */
+bool sysiso_enabled_globally = false;
+
+int sysiso_cpus_per_core;
+
+/* There appears to be no runtime topology information in the kernel, so we do
+ * it ourselves */
+static void sysiso_cores_init(void)
+{
+	int cpu, core;
+
+	/*
+	 * Note that we iterrate over alle physical cores, not over all CPUs.
+	 * Currently, we assume the worst case: each core = one cpu.
+	 */
+	for_each_physical_core(cpu)
+		zalloc_cpumask_var(&cpu_cores[cpu], GFP_KERNEL);
+
+	/* Ugly, but the boot code does it the same way. This code runs only
+	 * once during booting. */
+	for_each_possible_cpu(cpu) {
+		for_each_physical_core(core) {
+
+			if (!cpumask_empty(cpu_cores[core]) &&
+			    cpumask_equal(cpu_cores[core], topology_sibling_cpumask(cpu))) {
+				break;
+			} else if (cpumask_empty(cpu_cores[core])) {
+				sysiso_debug("cpu_cores[%d] -> [%*pbl]\n",
+					 core, cpumask_pr_args(topology_sibling_cpumask(cpu)));
+
+				cpumask_copy(cpu_cores[core], topology_sibling_cpumask(cpu));
+				break;
+			}
+		}
+	}
+
+	sysiso_cpus_per_core = cpumask_weight(cpu_cores[0]);
+}
+
+
+void __init sysiso_pre_sched_init()
+{
+	zalloc_cpumask_var(&sysiso_server_cores, GFP_KERNEL);
+}
+
+/*
+ * Init stuff that is needed on boot
+ */
+void sysiso_init()
+{
+	sysiso_cores_init();
+
+	if (sysiso_proc_init())
+		/* There are nicer ways than panicking. But practically
+		 * this does not happen. */
+		panic("SYSISO: Could not initialize sysiso procfs\n");
+
+	if (sysiso_init_sysfs())
+		panic("SYSISO: Could not initialize sysiso sysfs. Not enough memory?\n");
+
+	sysiso_init_supported_syscalls_bitmap();
+
+	sysiso_init_queue();
+}
diff --git a/security/sysiso/internal.h b/security/sysiso/internal.h
new file mode 100644
index 000000000..9284fdd9d
--- /dev/null
+++ b/security/sysiso/internal.h
@@ -0,0 +1,291 @@
+#include <linux/threads.h>
+#include <linux/cpumask.h>
+#include <linux/sched.h>
+
+#ifndef __SYSISO_INTERNAL_H__
+#define __SYSISO_INTERNAL_H__
+#define SYSISO_SERVER_DONE 1
+
+struct sysiso_syscall {
+	int nr;
+	unsigned long args[6];
+	struct pt_regs *regs;
+	unsigned long result;
+};
+
+enum sysiso_task_type {
+	SYSISO_SYSCALL,
+	SYSISO_PAGE_FAULT,
+	SYSISO_INTERRUPT
+};
+
+union sysiso_event {
+	struct sysiso_syscall syscall;
+	/* sysiso_page_fault page_fault; */
+	/* sysiso_interrupt interrupt */
+};
+
+#define SYSISO_TASK_FIRST_RUN		0x0001	/* No schedule() invocation */
+#define SYSISO_TASK_RUNNABLE		0x0002	/* Should be picked from the server's run queue */
+#define SYSISO_TASK_DEFERRED_WORK	0x0004	/* Executing a workqueue cannot finish */
+#define SYSISO_TASK_TIMER		0x0008	/* Task waiting for a timer */
+#define SYSISO_TASK_DONE		0x0010
+
+/* convenience macros */
+#define SYSISO_TASK_NEW			(SYSISO_TASK_FIRST_RUN | SYSISO_TASK_RUNNABLE)
+#define SYSISO_TASK_WAITING		(SYSISO_TASK_RUNNABLE | SYSISO_TASK_DEFERRED_WORK)
+
+#define sysiso_task_read_state(task)			smp_load_acquire(&task->state)
+#define sysiso_task_read_state_local(task)		task->state
+
+/* overwrite the state */
+#define sysiso_task_set_state(task, __state)		smp_store_release(&task->state, (__state))
+
+/* overwrite the state, locally */
+#define sysiso_task_set_state_local(task, __state)	task->state = __state
+
+/* just set a flag */
+#define sysiso_task_set_state_flag(task, __state)	sysiso_task_set_state(task, \
+									      (sysiso_task_read_state(task) \
+									       |  __state))
+
+/* just set a flag, without SMP synchronization */
+#define sysiso_task_set_state_flag_local(task, __state)	sysiso_task_set_state_local(task, \
+									      (task->state |  __state))
+
+#define sysiso_task_clear_state_flag(task, __state)	sysiso_task_set_state(task, \
+									      (sysiso_task_read_state(task) \
+									       &~ __state))
+
+#define sysiso_task_test_flag_local(task, __state)	(task->state & __state)
+#define sysiso_task_clear_flag_local(task, __state)	task->state &= ~__state
+
+/* Just add a flag */
+#define sysiso_task_set_runnable(task)		sysiso_task_set_state_flag(task, SYSISO_TASK_RUNNABLE)
+#define sysiso_task_set_deferred_work(task)	sysiso_task_set_state_flag(task, SYSISO_TASK_DEFERRED_WORK)
+
+#define sysiso_task_is_first_run(task)		(sysiso_task_read_state(task) & SYSISO_TASK_FIRST_RUN)
+#define sysiso_task_is_runnable(task)		(sysiso_task_read_state(task) & SYSISO_TASK_RUNNABLE)
+#define sysiso_task_has_deferred_work(task)	(sysiso_task_read_state(task) & SYSISO_TASK_DEFERRED_WORK)
+#define sysiso_task_is_done(task)		(sysiso_task_read_state(task) == SYSISO_TASK_DONE)
+
+#define sysiso_task_is_waiting(task)		(sysiso_task_read_state(task) == SYSISO_TASK_WAITING)
+#define sysiso_task_wake_up(task)		sysiso_task_clear_state_flag(task, SYSISO_TASK_DEFERRED_WORK)
+
+struct sysiso_task {
+	struct task_struct *client;
+	union sysiso_event event;
+	enum sysiso_task_type type;
+	unsigned int state;
+	int id;
+	int id_cnt;
+
+	void *stack;			/* lowest address */
+	unsigned long stack_top;
+	unsigned long rsp;		/* rsp to continue after scheduling */
+	unsigned long sysisod_rsp;	/* sysisod's rsp to return when scheduling */
+	bool needs_wakeup;
+
+	struct hrtimer_sleeper hrtimer_sleeper;
+
+	struct list_head node;
+};
+
+struct sysiso_server {
+	unsigned long rsp;
+	bool running;
+	int cpu;
+	struct task_struct *linux_task; /* kernel thread of sysisod */
+
+	struct list_head local_queue;
+	int queue_len;
+
+	/* stats */
+	unsigned long syscalls_processed;
+
+};
+
+
+int sysiso_proc_init(void);
+int sysiso_init_sysfs(void);
+
+/*
+ *  pysical cores, worst case is (theoretically) one cpu per core. The kernel
+ *  does not provide these infos, so we do it ourselves
+ */
+#define MAX_CORES NR_CPUS
+/* pretend to be consistent with for_each_cpu and friends */
+#define for_each_physical_core(core) \
+	for ((core) = 0;	     \
+	     (core) < MAX_CORES;     \
+	     (core)++)
+
+/* cpumasks for each physical core */
+extern cpumask_var_t cpu_cores[MAX_CORES];
+
+/* cpumaks for cores sysiso servers may run */
+extern cpumask_var_t sysiso_server_cores;
+
+#define SYSISO_NO_CPU -1
+
+/* prototypes */
+void sysiso_init(void);
+
+static inline bool sysiso_linux_state_is_sleeping(unsigned int __state)
+{
+	return (__state &
+		(TASK_INTERRUPTIBLE |
+		 TASK_UNINTERRUPTIBLE |
+		 TASK_KILLABLE));
+}
+
+static inline bool sysiso_state_is_sleeping(long state)
+{
+	return state & (TASK_INTERRUPTIBLE |
+		 TASK_UNINTERRUPTIBLE |
+		 TASK_KILLABLE);
+}
+
+DECLARE_PER_CPU(struct sysiso_server, sysiso_server);
+DECLARE_PER_CPU(struct sysiso_task *, sysisod_current_task);
+
+static __always_inline struct sysiso_task *get_sysisod_current(void)
+{
+	return this_cpu_read(sysisod_current_task);
+}
+
+#define sysisod_current get_sysisod_current()
+
+void sysiso_start_servers_on_core(int core_index);
+void sysiso_adjust_servers(int n);
+
+/* queue functions */
+void sysiso_init_queue(void);
+void sysiso_destroy_queue(void);
+
+struct sysiso_task *sysiso_queue_get(void);
+struct sysiso_task *sysisod_recv_new_task(void);
+void sysiso_send_new_task(struct sysiso_task *task);
+
+/* local queue */
+struct sysiso_task *sysisod_dequeue(void);
+void sysisod_enqueue(struct sysiso_task *task);
+bool sysisod_local_queue_empty(void);
+
+/* testing stuff that needs to be global */
+void sysiso_wakep_test_waitqueue(void);
+
+/* below is lots of potential garbage! */
+
+/* void sysiso_tear_down_globally(void); */
+
+/* sysisod scheduler */
+extern void sysisod_exec_task_asm(unsigned long task_rsp, unsigned long *sysisod_rsp);
+extern void sysisod_switch_to_task_asm(unsigned long task_rsp, unsigned long *sysisod_rsp);
+extern unsigned long sysisod_switch_to_server_asm(unsigned long *task_rsp, unsigned long sysisod_rsp);
+
+/* globals */
+extern bool sysiso_enabled_globally;
+extern atomic_t sysiso_servers_running;
+
+extern int sysiso_cpus_per_core;
+
+/* supported syscalls */
+
+inline void sysiso_init_supported_syscalls_bitmap(void);
+
+inline bool sysiso_syscall_is_supported(unsigned long nr);
+
+
+#ifdef SYSISO_SYSCALLS_UNSUPPORTED_LIST
+static const int sysiso_unsupported_syscalls_list[] = {
+	__NR_exit_group,
+	__NR_fork,
+	__NR_clone,
+	__NR_clone3,
+	__NR_rt_sigaction,
+	__NR_rt_sigprocmask,
+	__NR_rt_sigreturn,
+	__NR_wait4,
+//	__NR_sleep,
+	__NR_execve,
+	__NR_nanosleep,
+	__NR_clock_nanosleep,
+
+
+	__NR_rt_sigpending,
+	__NR_rt_sigtimedwait,
+	__NR_rt_sigqueueinfo,
+	__NR_rt_sigsuspend,
+	__NR_sigaltstack,
+
+	__NR_prctl,
+	__NR_arch_prctl,
+
+	__NR_dup,
+	__NR_dup2,
+	__NR_dup3,
+};
+#else
+static const int sysiso_supported_syscalls_list[] = {
+
+	__NR_sysiso_test,
+	__NR_read,
+	__NR_gettid,
+
+	__NR_getpid,
+	__NR_getppid,
+
+/* 	__NR_sendto, */
+	__NR_write,
+
+	/* lighttpd */
+	__NR_sendfile,
+	/* __NR_accept4, */
+
+/* 	__NR_recvfrom, */
+/* 	__NR_stat, */
+	__NR_writev,
+/* 	__NR_fstat, */
+/* 	__NR_setsockopt, */
+	__NR_accept4,
+	__NR_open,
+	__NR_openat,
+	__NR_close,
+
+	__NR_stat,
+	__NR_newfstatat,
+	__NR_getrusage,
+	__NR_wait4,
+	__NR_pselect6,
+	__NR_kill,
+	__NR_creat,
+	__NR_sendto,
+	__NR_recvfrom,
+	__NR_fcntl,
+
+	/* __NR_lseek, */
+
+	/* __NR_mprotect, */
+	__NR_pread64,
+	__NR_access,
+
+	__NR_getuid,
+	__NR_geteuid,
+	__NR_getgid,
+	__NR_getegid,
+
+	__NR_mkdir,
+	__NR_rmdir,
+
+	/* __NR_epoll_ctl, */
+	/* __NR_epoll_wait, */
+
+	__NR_bind,
+
+	__NR_rt_sigreturn,
+	__NR_rt_sigaction
+};
+#endif /* SYSISO_SYSCALLS_UNSUPPORTED_LIST */
+
+#endif
diff --git a/security/sysiso/kernel_interface.c b/security/sysiso/kernel_interface.c
new file mode 100644
index 000000000..905fcf263
--- /dev/null
+++ b/security/sysiso/kernel_interface.c
@@ -0,0 +1,189 @@
+#include <linux/sysiso.h>
+#include <linux/workqueue.h>
+#include "internal.h"
+#include "debug.h"
+
+
+static void sysiso_set_client_state(unsigned int state)
+{
+
+	/* We need to handle any deferred work, so don't change the state */
+
+	sysiso_debug("setting linux__state 0x%x for %s(%d) on CPU %d\n",
+		     state,
+		     sysisod_current->client->comm,
+		     sysisod_current->client->pid,
+		     smp_processor_id());
+
+	if (sysiso_linux_state_is_sleeping(state))
+		sysiso_task_set_state(sysisod_current, SYSISO_TASK_WAITING);
+
+	if (state == TASK_RUNNING)
+		sysiso_task_wake_up(sysisod_current);
+
+	smp_store_mb(sysisod_current->client->__state, state);
+}
+
+/*
+ * Wrapper for __set_current_state
+ */
+void sysiso___set_current_state(unsigned int state)
+{
+	if (sysiso_current_is_server())
+		sysiso_set_client_state(state);
+	else
+		__set_current_state_linux(state);
+}
+
+void sysiso_set_current_state(unsigned int state)
+{
+	if (sysiso_current_is_server())
+		sysiso_set_client_state(state);
+	else
+		set_current_state_linux(state);
+}
+
+/*
+ * return if the kernel should thing the process was woken up successfully
+ */
+bool sysiso_try_to_wake_up(struct task_struct *linux_task)
+{
+	struct sysiso_task *task;
+
+	/*
+	 *  Deferred work always thinks it's waking up the sysisod kthread
+	 */
+	if (!sysiso_task_is_server(linux_task))
+		return false;
+
+	/*
+	 * If someone wakes up a sysiso_server, we always want to wake up the
+	 * sysiso task, e.g., when __try_to_wake_up is called from a waitqueue
+	 * (NOT a workqueue), the server has already been woken up.
+	 */
+	if (!current_work())
+		return true;
+
+	/* We know that we are waking up from a workqueue */
+	if ((task = current_work()->sysiso_task)) {
+
+		BUG_ON(!sysiso_cpu_is_server(smp_processor_id()));
+		sysiso_debug_task(task, "-> RUNNABLE");
+		task->needs_wakeup = true;
+		sysiso_task_set_state(task, SYSISO_TASK_RUNNABLE);
+	}
+	return true;
+}
+
+/* Workqueues */
+
+struct work_struct;
+
+void sysiso__queue_work(struct work_struct *work)
+{
+	if (!sysiso_current_is_server())
+		return;
+
+	/*
+	 * Here, we only care about work that is queued by syscalls, for
+	 * workqueues defined by interrupts it's enough to bind them to a server
+	 * cpu
+	 */
+	if (in_interrupt())
+		return;
+
+	sysiso_debug_task(sysisod_current, "-> WAIT (from workqueue)");
+
+	sysiso_task_set_state(sysisod_current, SYSISO_TASK_WAITING);
+	work->sysiso_task = sysisod_current;
+}
+
+/* Waitqueues */
+void sysiso_init_wait_entry(struct wait_queue_entry *wq_entry)
+{
+	if (sysiso_current_is_server()) {
+		BUG_ON(!sysiso_cpu_is_server(smp_processor_id()));
+
+		wq_entry->sysiso_task = sysisod_current;
+	}
+	else
+		wq_entry->sysiso_task = NULL;
+}
+
+void sysiso__wake_up_common(struct wait_queue_entry *wq_entry)
+{
+	struct sysiso_task *task;
+
+	/*
+	 *  Deferred work always thinks it's waking up the sysisod kthread
+	 */
+
+	task = wq_entry->sysiso_task;
+
+	if (!task)
+		return;
+
+	BUG_ON(!task->client);
+	BUG_ON(!task->client->comm);
+
+	sysiso_debug_task(task, "-> RUNNABLE");
+
+	task->needs_wakeup = true;
+	sysiso_task_set_state(task, SYSISO_TASK_RUNNABLE);
+}
+
+void sysiso_prepare_wait(struct wait_queue_entry *wq_entry)
+{
+	if (!sysiso_current_is_server())
+		return;
+
+	BUG_ON(!sysiso_cpu_is_server(smp_processor_id()));
+	BUG_ON(!wq_entry);
+
+	sysiso_debug_task(sysisod_current, "-> WAIT (from wait_queue)");
+
+	/*
+	 * Waitqueues are triggered by events, that happen outside of the
+	 * current task! This might involve events triggered by other user space
+	 * tasks. We cannot continue until the event has happened, so continue
+	 * with other tasks. E.g. a user space program writing to /proc
+	 */
+	sysiso_task_set_deferred_work(sysisod_current);
+	sysiso_task_clear_state_flag(sysisod_current, SYSISO_TASK_RUNNABLE);
+	WRITE_ONCE(wq_entry->sysiso_task, sysisod_current);
+}
+
+/* Timers */
+
+struct hrtimer_sleeper *sysiso_get_hrtimer_sleeper(struct task_struct *client)
+{
+	struct hrtimer_sleeper *t = &client->sysiso_task->hrtimer_sleeper;
+
+	/* already done by __hrtimer_init */
+	/* memset(t, 0, sizeof(struct hrtimer_sleeper)); */
+	return t;
+}
+
+void sysiso___hrtimer_init()
+{
+	if (!sysiso_current_is_server())
+		return;
+
+	sysiso_task_set_state_local(sysiso_current->sysiso_task, SYSISO_TASK_TIMER);
+}
+
+void sysiso_hrtimer_wakeup(struct task_struct *client)
+{
+	struct sysiso_task *task = client->sysiso_task;
+
+	if (!sysiso_current_is_server())
+		return;
+
+	BUG_ON(!sysiso_task_test_flag_local(task, SYSISO_TASK_TIMER));
+
+	/* At this point the timer is finished */
+
+	sysiso_debug_task(task, "TIMER -> RUNNABLE");
+
+	sysiso_task_set_state_flag_local(task, SYSISO_TASK_RUNNABLE);
+}
diff --git a/security/sysiso/proc.c b/security/sysiso/proc.c
new file mode 100644
index 000000000..ce3f5d6ca
--- /dev/null
+++ b/security/sysiso/proc.c
@@ -0,0 +1,185 @@
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+
+#include <linux/sysiso.h>
+
+#include "internal.h"
+#include "debug.h"
+
+enum sysiso_proc_config_simple {
+	SYSISO_PROC_ENABLE_GLOBALLY,
+};
+
+static int nservers_show(struct seq_file *m, void *v) {
+
+	uintptr_t cpu = (long) m->private;
+
+	seq_printf(m, "I'm responsible for CPU %ld\n", cpu);
+	return 0;
+}
+
+static int nservers_open(struct inode *inode, struct file *file) {
+
+	return single_open(file, nservers_show, PDE_DATA(inode));
+}
+
+static ssize_t nservers_write(struct file *file, const char __user *buf,
+			      size_t count, loff_t *pos)
+{
+	char *end;
+	char kbuf[5];		/* this fails for >= 10k CPUs */
+	uintptr_t cpu, nservers;
+
+	cpu = (uintptr_t) PDE_DATA(file_inode(file));
+
+	if (copy_from_user(kbuf, buf, min(count, sizeof(kbuf))))
+		return -EFAULT;
+
+	nservers = simple_strtol(kbuf, &end, 10);
+
+	if ((*end != '\0') && !isspace(*end))
+		return -EINVAL;
+	return count;
+}
+
+static const struct proc_ops nservers_ops = {
+	.proc_open		= nservers_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+	.proc_write		= nservers_write,
+};
+
+static int simple_config_show(struct seq_file *m, void *v) {
+
+	bool *global_var = m->private;
+
+	seq_printf(m, "%d\n", *global_var);
+	return 0;
+}
+
+static ssize_t simple_config_write(struct file *file, const char __user *buf,
+				   size_t count, loff_t *pos)
+{
+	char *end;
+	char kbuf[2];
+	int val;
+	uintptr_t global_var = (uintptr_t) PDE_DATA(file_inode(file));
+
+	if (copy_from_user(kbuf, buf, sizeof(kbuf)))
+		return -EFAULT;
+
+	val = simple_strtol(kbuf, &end, 10);
+
+	if ((*end != '\0') && !isspace(*end))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	switch (global_var) {
+	case SYSISO_PROC_ENABLE_GLOBALLY:
+		sysiso_enabled_globally = (bool) val;
+		sysiso_debug("SYSISO: sysiso_enabled_globally: %d\n", sysiso_enabled_globally);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static int simple_config_open(struct inode *inode, struct file *file) {
+
+	return single_open(file, simple_config_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops simple_config_ops = {
+	.proc_open		= simple_config_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+	.proc_write		= simple_config_write,
+};
+
+/* simple core */
+
+static ssize_t core_config_write(struct file *file, const char __user *buf,
+				   size_t count, loff_t *pos)
+{
+	char *end;
+	char kbuf[2];
+	int val;
+	int core = (uintptr_t) PDE_DATA(file_inode(file));
+
+	if (copy_from_user(kbuf, buf, sizeof(kbuf)))
+		return -EFAULT;
+
+	val = simple_strtol(kbuf, &end, 10);
+
+	if ((*end != '\0') && !isspace(*end))
+		return -EINVAL;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	pr_notice("SYSISO enabling on CPUs %d : [%*pbl]\n", val, cpumask_pr_args(cpu_cores[core]));
+	if (val)
+		cpumask_or(sysiso_server_cores, sysiso_server_cores, cpu_cores[core]);
+	else
+		cpumask_andnot(sysiso_server_cores, sysiso_server_cores, cpu_cores[core]);
+
+	return count;
+}
+
+static int core_config_show(struct seq_file *m, void *v) {
+
+	int core = *(int *) m->private;
+
+	seq_printf(m, "%d\n", cpumask_intersects(sysiso_server_cores, cpu_cores[core]));
+	return 0;
+}
+
+static int core_config_open(struct inode *inode, struct file *file) {
+
+	return single_open(file, core_config_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops core_config_ops = {
+	.proc_open		= core_config_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release		= single_release,
+	.proc_write		= core_config_write,
+};
+
+/*  */
+
+int sysiso_proc_init(void) {
+	struct proc_dir_entry *dir;
+	char namestr[] = "coreXXX";
+	int i;
+
+	dir = proc_mkdir("sysiso", NULL);
+
+	if (!dir)
+		return -ENOMEM;
+
+	proc_create_data("enable_globally", 0660, dir, &simple_config_ops, SYSISO_PROC_ENABLE_GLOBALLY);
+
+	/* smp_64.c does it as ugly as we ... */
+
+	for (i = 0; i < MAX_CORES; i++) {
+
+		/* theoretically cores could be in any order */
+		if (cpumask_empty(cpu_cores[i]))
+			continue;
+
+		snprintf(namestr, sizeof(namestr), "core%d", i);
+		proc_create_data(namestr, 0660, dir, &core_config_ops, &i);
+	}
+
+	return 0;
+}
diff --git a/security/sysiso/syscall_client.c b/security/sysiso/syscall_client.c
new file mode 100644
index 000000000..00a97923d
--- /dev/null
+++ b/security/sysiso/syscall_client.c
@@ -0,0 +1,213 @@
+#include <linux/kernel.h>
+#include <linux/smp.h>
+#include <linux/slab.h>
+#include <linux/gfp.h>
+#include <linux/sched/mm.h>
+#include <linux/fdtable.h>
+#include <asm/syscall.h>
+
+#include <linux/vmalloc.h>
+
+#include <linux/sysiso.h>
+
+#include "internal.h"
+#include "debug.h"
+
+#ifdef SYSISO_SYSCALLS_UNSUPPORTED_LIST
+static __read_mostly DECLARE_BITMAP(sysiso_unsupported_syscalls, NR_syscalls);
+#else
+static __read_mostly DECLARE_BITMAP(sysiso_supported_syscalls, NR_syscalls);
+#endif
+
+static atomic_t task_id = ATOMIC_INIT(0);
+
+/* Common initialization for all sysiso task types */
+static void sysiso_prepare_task(void) {
+	struct sysiso_task *task = current->sysiso_task;
+	task->client = current;
+	task->rsp = task->stack_top;
+	task->needs_wakeup = false;
+
+	sysiso_task_set_state(task, SYSISO_TASK_NEW);
+	get_task_struct(task->client);
+}
+
+static struct sysiso_task *sysiso_prepare_syscall_task(unsigned long nr, struct pt_regs *regs)
+{
+	struct sysiso_task *task = current->sysiso_task;
+	struct sysiso_syscall *syscall = (struct sysiso_syscall *) &task->event;
+
+	syscall->regs = regs;
+	syscall->nr = nr;
+
+	task->type = SYSISO_SYSCALL;
+	atomic_inc(&task_id);
+	task->id_cnt = 0;
+	task->id  = atomic_read(&task_id);
+
+	sysiso_debug_task(task, "client created");
+
+	return task;
+}
+
+static void debug_print_sending_task(struct sysiso_task *task)
+{
+	if (IS_ENABLED(CONFIG_SYSISO_DEBUG)) {
+		if (task->type == SYSISO_SYSCALL) {
+			struct sysiso_syscall *syscall = (struct sysiso_syscall *) &task->event;
+			sysiso_debug("sending syscall %d from CPU %d\n", syscall->nr, smp_processor_id());
+		}
+	}
+}
+
+static void debug_print_sent_task(struct sysiso_task *task)
+{
+	if (IS_ENABLED(CONFIG_SYSISO_DEBUG)) {
+		if (task->type == SYSISO_SYSCALL) {
+			struct sysiso_syscall *syscall = (struct sysiso_syscall *) &task->event;
+			sysiso_debug("sent syscall %d from CPU %d\n", syscall->nr, smp_processor_id());
+		}
+	}
+}
+
+static void sysiso_client_send(void)
+{
+	struct sysiso_task *task = current->sysiso_task;
+	debug_print_sending_task(task);
+
+	sysiso_send_new_task(task);
+	debug_print_sent_task(task);
+}
+
+static void sysiso_client_wait(void)
+{
+	struct sysiso_task *task = current->sysiso_task;
+
+	while (!sysiso_task_is_done(task))
+		cpu_relax();
+
+	sysiso_debug_task(task, "client received result");
+}
+
+void sysiso_init_supported_syscalls_bitmap()
+{
+	int i;
+
+#ifdef SYSISO_SYSCALLS_UNSUPPORTED_LIST
+	/* UNSUPPORTED SYSCALLS  */
+	bitmap_clear(sysiso_unsupported_syscalls, 0, NR_syscalls);
+
+	for(i = 0; i < ARRAY_SIZE(sysiso_unsupported_syscalls_list); i++)
+		bitmap_set(sysiso_unsupported_syscalls, sysiso_unsupported_syscalls_list[i], 1);
+#else
+	/* SUPPORED SYSCALLS */
+	bitmap_clear(sysiso_supported_syscalls, 0, NR_syscalls);
+	/* wow, this GCC 10.2 does not warn if i is not initialized ? */
+	for(i = 0; i < ARRAY_SIZE(sysiso_supported_syscalls_list); i++)
+		bitmap_set(sysiso_supported_syscalls, sysiso_supported_syscalls_list[i], 1);
+#endif
+}
+
+bool sysiso_syscall_is_supported(unsigned long nr) {
+
+#ifdef SYSISO_SYSCALLS_UNSUPPORTED_LIST
+	return !test_bit(nr, sysiso_unsupported_syscalls);
+#else
+	return test_bit(nr, sysiso_supported_syscalls);
+#endif
+}
+
+static inline bool sysiso_should_send_syscall(unsigned long nr)
+{
+	if (!sysiso_syscall_is_supported(nr))
+		return false;
+
+	if (sysiso_enabled_globally)
+		return true;
+
+	if (test_thread_flag(TIF_SYSISO_CLIENT))
+		return true;
+
+	return false;
+}
+
+unsigned long sysiso_syscall_client(unsigned long nr, struct pt_regs *regs)
+{
+	struct sysiso_task *task = current->sysiso_task;
+
+	if (sysiso_should_send_syscall(nr)) {
+		set_tsk_thread_flag(current, TIF_SYSISO_CLIENT_WAITING);
+		sysiso_prepare_task();
+		sysiso_prepare_syscall_task(nr, regs);
+		sysiso_client_send();
+		sysiso_client_wait();
+		clear_tsk_thread_flag(current, TIF_SYSISO_CLIENT_WAITING);
+		return ((struct sysiso_syscall *) &task->event)->result;
+	}
+
+	/* Regular, non-sysiso execution */
+	return sys_call_table[nr](regs);
+}
+
+void sysiso_client_enable(struct task_struct *client)
+{
+	struct sysiso_task *task;
+	sysiso_debug("client: %s(%u) requested isolation\n",
+	       client->comm, client->pid);
+
+	if (!atomic_read(&sysiso_servers_running)) {
+		pr_warn("SYSISO client: Not enabled on any core. Starting servers on core 1 (cpus [%*pbl])\n",
+			cpumask_pr_args(cpu_cores[1]));
+
+		sysiso_start_servers_on_core(1);
+	}
+
+	task = kzalloc(sizeof(struct sysiso_task), GFP_KERNEL);
+	task->stack = vzalloc(2*PAGE_SIZE);
+	task->stack_top = (unsigned long) task->stack + (2 * PAGE_SIZE) - 1;
+
+	client->sysiso_task = task;
+
+	set_tsk_thread_flag(client, TIF_SYSISO_CLIENT);
+}
+
+void sysiso_client_disable(struct task_struct *client)
+{
+	if (!sysiso_task_is_client(client))
+		return;
+
+	vfree(client->sysiso_task->stack);
+	kfree(client->sysiso_task);
+}
+
+/*
+ * Return values must make sense to prctl():
+ *  ok -> 0
+ *  error -> -EINVAL
+ */
+int sysiso_client_enable_prctl(void)
+{
+	if (test_tsk_thread_flag(sysiso_current->real_parent, TIF_SYSISO_CLIENT))
+		return -EINVAL;
+
+	if (test_tsk_thread_flag(current, TIF_SYSISO_CLIENT)) {
+		pr_warn("SYSISO client: %s already using sysiso. Won't set it up once more.",
+			sysiso_current->comm);
+		return -EINVAL;
+	}
+
+	if (sysiso_enabled_globally) {
+		pr_warn("SYSISO client: already running globally. Won't set it of for %s.\n", sysiso_current->comm);
+		return -EINVAL;
+	}
+
+	sysiso_client_enable(current);
+
+	return 0;
+}
+
+int sysiso_client_disable_prctl(void)
+{
+	sysiso_client_disable(current);
+	return 0;
+}
diff --git a/security/sysiso/syscall_ctx.h b/security/sysiso/syscall_ctx.h
new file mode 100644
index 000000000..3bfe45cf0
--- /dev/null
+++ b/security/sysiso/syscall_ctx.h
@@ -0,0 +1,10 @@
+#include <asm/ptrace.h>
+
+struct sysiso_syscall_ctx {
+	unsigned long server_sp;
+	unsigned long task_sp;
+
+	int nr;
+	struct pt_regs *regs;
+	unsigned long result;
+};
diff --git a/security/sysiso/sysfs.c b/security/sysiso/sysfs.c
new file mode 100644
index 000000000..fbe6974e1
--- /dev/null
+++ b/security/sysiso/sysfs.c
@@ -0,0 +1,62 @@
+#include <linux/kobject.h>
+#include <linux/string.h>
+
+#include "internal.h"
+
+/* see samples/kobject-example.c */
+
+#define SYSISO_SHOW_FUNC(NAME, VAR)							\
+static ssize_t sysiso_##NAME##_show(struct kobject *kobj, struct kobj_attribute *attr,	\
+		      char *buf)							\
+{											\
+	return sprintf(buf, "%d\n", VAR);						\
+}
+
+#define SYSISO_STORE_FUNC(NAME, FUNC)							\
+static ssize_t sysiso_##NAME##_store(struct kobject *kobj, struct kobj_attribute *attr,	\
+		       const char *buf, size_t count)					\
+{											\
+	int ret, val;									\
+											\
+	ret = kstrtoint(buf, 10, &val);							\
+	if (ret < 0)									\
+		return ret;								\
+											\
+	FUNC(val);									\
+	return count;									\
+}
+
+#define SYSISO_ATTR(NAME, VAR, STORE_FUNC)			\
+	SYSISO_SHOW_FUNC(NAME, VAR)				\
+	SYSISO_STORE_FUNC(NAME, STORE_FUNC)			\
+								\
+	static struct kobj_attribute NAME##_attribute =		\
+		__ATTR(NAME, 0664, sysiso_##NAME##_show, sysiso_##NAME##_store);
+
+SYSISO_ATTR(servers, sysiso_servers_running, sysiso_adjust_servers)
+
+static struct attribute *sysiso_attrs[] = {
+
+	&servers_attribute.attr,
+	NULL	/* need to NULL terminate the list of attributes */
+};
+
+static struct attribute_group sysiso_attr_group = {
+	.attrs = sysiso_attrs,
+};
+
+int sysiso_init_sysfs()
+{
+	int ret;
+	struct kobject *sysiso_kobj = kobject_create_and_add("sysiso", kernel_kobj);
+
+	if (!sysiso_kobj)
+		return -ENOMEM;
+
+	ret = sysfs_create_group(sysiso_kobj, &sysiso_attr_group);
+	if (ret)
+		kobject_put(sysiso_kobj);
+
+	return ret;
+
+}
diff --git a/security/sysiso/sysisod.c b/security/sysiso/sysisod.c
new file mode 100644
index 000000000..14748b369
--- /dev/null
+++ b/security/sysiso/sysisod.c
@@ -0,0 +1,376 @@
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <asm/syscall.h>
+#include <linux/vmalloc.h>
+
+#include <linux/sched/task.h>
+#include <linux/sched/signal.h> /* for_each_process(). Yes, really */
+
+#include <linux/sysiso.h>
+
+#include "internal.h"
+#include "debug.h"
+
+DEFINE_PER_CPU(struct sysiso_server, sysiso_server);
+
+DEFINE_PER_CPU(struct sysiso_task *, sysisod_current_task) = NULL;
+
+atomic_t sysiso_servers_running = ATOMIC_INIT(0);
+
+/*
+ * called instead of schedule() when in client context
+ */
+void sysiso_schedule(void)
+{
+	sysiso_debug_task(sysisod_current, "schedule()");
+
+	sysisod_enqueue(sysisod_current);
+
+	kthread_unuse_mm(sysisod_current->client->mm);
+
+	/* context switch_to sysisod */
+	local_irq_disable();
+	sysisod_current->rsp = sysisod_switch_to_server_asm(
+		&sysisod_current->rsp, sysisod_current->sysisod_rsp);
+
+	/* sysiso task will continue here, when rescheduled by __sysisod_schedule */
+
+	kthread_use_mm(sysisod_current->client->mm);
+	this_cpu_write(current_sysiso_client, sysisod_current->client);
+
+	sysiso_debug_task(sysisod_current, "continued");
+
+	/* magically returns to where the task invoked schedule() */
+}
+
+void sysisod_exec_current_syscall(void)
+{
+	struct sysiso_syscall *syscall = (struct sysiso_syscall *) &sysisod_current->event;
+
+	sysiso_debug("starting syscall # %d "
+		     "(%ld, %ld, %ld, %ld, %ld, %ld) "
+		     "for %s(%d)"
+		     "on CPU %d\n",
+		     syscall->nr,
+		     syscall->regs->di,
+		     syscall->regs->si,
+		     syscall->regs->dx,
+		     syscall->regs->r10,
+		     syscall->regs->r8,
+		     syscall->regs->r9,
+		     sysisod_current->client->comm,
+		     sysisod_current->client->pid,
+		     smp_processor_id());
+
+	syscall->result = sys_call_table[syscall->nr](syscall->regs);
+}
+
+void sysisod_exec_current_task(void)
+{
+	struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+
+	local_irq_enable();
+	BUG_ON(!sysisod_current);
+
+	BUG_ON(sysisod_current->client == current);
+	BUG_ON(sysisod_current->client == server->linux_task);
+
+	kthread_use_mm(sysisod_current->client->mm);
+	this_cpu_write(current_sysiso_client, sysisod_current->client);
+
+	switch (sysisod_current->type) {
+	case SYSISO_SYSCALL:
+		sysisod_exec_current_syscall();
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	/* once we are here, the task has finished */
+
+	kthread_unuse_mm(sysisod_current->client->mm);
+
+	if (IS_ENABLED(CONFIG_SYSISO_DEBUG) &&
+	    sysisod_current->stack_top - (unsigned long) sysisod_current->stack != 2 * PAGE_SIZE -1) {
+			pr_err("sysisod_current->stack_top: %#08lx, stack: %px\n",
+			       sysisod_current->stack_top,
+			       sysisod_current->stack
+				);
+			BUG();
+		}
+
+	sysiso_debug_task(sysisod_current, "finished");
+
+	BUG_ON(sysiso_task_has_deferred_work(sysisod_current));
+
+	sysiso_task_set_state(sysisod_current, SYSISO_TASK_DONE);
+
+	server->syscalls_processed++;
+
+	BUG_ON(!sysisod_current);
+	BUG_ON(!sysisod_current->client);
+
+	if (sysisod_current->needs_wakeup) {
+		sysiso_debug_task(sysisod_current, "waking up");
+		wake_up_process(sysisod_current->client);
+		sysisod_current->needs_wakeup = false;
+	}
+
+	put_task_struct(sysisod_current->client);
+
+	local_irq_disable();
+}
+
+static struct sysiso_task *sysisod_pick_task(void)
+{
+	static struct sysiso_task *last = NULL;
+
+	struct sysiso_task *task = sysisod_dequeue();
+
+	if (task && last == task) {
+		sysisod_enqueue(task);
+		last = NULL;
+		return NULL;
+	}
+
+	last = task;
+	return task;
+}
+
+static void sysisod_print_status(void)
+{
+	static int count = 0;
+	count++;
+
+	if (count == 1000) {
+		struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+		count = 0;
+		printk("sysisod on %d: %ld syscalls, queue_len: %d\n",
+		       server->cpu,
+		       server->syscalls_processed,
+		       server->queue_len
+			);
+		BUG_ON(server->queue_len > 20);
+	}
+}
+
+/*
+ * The core scheduler function of sysisod
+ */
+static void __sysisod_schedule(void)
+{
+	struct sysiso_task *task;
+
+	while ((task = sysisod_pick_task())) {
+		this_cpu_write(sysisod_current_task, task);
+
+		/*
+		 * NOTE: if a state is already SCHEDULED, we don't need to smp_load_acquire it.
+		 * If it is new however, it's saver to do so, as this was set on the client's cpu.
+		 */
+		if (sysiso_task_is_first_run(task)) {
+
+			/* clear SYSISO_TASK_FIRST_RUN */
+			sysiso_task_set_state(task, SYSISO_TASK_RUNNABLE);
+
+			local_irq_disable();
+			sysisod_exec_task_asm(task->rsp, &task->sysisod_rsp);
+			local_irq_enable();
+
+		} else if (sysiso_task_is_waiting(task)){
+			/*
+			 * The task has deferred work, so we call the
+			 * scheduler, to run worker_thread() and friends
+			 * schedule_linux();
+			 */
+			sysisod_enqueue(task);
+
+		} else if (sysiso_task_is_runnable(task)) {
+			/* sp->client already set */
+			local_irq_disable();
+			sysisod_switch_to_task_asm(task->rsp, &task->sysisod_rsp);
+
+		} else {
+			pr_err("tried to schedule non new/runnable task! sysiso_state: %d\n", task->state);
+			BUG();
+		}
+
+		/* When a task invoked schedule() or finished, sysisod continues
+		 * here */
+	}
+}
+
+static void sysisod_idle(void)
+{
+	schedule_linux();
+}
+
+static int sysisod(void *arg)
+{
+	struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+
+	sysiso_debug("started sysisod on CPU %d\n", smp_processor_id());
+	BUG_ON(server->cpu != smp_processor_id());
+
+	/*
+	 * NOTE We cannot wake up servers, as long as this flag is set, see
+	 * code/comments in sysiso_try_to_wake_up()
+	 */
+	set_tsk_thread_flag(server->linux_task, TIF_SYSISO_SERVER);
+
+	/* NOTE always test with CONFIG_RCU_EQS_DEBUG=y. */
+	smp_store_release(&server->running, true);
+
+	while (1) {
+		struct sysiso_task *task = NULL;
+
+		cpu_relax();
+
+		if (unlikely(kthread_should_stop())) {
+			if (!server->queue_len) {
+				smp_store_release(&server->running, false);
+				return 0;
+			}
+		} else {
+			task = sysisod_recv_new_task();
+		}
+
+		if (task) {
+			sysisod_enqueue(task);
+			__sysisod_schedule();
+		} else if (!sysisod_local_queue_empty()) {
+			__sysisod_schedule();
+		}
+		sysisod_idle();
+	}
+}
+
+/*
+ * Note core == physical core, not logical cpu
+ *
+ * Should not be used in sysisod, might call schedule()
+ */
+void sysiso_start_servers_on_core(int core_index)
+{
+	int cpu;
+
+	BUG_ON(cpumask_empty(cpu_cores[core_index]));
+
+	sysiso_debug("Initializing servers on core %d (cpus [%*pbl])",
+		 core_index, cpumask_pr_args(cpu_cores[core_index]));
+
+	/* Start a server on each CPU on the given core, first just wake them ...*/
+	for_each_cpu(cpu, cpu_cores[core_index]) {
+		char server_string[TASK_COMM_LEN];
+		struct sysiso_server *server = per_cpu_ptr(&sysiso_server, cpu);
+		struct task_struct *p;
+
+		snprintf(server_string, sizeof("sysisod_on_XXX"), "sysisod_on_%d", cpu);
+		server->cpu = cpu;
+		server->syscalls_processed = 0;
+		server->queue_len = 0;
+
+		INIT_LIST_HEAD(&server->local_queue);
+		server->linux_task = kthread_create_on_cpu(sysisod, server, cpu, server_string);
+
+		/* just to be explicit, it's zero anyways */
+		/* server->running = false; */
+
+		if (IS_ERR(server->linux_task)) {
+			pr_err("SYSISO: failed to create sysiso server on cpu %d!\n", cpu);
+			continue;
+		}
+
+		/* Make sure no user processes get scheduled on server cpus */
+		for_each_process(p) {
+			if (!(p->flags & PF_KTHREAD))
+				cpumask_clear_cpu(cpu, &p->cpus_mask);
+		}
+
+		wake_up_process(server->linux_task);
+
+		/*
+		 * wait until the server is up and running
+		 *
+		 * this is necessary for two reasons:
+		 *
+		 * 1. to guarantee, that clients can only use servers once the
+		 * core is fully isolated.
+		 *
+		 * 2. to avoid deadlocks (triggered by the queue lock?) in
+		 * situations where a server is already running on one logical
+		 * cpu of core X, while the client gets scheduled on another
+		 * logical cpu of core X.
+		 */
+
+		/* Not the nicest way, but good enough, this runs on the clients */
+		while (!smp_load_acquire(&server->running))
+			schedule_linux();
+
+		cpumask_set_cpu(cpu, sysiso_server_cores);
+		atomic_inc(&sysiso_servers_running);
+	}
+}
+
+void sysiso_stop_servers_on_core(int core_index)
+{
+	int cpu;
+
+	for_each_cpu(cpu, cpu_cores[core_index]) {
+		struct task_struct *p = per_cpu_ptr(&sysiso_server, cpu)->linux_task;
+		cpumask_clear_cpu(cpu, sysiso_server_cores);
+
+		kthread_stop(p);
+		atomic_dec(&sysiso_servers_running);
+
+		for_each_process(p) {
+			if (!(p->flags & PF_KTHREAD))
+				cpumask_set_cpu(cpu, &p->cpus_mask);
+		}
+	}
+}
+
+void sysiso_adjust_servers(int n)
+{
+	int next_cpu, next_core;
+
+	/* next_cpu is the first CPU that is not a sysiso server, i.e., the first
+	 * cpu of a non-sysiso core, hence
+	 * the next_cpu 'free' core = next_cpu / sysiso_cpus_per_core */
+
+	while(atomic_read(&sysiso_servers_running) < n) {
+
+		next_cpu = cpumask_next_zero(1, sysiso_server_cores);
+		next_core = next_cpu / sysiso_cpus_per_core;
+
+		if (cpumask_last(cpu_possible_mask) + 1 - sysiso_cpus_per_core == next_cpu) {
+			pr_warn("You need at least one user core!\n");
+			return;
+		}
+
+		sysiso_start_servers_on_core(next_core);
+	}
+
+	while(atomic_read(&sysiso_servers_running) > n) {
+
+		next_cpu = cpumask_last(sysiso_server_cores);
+		next_core = (next_cpu + 1 - sysiso_cpus_per_core) / sysiso_cpus_per_core;
+
+		/* Nothing to warn */
+
+		sysiso_debug("Stopping servers on core %d\n", next_core);
+
+		sysiso_stop_servers_on_core(next_core);
+	}
+}
+
+bool sysiso_cpumask_is_server(const struct cpumask *mask)
+{
+	return cpumask_intersects(mask, sysiso_server_cores);
+}
+
+bool sysiso_cpu_is_server(int cpu)
+{
+	return sysiso_cpumask_is_server(cpumask_of(cpu));
+}
diff --git a/security/sysiso/sysisod_asm.S b/security/sysiso/sysisod_asm.S
new file mode 100644
index 000000000..fdcaf2f05
--- /dev/null
+++ b/security/sysiso/sysisod_asm.S
@@ -0,0 +1,93 @@
+#include <linux/linkage.h>
+#include <asm/percpu.h>
+#include <asm/asm-offsets.h>
+
+.code64
+.text
+
+SYM_FUNC_START(sysisod_exec_task_asm)
+
+	/* store the servers state */
+ 	pushq	%rbp
+	pushq	%rbx
+	pushq	%r12
+	pushq	%r13
+	pushq	%r14
+	pushq	%r15
+
+	/* rdi client rsp */
+	/* rsi sysisod rsp */
+	movq	%rsp, (%rsi)	/* save rsp to task->rsp */
+	movq	%rsp, %rsi	/* save rsp before switching the stack */
+	movq	%rdi, %rsp	/* set task rsp */
+	push	%rsi		/* and push the server's stack on the client's */
+
+	call	sysisod_exec_current_task
+
+	/* The task has finished, we don't need to store its stack */
+
+	popq	%rsi
+	movq	%rsi, %rsp 	/* restore the server's stack */
+
+	popq	%r15
+	popq	%r14
+	popq	%r13
+	popq	%r12
+	popq	%rbx
+	popq	%rbp
+
+	ret
+
+SYM_FUNC_END(sysisod_exec_task_asm)
+
+SYM_FUNC_START(sysisod_switch_to_task_asm)
+
+ 	pushq	%rbp
+	pushq	%rbx
+	pushq	%r12
+	pushq	%r13
+	pushq	%r14
+	pushq	%r15
+
+	/* rdi client rsp */
+	/* rsi sysisod rsp */
+	movq 	%rsp, (%rsi)	/* save the server's stack */
+	movq	%rdi, %rsp	/* switch to the client's stack */
+
+	popq	%r15
+	popq	%r14
+	popq	%r13
+	popq	%r12
+	popq	%rbx
+	popq	%rbp
+
+	sti
+
+	ret
+
+SYM_FUNC_END(sysisod_switch_to_task_asm)
+
+SYM_FUNC_START(sysisod_switch_to_server_asm)
+
+ 	pushq	%rbp
+	pushq	%rbx
+	pushq	%r12
+	pushq	%r13
+	pushq	%r14
+	pushq	%r15
+
+	/* rdi client rsp */
+	/* rsi sysisod rsp */
+	movq 	%rsp, (%rdi)	/* save the client's stack */
+	movq	%rsi, %rsp	/* switch to the server's stack */
+
+	popq	%r15
+	popq	%r14
+	popq	%r13
+	popq	%r12
+	popq	%rbx
+	popq	%rbp
+
+	ret
+
+SYM_FUNC_END(sysisod_switch_to_server_asm)
diff --git a/security/sysiso/task_queue.c b/security/sysiso/task_queue.c
new file mode 100644
index 000000000..723b3def8
--- /dev/null
+++ b/security/sysiso/task_queue.c
@@ -0,0 +1,137 @@
+#include <linux/slab.h>
+#include <linux/gfp.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+
+#include <linux/sysiso.h>
+
+#include "internal.h"
+#include "debug.h"
+
+static LIST_HEAD(sysiso_global_queue);
+
+static DEFINE_SPINLOCK(sysiso_global_queue_lock);
+
+void sysiso_init_queue()
+{
+
+}
+
+void sysiso_destroy_queue()
+{
+	BUG_ON(!list_empty(&sysiso_global_queue));
+}
+
+/*
+ * Global queue
+ */
+struct sysiso_task *sysisod_recv_new_task(void)
+{
+	struct sysiso_task *task = NULL;
+
+	spin_lock(&sysiso_global_queue_lock);
+	smp_mb();
+
+	task = list_first_entry_or_null(&sysiso_global_queue, struct sysiso_task, node);
+
+	smp_mb();
+
+	if (task)
+		list_del(&task->node);
+
+	spin_unlock(&sysiso_global_queue_lock);
+
+	if (task) {
+		/* sysiso_debug_task(task, "received"); */
+		sysiso_task_set_state(task, SYSISO_TASK_NEW);
+	}
+
+	return task;
+}
+
+void sysiso_send_new_task(struct sysiso_task *task)
+{
+	spin_lock(&sysiso_global_queue_lock);
+	smp_mb();
+	list_add_tail(&task->node, &sysiso_global_queue);
+	smp_mb();
+	spin_unlock(&sysiso_global_queue_lock);
+}
+
+static void debug_print_queue(struct list_head *queue)
+{
+	struct list_head *pos;
+
+	sysiso_debug("queue:\n");
+
+	list_for_each(pos, queue) {
+		struct sysiso_task *task;
+
+		task = list_entry(pos, struct sysiso_task, node);
+		sysiso_debug("  %s(%d)\n",
+		     task->client->comm,
+		     task->client->pid);
+	}
+}
+
+static void debug_print_local_queue(void)
+{
+	struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+	struct list_head *queue = &server->local_queue;
+	debug_print_queue(queue);
+}
+
+/*
+ * Local queue
+ */
+struct sysiso_task *sysisod_dequeue()
+{
+	struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+	struct list_head *queue = &server->local_queue;
+	struct sysiso_task *task = NULL;
+	struct sysiso_task *first = NULL;
+
+	first = list_first_entry_or_null(queue, struct sysiso_task, node);
+
+	/* queue is empty */
+	if (!first)
+		goto out;
+
+	task = first;
+
+	/* We don't want to wake sleeping tasks */
+	while (!sysiso_task_is_runnable(task)) {
+		/* We poll, most syscalls are done really quickly...  */
+		cpu_relax();
+		list_move_tail(&task->node, queue);
+		task = list_first_entry_or_null(queue, struct sysiso_task, node);
+
+		/* We went through the entire list */
+		if (task == first)
+			task = NULL;
+		if (!task)
+			goto out;
+	}
+
+	BUG_ON(!task);
+	BUG_ON(!(&task->node));
+	BUG_ON(!task->state);
+
+	server->queue_len--;
+	list_del(&task->node);
+out:
+	return task;
+}
+
+void sysisod_enqueue(struct sysiso_task *task)
+{
+	struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+	struct list_head *queue = &server->local_queue;
+	server->queue_len++;
+	list_add_tail(&task->node, queue);
+}
+
+bool sysisod_local_queue_empty(void) {
+	struct sysiso_server *server = this_cpu_ptr(&sysiso_server);
+	return list_empty(&server->local_queue);
+}
diff --git a/security/sysiso/tests/Makefile b/security/sysiso/tests/Makefile
new file mode 100644
index 000000000..eb3817587
--- /dev/null
+++ b/security/sysiso/tests/Makefile
@@ -0,0 +1,3 @@
+ccflags-$(CONFIG_SYSISO_DEBUG)    += -DDEBUG
+
+obj-y += syscall.o simple_schedule.o sleeping_schedule.o workqueue.o waitqueue.o timers.o
diff --git a/security/sysiso/tests/internal.h b/security/sysiso/tests/internal.h
new file mode 100644
index 000000000..9c613ef31
--- /dev/null
+++ b/security/sysiso/tests/internal.h
@@ -0,0 +1,6 @@
+#include "sysiso_test.h"
+
+void sysiso_test_simple_schedule(void);
+void sysiso_test_workqueue(void);
+void sysiso_test_waitqueue(void);
+void sysiso_test_hr_timer(void);
diff --git a/security/sysiso/tests/simple_schedule.c b/security/sysiso/tests/simple_schedule.c
new file mode 100644
index 000000000..79ed53799
--- /dev/null
+++ b/security/sysiso/tests/simple_schedule.c
@@ -0,0 +1,10 @@
+#include "../internal.h"
+#include "../debug.h"
+
+void sysiso_test_simple_schedule(void)
+{
+	sysiso_debug("Testing simple schedule() on CPU %d\n",
+		     smp_processor_id());
+	schedule();
+	sysiso_debug("OK");
+}
diff --git a/security/sysiso/tests/sleeping_schedule.c b/security/sysiso/tests/sleeping_schedule.c
new file mode 100644
index 000000000..2ce6e98ee
--- /dev/null
+++ b/security/sysiso/tests/sleeping_schedule.c
@@ -0,0 +1,13 @@
+#include "../internal.h"
+#include "../debug.h"
+
+void sysiso_test_sleeping_schedule(void)
+{
+	sysiso_debug("Testing sleeping schedule() on CPU %d\n",
+		     smp_processor_id());
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule();
+	set_current_state(TASK_RUNNING);
+	sysiso_debug("OK");
+}
diff --git a/security/sysiso/tests/syscall.c b/security/sysiso/tests/syscall.c
new file mode 100644
index 000000000..b8a09ad3c
--- /dev/null
+++ b/security/sysiso/tests/syscall.c
@@ -0,0 +1,33 @@
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+
+#include <linux/sysiso.h>
+
+#include "../internal.h"
+#include "../debug.h"
+
+#include "internal.h"
+
+SYSCALL_DEFINE1(sysiso_test, int, type)
+{
+	sysiso_debug("sysiso_test(%d) on CPU %d\n", type, smp_processor_id());
+
+	switch (type) {
+	case SYSISO_TEST_SIMPLE_SCHEDULE:
+		sysiso_test_simple_schedule();
+		break;
+	case SYSISO_TEST_WORKQUEUE:
+		sysiso_test_workqueue();
+		break;
+	case SYSISO_TEST_WAITQUEUE:
+		sysiso_test_waitqueue();
+		break;
+	case SYSISO_TEST_TIMRES:
+		sysiso_test_hr_timer();
+		break;
+	default:
+		break;
+	}
+
+	return 0L;
+}
diff --git a/security/sysiso/tests/sysiso_test.h b/security/sysiso/tests/sysiso_test.h
new file mode 100644
index 000000000..0a1e5e6db
--- /dev/null
+++ b/security/sysiso/tests/sysiso_test.h
@@ -0,0 +1,10 @@
+enum sysiso_test_type {
+	SYSISO_TEST_SIMPLE_SCHEDULE,
+	SYSISO_TEST_SLEEPING_SCHEDULE,
+	SYSISO_TEST_WORKQUEUE,
+	SYSISO_TEST_WAITQUEUE,
+	SYSISO_TEST_TIMRES,
+	SYSISO_TEST_VANILLA,
+	SYSISO_TEST_NR, 	/* Number of tests */
+	SYSISO_TEST_ALL,
+};
diff --git a/security/sysiso/tests/timers.c b/security/sysiso/tests/timers.c
new file mode 100644
index 000000000..b210570d0
--- /dev/null
+++ b/security/sysiso/tests/timers.c
@@ -0,0 +1,19 @@
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include "../internal.h"
+#include "../debug.h"
+
+void sysiso_test_hr_timer(void)
+{
+	int i, j, ret;
+	ktime_t expire;
+	ktime_t delta;
+
+	expire = ktime_set(2, 0);
+	delta = ktime_set(1, 0);
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	ret = schedule_hrtimeout_range(&expire, delta, HRTIMER_MODE_REL);
+	__set_current_state(TASK_RUNNING);
+}
diff --git a/security/sysiso/tests/waitqueue.c b/security/sysiso/tests/waitqueue.c
new file mode 100644
index 000000000..f9f6ec6cd
--- /dev/null
+++ b/security/sysiso/tests/waitqueue.c
@@ -0,0 +1,23 @@
+#include <linux/wait.h>
+
+#include "../internal.h"
+#include "../debug.h"
+
+DECLARE_WAIT_QUEUE_HEAD(wq);
+
+static bool wake = false;
+
+void sysiso_wakep_test_waitqueue()
+{
+	sysiso_debug("waking up\n");
+	wake = true;
+	wake_up_interruptible(&wq);
+}
+
+void sysiso_test_waitqueue(void)
+{
+	sysiso_debug("Testing waitqueue scheduling on CPU %d\n",
+		     smp_processor_id());
+
+	wait_event_interruptible(wq, wake);
+}
diff --git a/security/sysiso/tests/workqueue.c b/security/sysiso/tests/workqueue.c
new file mode 100644
index 000000000..b6e8d596c
--- /dev/null
+++ b/security/sysiso/tests/workqueue.c
@@ -0,0 +1,49 @@
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include "../debug.h"
+
+void workqueue_fn(struct work_struct *work);
+DECLARE_WORK(workqueue,workqueue_fn);
+
+struct wakeup {
+	struct work_struct work;
+	struct task_struct *task;
+};
+
+void workqueue_fn(struct work_struct *work)
+{
+	struct task_struct *task;
+
+	task = container_of(work, struct wakeup, work)->task;
+
+        sysiso_debug("Waking up %s from CPU %d in 2 sec\n", task->comm, smp_processor_id());
+	mdelay(2000);
+
+	sysiso_debug("task: %s\n", task->comm);
+	sysiso_debug("task->state: %d\n", task->__state);
+	sysiso_debug("current: %s\n", sysiso_current->comm);
+
+	wake_up_process(task);
+}
+
+void sysiso_test_workqueue(void)
+{
+	int c;
+	struct wakeup wakeup;
+
+	sysiso_debug("Testing workqueue scheduling on CPU %d\n",
+		     smp_processor_id());
+
+	INIT_WORK(&wakeup.work, workqueue_fn);
+	wakeup.task = current;
+
+        schedule_work(&wakeup.work);
+
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	schedule();
+
+	__set_current_state(TASK_RUNNING);
+}
diff --git a/security/sysiso/userspace/Makefile b/security/sysiso/userspace/Makefile
new file mode 100644
index 000000000..87360fb05
--- /dev/null
+++ b/security/sysiso/userspace/Makefile
@@ -0,0 +1,8 @@
+sysisoify_flags := -fPIC -shared -ldl
+
+$(obj)/sysisoify.so: $(obj)/include/sysiso_userspace.h  $(src)/sysisoify.c
+	$(CC) -I$(obj)/include -o $@ $? $(sysisoify_flags)
+
+always-y += sysisoify.so
+
+obj-y	+= syscalls/
diff --git a/security/sysiso/userspace/include/sysiso_userspace.h b/security/sysiso/userspace/include/sysiso_userspace.h
new file mode 100644
index 000000000..8acef3bb9
--- /dev/null
+++ b/security/sysiso/userspace/include/sysiso_userspace.h
@@ -0,0 +1,6 @@
+#define PR_SCHED_CORE			62
+
+#define PR_SET_SYSISO                  63
+#define PR_GET_SYSISO                  64
+
+#define __NR_sysiso_test  449
diff --git a/security/sysiso/userspace/syscalls/.gitignore b/security/sysiso/userspace/syscalls/.gitignore
new file mode 100644
index 000000000..6ea8f3903
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/.gitignore
@@ -0,0 +1,6 @@
+getpid
+getppid
+gettid
+sysiso_test
+read
+write
diff --git a/security/sysiso/userspace/syscalls/Makefile b/security/sysiso/userspace/syscalls/Makefile
new file mode 100644
index 000000000..9221fd984
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/Makefile
@@ -0,0 +1,10 @@
+userccflags += -I$(src)/../include
+
+userprogs-always-y	+= \
+	getpid  \
+	getppid \
+	gettid	\
+	read \
+	write \
+	wait4 \
+	getids
diff --git a/security/sysiso/userspace/syscalls/getids.c b/security/sysiso/userspace/syscalls/getids.c
new file mode 100644
index 000000000..4d5a099d3
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/getids.c
@@ -0,0 +1,32 @@
+#include <stdio.h>
+#include <sys/prctl.h>
+#include <unistd.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[]) {
+	int ret;
+
+	/*
+	  x = no. of dedicated cpus
+	  y = no. of sysiso servers
+	  z = no. of queue elements
+	*/
+	/* ret = prctl(PR_SET_SYSISO, x, y, z, 0, 0); */
+	printf("getppid vanilla: %d\n", getppid());
+	printf("getuid vanilla: %d\n", getuid());
+	printf("geteuid vanilla: %d\n", geteuid());
+	printf("getgid vanilla: %d\n", getgid());
+	printf("getegid vanilla: %d\n", getegid());
+
+	ret = prctl(PR_SET_SYSISO, 1, 5, 10, 0, 0);
+	printf("prctl(): %d\n", ret);
+
+	printf("getppid sysiso: %d\n", getppid());
+	printf("getuid sysiso: %d\n", getuid());
+	printf("geteuid sysiso: %d\n", geteuid());
+	printf("getgid sysiso: %d\n", getgid());
+	printf("getegid sysiso: %d\n", getegid());
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/getpid.c b/security/sysiso/userspace/syscalls/getpid.c
new file mode 100644
index 000000000..4de2ea6bc
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/getpid.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <sys/prctl.h>
+#include <unistd.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[]) {
+	int ret;
+
+	/*
+	  x = no. of dedicated cpus
+	  y = no. of sysiso servers
+	  z = no. of queue elements
+	*/
+	printf("getpid vanilla: %d\n", getpid());
+
+	ret = prctl(PR_SET_SYSISO, 1, 5, 10, 0, 0);
+	printf("prctl(): %d\n", ret);
+
+	printf("getpid sysiso: %d\n", getpid());
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/getppid.c b/security/sysiso/userspace/syscalls/getppid.c
new file mode 100644
index 000000000..88493ce56
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/getppid.c
@@ -0,0 +1,25 @@
+#include <stdio.h>
+#include <sys/prctl.h>
+
+#include <unistd.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[]) {
+	int ret;
+
+	/*
+	  x = no. of dedicated cpus
+	  y = no. of sysiso servers
+	  z = no. of queue elements
+	*/
+	/* ret = prctl(PR_SET_SYSISO, x, y, z, 0, 0); */
+	printf("getppid vanilla: %d\n", getppid());
+
+	ret = prctl(PR_SET_SYSISO, 1, 5, 10, 0, 0);
+	printf("prctl(): %d\n", ret);
+
+	printf("getppid sysiso: %d\n", getppid());
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/gettid.c b/security/sysiso/userspace/syscalls/gettid.c
new file mode 100644
index 000000000..292c11926
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/gettid.c
@@ -0,0 +1,26 @@
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <sys/prctl.h>
+
+#include <unistd.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[]) {
+	int ret;
+
+	/*
+	  x = no. of dedicated cpus
+	  y = no. of sysiso servers
+	  z = no. of queue elements
+	*/
+	printf("gettid vanilla: %d\n", gettid());
+
+	ret = prctl(PR_SET_SYSISO, 1, 5, 10, 0, 0);
+	printf("prctl(): %d\n", ret);
+
+	printf("gettid sysiso: %d\n", gettid());
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/read.c b/security/sysiso/userspace/syscalls/read.c
new file mode 100644
index 000000000..52afd2f0a
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/read.c
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <sys/prctl.h>
+#include <linux/limits.h>
+
+#include <libgen.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[])
+{
+	int ret;
+	char buf[100];
+	char *txt_path;
+
+	/*
+	  x = no. of dedicated cpus
+	  y = no. of sysiso servers
+	  z = no. of queue elements
+	*/
+	txt_path = malloc(PATH_MAX);
+	strncpy(txt_path, argv[0], PATH_MAX - 1);
+	txt_path = dirname(txt_path);
+	strncat(txt_path, "/txtfile", PATH_MAX - 1);
+
+	ret = prctl(PR_SET_SYSISO, 1, 1, 10, 0, 0);
+	printf("prctl(): %d\n", ret);
+
+	FILE *fp = fopen(txt_path, "r");
+	fgets(buf, 100, fp);
+	printf("file:\n\%s", buf);
+	fclose(fp);
+	free(txt_path);
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/read_nosysiso.c b/security/sysiso/userspace/syscalls/read_nosysiso.c
new file mode 100644
index 000000000..d945ecd04
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/read_nosysiso.c
@@ -0,0 +1,31 @@
+//#define _GNU_SOURCE
+
+#include <stdio.h>
+//#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <sys/prctl.h>
+#include <linux/limits.h>
+
+#include <libgen.h>
+
+int main(int argc, char *argv[]) {
+	int ret;
+	char buf[100];
+	int i;
+	char *txt_path;
+
+	txt_path = malloc(PATH_MAX);
+	strncpy(txt_path, argv[0], PATH_MAX - 1);
+	txt_path = dirname(txt_path);
+	strncat(txt_path, "/txtfile", PATH_MAX - 1);
+
+	FILE *fp = fopen(txt_path, "r");
+	fgets(buf, 100, fp);
+	printf("file:\n\%s", buf);
+	fclose(fp);
+	free(txt_path);
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/txtfile b/security/sysiso/userspace/syscalls/txtfile
new file mode 100644
index 000000000..881fd205d
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/txtfile
@@ -0,0 +1 @@
+TXTFILE
diff --git a/security/sysiso/userspace/syscalls/wait4.c b/security/sysiso/userspace/syscalls/wait4.c
new file mode 100644
index 000000000..61805c3cb
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/wait4.c
@@ -0,0 +1,24 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+#include <sys/prctl.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[])
+{
+	pid_t child;
+	prctl(PR_SET_SYSISO, 1, 5, 10, 0, 0);
+
+	child = fork();
+
+	if (!child) {
+		printf("child %d sleeping.\n", getpid());
+		sleep(3);
+	} else {
+		printf("parent %d waiting for child.\n", getpid());
+		wait4(child, NULL, 0 ,NULL);
+	}
+	return 0;
+}
diff --git a/security/sysiso/userspace/syscalls/write.c b/security/sysiso/userspace/syscalls/write.c
new file mode 100644
index 000000000..5eed614c1
--- /dev/null
+++ b/security/sysiso/userspace/syscalls/write.c
@@ -0,0 +1,40 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <sys/prctl.h>
+#include <linux/limits.h>
+
+#include <libgen.h>
+
+#include <sysiso_userspace.h>
+
+int main(int argc, char *argv[])
+{
+	int ret;
+	char buf[100];
+	char *txt_path;
+
+	/*
+	  x = no. of dedicated cpus
+	  y = no. of sysiso servers
+	  z = no. of queue elements
+	*/
+
+	txt_path = malloc(PATH_MAX);
+	strncpy(txt_path, argv[0], PATH_MAX - 1);
+	txt_path = dirname(txt_path);
+	strncat(txt_path, "/txtfile", PATH_MAX - 1);
+
+	ret = prctl(PR_SET_SYSISO, 1, 1, 10, 0, 0);
+	printf("prctl(): %d\n", ret);
+
+	FILE *fp = fopen(txt_path, "w");
+	fputs("WRITE\n", fp);
+	printf("file:\n\%s", buf);
+	fclose(fp);
+
+	free(txt_path);
+
+	return 0;
+}
diff --git a/security/sysiso/userspace/sysisoify.c b/security/sysiso/userspace/sysisoify.c
new file mode 100644
index 000000000..060de5fa6
--- /dev/null
+++ b/security/sysiso/userspace/sysisoify.c
@@ -0,0 +1,42 @@
+/* inspired by https://gist.github.com/apsun/1e144bf7639b22ff0097171fa0f8c6b1 */
+
+#define _GNU_SOURCE
+
+#include <sys/prctl.h>
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <sched.h>
+#include <unistd.h>
+
+#include <sysiso_userspace.h>
+
+/* Request the scheduler to share a core */
+#define PR_SCHED_CORE			62
+# define PR_SCHED_CORE_GET		0
+# define PR_SCHED_CORE_CREATE		1 /* create unique core_sched cookie */
+# define PR_SCHED_CORE_SHARE_TO		2 /* push core_sched cookie to pid */
+# define PR_SCHED_CORE_SHARE_FROM	3 /* pull core_sched cookie to pid */
+# define PR_SCHED_CORE_MAX		4
+# define PR_SCHED_CORE_SCOPE_THREAD		0
+# define PR_SCHED_CORE_SCOPE_THREAD_GROUP	1
+# define PR_SCHED_CORE_SCOPE_PROCESS_GROUP	2
+
+int __libc_start_main(
+    int (*main)(int, char **, char **),
+    int argc,
+    char **argv,
+    int (*init)(int, char **, char **),
+    void (*fini)(void),
+    void (*rtld_fini)(void),
+    void *stack_end)
+{
+
+    /* Find the real __libc_start_main()... */
+    typeof(&__libc_start_main) orig = dlsym(RTLD_NEXT, "__libc_start_main");
+
+    prctl(PR_SCHED_CORE, PR_SCHED_CORE_CREATE, getpid(), getpid(), 0, 0);
+    prctl(PR_SET_SYSISO, 0, 0, 0, 0, 0);
+
+    return orig(main, argc, argv, init, fini, rtld_fini, stack_end);
+}
diff --git a/security/tomoyo/audit.c b/security/tomoyo/audit.c
index d79bf07e1..4b3f2aa0f 100644
--- a/security/tomoyo/audit.c
+++ b/security/tomoyo/audit.c
@@ -150,7 +150,7 @@ static inline const char *tomoyo_filetype(const umode_t mode)
 static char *tomoyo_print_header(struct tomoyo_request_info *r)
 {
 	struct tomoyo_time stamp;
-	const pid_t gpid = task_pid_nr(current);
+	const pid_t gpid = task_pid_nr(sysiso_current);
 	struct tomoyo_obj_info *obj = r->obj;
 	static const int tomoyo_buffer_len = 4096;
 	char *buffer = kmalloc(tomoyo_buffer_len, GFP_NOFS);
diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
index 5c64927bf..538750608 100644
--- a/security/tomoyo/common.c
+++ b/security/tomoyo/common.c
@@ -938,7 +938,7 @@ static bool tomoyo_manager(void)
 {
 	struct tomoyo_manager *ptr;
 	const char *exe;
-	const struct task_struct *task = current;
+	const struct task_struct *task = sysiso_current;
 	const struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;
 	bool found = IS_ENABLED(CONFIG_SECURITY_TOMOYO_INSECURE_BUILTIN_SETTING);
 
@@ -962,7 +962,7 @@ static bool tomoyo_manager(void)
 	}
 	if (!found) { /* Reduce error messages. */
 		static pid_t last_pid;
-		const pid_t pid = current->pid;
+		const pid_t pid = sysiso_current->pid;
 
 		if (last_pid != pid) {
 			pr_warn("%s ( %s ) is not permitted to update policies.\n",
diff --git a/security/tomoyo/common.h b/security/tomoyo/common.h
index 85246b9df..b30a0d074 100644
--- a/security/tomoyo/common.h
+++ b/security/tomoyo/common.h
@@ -1136,7 +1136,7 @@ static inline pid_t tomoyo_sys_getppid(void)
 	pid_t pid;
 
 	rcu_read_lock();
-	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
+	pid = task_tgid_vnr(rcu_dereference(sysiso_current->real_parent));
 	rcu_read_unlock();
 	return pid;
 }
diff --git a/security/tomoyo/memory.c b/security/tomoyo/memory.c
index 1b570bde7..6b4363aa4 100644
--- a/security/tomoyo/memory.c
+++ b/security/tomoyo/memory.c
@@ -18,7 +18,7 @@ void tomoyo_warn_oom(const char *function)
 {
 	/* Reduce error messages. */
 	static pid_t tomoyo_last_pid;
-	const pid_t pid = current->pid;
+	const pid_t pid = sysiso_current->pid;
 
 	if (tomoyo_last_pid != pid) {
 		pr_warn("ERROR: Out of memory at %s.\n", function);
diff --git a/security/tomoyo/network.c b/security/tomoyo/network.c
index 8dc61335f..dc7ffa7b0 100644
--- a/security/tomoyo/network.c
+++ b/security/tomoyo/network.c
@@ -613,7 +613,7 @@ static int tomoyo_check_unix_address(struct sockaddr *addr,
 static bool tomoyo_kernel_service(void)
 {
 	/* Nothing to do if I am a kernel service. */
-	return current->flags & PF_KTHREAD;
+	return sysiso_current->flags & PF_KTHREAD;
 }
 
 /**
diff --git a/security/tomoyo/realpath.c b/security/tomoyo/realpath.c
index df4798980..86fa6fcf7 100644
--- a/security/tomoyo/realpath.c
+++ b/security/tomoyo/realpath.c
@@ -165,7 +165,7 @@ static char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,
 		struct pid_namespace *proc_pidns = proc_pid_ns(sb);
 
 		if (*ep == '/' && pid && pid ==
-		    task_tgid_nr_ns(current, proc_pidns)) {
+		    task_tgid_nr_ns(sysiso_current, proc_pidns)) {
 			pos = ep - 5;
 			if (pos < buffer)
 				goto out;
diff --git a/security/tomoyo/tomoyo.c b/security/tomoyo/tomoyo.c
index b6a31901f..8493fae3c 100644
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@ -17,7 +17,7 @@ struct tomoyo_domain_info *tomoyo_domain(void)
 {
 	struct tomoyo_task *s = tomoyo_task(current);
 
-	if (s->old_domain_info && !current->in_execve) {
+	if (s->old_domain_info && !sysiso_current->in_execve) {
 		atomic_dec(&s->old_domain_info->users);
 		s->old_domain_info = NULL;
 	}
@@ -39,7 +39,7 @@ static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,
 	/* Restore old_domain_info saved by previous execve() request. */
 	struct tomoyo_task *s = tomoyo_task(current);
 
-	if (s->old_domain_info && !current->in_execve) {
+	if (s->old_domain_info && !sysiso_current->in_execve) {
 		atomic_dec(&s->domain_info->users);
 		s->domain_info = s->old_domain_info;
 		s->old_domain_info = NULL;
@@ -306,7 +306,7 @@ static int tomoyo_file_fcntl(struct file *file, unsigned int cmd,
 static int tomoyo_file_open(struct file *f)
 {
 	/* Don't check read permission here if called from execve(). */
-	if (current->in_execve)
+	if (sysiso_current->in_execve)
 		return 0;
 	return tomoyo_check_open_permission(tomoyo_domain(), &f->f_path,
 					    f->f_flags);
diff --git a/security/yama/yama_lsm.c b/security/yama/yama_lsm.c
index 06e226166..ffa484b3f 100644
--- a/security/yama/yama_lsm.c
+++ b/security/yama/yama_lsm.c
@@ -79,7 +79,7 @@ static void report_access(const char *access, struct task_struct *target,
 
 	assert_spin_locked(&target->alloc_lock); /* for target->comm */
 
-	if (current->flags & PF_KTHREAD) {
+	if (sysiso_current->flags & PF_KTHREAD) {
 		/* I don't think kthreads call task_work_run() before exiting.
 		 * Imagine angry ranting about procfs here.
 		 */
@@ -413,9 +413,9 @@ static int yama_ptrace_traceme(struct task_struct *parent)
 	}
 
 	if (rc) {
-		task_lock(current);
+		task_lock(sysiso_current);
 		report_access("traceme", current, parent);
-		task_unlock(current);
+		task_unlock(sysiso_current);
 	}
 
 	return rc;
diff --git a/sound/core/control.c b/sound/core/control.c
index a25c0d64d..258c07231 100644
--- a/sound/core/control.c
+++ b/sound/core/control.c
@@ -75,7 +75,7 @@ static int snd_ctl_open(struct inode *inode, struct file *file)
 	ctl->card = card;
 	for (i = 0; i < SND_CTL_SUBDEV_ITEMS; i++)
 		ctl->preferred_subdevice[i] = -1;
-	ctl->pid = get_pid(task_pid(current));
+	ctl->pid = get_pid(task_pid(sysiso_current));
 	file->private_data = ctl;
 	write_lock_irqsave(&card->ctl_files_rwlock, flags);
 	list_add_tail(&ctl->list, &card->ctl_files);
@@ -1864,7 +1864,7 @@ static ssize_t snd_ctl_read(struct file *file, char __user *buffer,
 			remove_wait_queue(&ctl->change_sleep, &wait);
 			if (ctl->card->shutdown)
 				return -ENODEV;
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -ERESTARTSYS;
 			spin_lock_irq(&ctl->read_lock);
 		}
@@ -2016,7 +2016,7 @@ int snd_ctl_get_preferred_subdevice(struct snd_card *card, int type)
 
 	read_lock_irqsave(&card->ctl_files_rwlock, flags);
 	list_for_each_entry(kctl, &card->ctl_files, list) {
-		if (kctl->pid == task_pid(current)) {
+		if (kctl->pid == task_pid(sysiso_current)) {
 			subdevice = kctl->preferred_subdevice[type];
 			if (subdevice != -1)
 				break;
diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index e95fa275c..84a693cec 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -120,7 +120,7 @@ static int snd_hwdep_open(struct inode *inode, struct file * file)
 			err = -ENODEV;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			break;
 		}
diff --git a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c
index 82a818734..c59c94cb9 100644
--- a/sound/core/oss/pcm_oss.c
+++ b/sound/core/oss/pcm_oss.c
@@ -1440,7 +1440,7 @@ static ssize_t snd_pcm_oss_write1(struct snd_pcm_substream *substream, const cha
 		mutex_unlock(&runtime->oss.params_lock);
 		if (tmp < 0)
 			break;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			tmp = -ERESTARTSYS;
 			break;
 		}
@@ -1535,7 +1535,7 @@ static ssize_t snd_pcm_oss_read1(struct snd_pcm_substream *substream, char __use
 		mutex_unlock(&runtime->oss.params_lock);
 		if (tmp < 0)
 			break;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			tmp = -ERESTARTSYS;
 			break;
 		}
@@ -1617,7 +1617,7 @@ static int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)
 			break;
 		}
 		res = schedule_timeout(10 * HZ);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			result = -ERESTARTSYS;
 			break;
 		}
@@ -2532,7 +2532,7 @@ static int snd_pcm_oss_open(struct inode *inode, struct file *file)
 			err = -ENODEV;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			break;
 		}
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 6fd367768..03e7e3c31 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -970,7 +970,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	substream->private_data = pcm->private_data;
 	substream->ref_count = 1;
 	substream->f_flags = file->f_flags;
-	substream->pid = get_pid(task_pid(current));
+	substream->pid = get_pid(task_pid(sysiso_current));
 	pstr->substream_opened++;
 	*rsubstream = substream;
 	return 0;
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index a144a3f68..9e9dcae18 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -1889,7 +1889,7 @@ static int wait_for_avail(struct snd_pcm_substream *substream,
 	}
 
 	for (;;) {
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			break;
 		}
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index d233cb3b4..983696dd0 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -2061,7 +2061,7 @@ static int snd_pcm_drain(struct snd_pcm_substream *substream,
 	for (;;) {
 		long tout;
 		struct snd_pcm_runtime *to_check;
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			result = -ERESTARTSYS;
 			break;
 		}
@@ -2785,7 +2785,7 @@ static int snd_pcm_open(struct file *file, struct snd_pcm *pcm, int stream)
 			err = -ENODEV;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			break;
 		}
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index 6f30231bd..c762067d9 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -232,7 +232,7 @@ int snd_rawmidi_drain_output(struct snd_rawmidi_substream *substream)
 	timeout = wait_event_interruptible_timeout(runtime->sleep,
 				(runtime->avail >= runtime->buffer_size),
 				10*HZ);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		err = -ERESTARTSYS;
 	if (runtime->avail < runtime->buffer_size && !timeout) {
 		rmidi_warn(substream->rmidi,
@@ -315,7 +315,7 @@ static int open_substream(struct snd_rawmidi *rmidi,
 		substream->active_sensing = 0;
 		if (mode & SNDRV_RAWMIDI_LFLG_APPEND)
 			substream->append = 1;
-		substream->pid = get_pid(task_pid(current));
+		substream->pid = get_pid(task_pid(sysiso_current));
 		rmidi->streams[substream->stream].substream_opened++;
 	}
 	substream->use_count++;
@@ -469,7 +469,7 @@ static int snd_rawmidi_open(struct inode *inode, struct file *file)
 			err = -ENODEV;
 			break;
 		}
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			break;
 		}
@@ -1211,7 +1211,7 @@ static ssize_t snd_rawmidi_read(struct file *file, char __user *buf, size_t coun
 			remove_wait_queue(&runtime->sleep, &wait);
 			if (rfile->rmidi->card->shutdown)
 				return -ENODEV;
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return result > 0 ? result : -ERESTARTSYS;
 			spin_lock_irq(&runtime->lock);
 			if (!runtime->avail) {
@@ -1542,7 +1542,7 @@ static ssize_t snd_rawmidi_write(struct file *file, const char __user *buf,
 			remove_wait_queue(&runtime->sleep, &wait);
 			if (rfile->rmidi->card->shutdown)
 				return -ENODEV;
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return result > 0 ? result : -ERESTARTSYS;
 			spin_lock_irq(&runtime->lock);
 			if (!runtime->avail && !timeout) {
@@ -1572,7 +1572,7 @@ static ssize_t snd_rawmidi_write(struct file *file, const char __user *buf,
 			spin_unlock_irq(&runtime->lock);
 			timeout = schedule_timeout(30 * HZ);
 			remove_wait_queue(&runtime->sleep, &wait);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return result > 0 ? result : -ERESTARTSYS;
 			if (runtime->avail == last_avail && !timeout)
 				return result > 0 ? result : -EIO;
diff --git a/sound/core/seq/oss/seq_oss_ioctl.c b/sound/core/seq/oss/seq_oss_ioctl.c
index ccf682689..5c06403b4 100644
--- a/sound/core/seq/oss/seq_oss_ioctl.c
+++ b/sound/core/seq/oss/seq_oss_ioctl.c
@@ -85,7 +85,7 @@ snd_seq_oss_ioctl(struct seq_oss_devinfo *dp, unsigned int cmd, unsigned long ca
 			return 0;
 		while (snd_seq_oss_writeq_sync(dp->writeq))
 			;
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		return 0;
 
diff --git a/sound/core/seq/oss/seq_oss_rw.c b/sound/core/seq/oss/seq_oss_rw.c
index 8a142fd54..aaf76214d 100644
--- a/sound/core/seq/oss/seq_oss_rw.c
+++ b/sound/core/seq/oss/seq_oss_rw.c
@@ -47,7 +47,7 @@ snd_seq_oss_read(struct seq_oss_devinfo *dp, char __user *buf, int count)
 			snd_seq_oss_readq_unlock(readq, flags);
 			snd_seq_oss_readq_wait(readq);
 			snd_seq_oss_readq_lock(readq, flags);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				err = -ERESTARTSYS;
 			else
 				err = snd_seq_oss_readq_pick(readq, &rec);
diff --git a/sound/core/seq/oss/seq_oss_writeq.c b/sound/core/seq/oss/seq_oss_writeq.c
index 3e3209ce5..ee0e02ebe 100644
--- a/sound/core/seq/oss/seq_oss_writeq.c
+++ b/sound/core/seq/oss/seq_oss_writeq.c
@@ -108,7 +108,7 @@ snd_seq_oss_writeq_sync(struct seq_oss_writeq *q)
 	}
 
 	wait_event_interruptible_timeout(q->sync_sleep, ! q->sync_event_put, HZ);
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		/* interrupted - return 0 to finish sync */
 		q->sync_event_put = 0;
 	if (! q->sync_event_put || q->sync_time >= time)
diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c
index 2e9d695d3..f33ca6dda 100644
--- a/sound/core/seq/seq_clientmgr.c
+++ b/sound/core/seq/seq_clientmgr.c
@@ -365,7 +365,7 @@ static int snd_seq_open(struct inode *inode, struct file *file)
 	/* fill client data */
 	user->file = file;
 	sprintf(client->name, "Client-%d", c);
-	client->data.user.owner = get_pid(task_pid(current));
+	client->data.user.owner = get_pid(task_pid(sysiso_current));
 
 	/* make others aware this new client */
 	snd_seq_system_client_ev_client_start(c);
diff --git a/sound/core/seq/seq_fifo.c b/sound/core/seq/seq_fifo.c
index f8e02e987..30eb7eedc 100644
--- a/sound/core/seq/seq_fifo.c
+++ b/sound/core/seq/seq_fifo.c
@@ -184,7 +184,7 @@ int snd_seq_fifo_cell_out(struct snd_seq_fifo *f,
 		schedule();
 		spin_lock_irqsave(&f->lock, flags);
 		remove_wait_queue(&f->input_sleep, &wait);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			spin_unlock_irqrestore(&f->lock, flags);
 			return -ERESTARTSYS;
 		}
diff --git a/sound/core/seq/seq_memory.c b/sound/core/seq/seq_memory.c
index b7aee23fc..7c4e67519 100644
--- a/sound/core/seq/seq_memory.c
+++ b/sound/core/seq/seq_memory.c
@@ -241,7 +241,7 @@ static int snd_seq_cell_alloc(struct snd_seq_pool *pool,
 		spin_lock_irqsave(&pool->lock, flags);
 		remove_wait_queue(&pool->output_sleep, &wait);
 		/* interrupted? */
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			err = -ERESTARTSYS;
 			goto __error;
 		}
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 92b7008fc..50c5e484d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1768,7 +1768,7 @@ static int snd_timer_user_tselect(struct file *file,
 		err = -EFAULT;
 		goto __err;
 	}
-	sprintf(str, "application %i", current->pid);
+	sprintf(str, "application %i", sysiso_current->pid);
 	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
 		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
 	tu->timeri = snd_timer_instance_new(str);
@@ -1784,7 +1784,7 @@ static int snd_timer_user_tselect(struct file *file,
 	tu->timeri->callback_data = (void *)tu;
 	tu->timeri->disconnect = snd_timer_user_disconnect;
 
-	err = snd_timer_open(tu->timeri, &tselect.id, current->pid);
+	err = snd_timer_open(tu->timeri, &tselect.id, sysiso_current->pid);
 	if (err < 0) {
 		snd_timer_instance_free(tu->timeri);
 		tu->timeri = NULL;
@@ -2192,7 +2192,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 				err = -ENODEV;
 				goto _error;
 			}
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				err = -ERESTARTSYS;
 				goto _error;
 			}
diff --git a/sound/drivers/aloop.c b/sound/drivers/aloop.c
index 9b4a7cdb1..627b5747e 100644
--- a/sound/drivers/aloop.c
+++ b/sound/drivers/aloop.c
@@ -1150,7 +1150,8 @@ static int loopback_snd_timer_open(struct loopback_pcm *dpcm)
 	 * [proc1] Call snd_timer_open() and overwrite running timer
 	 *	   instance
 	 */
-	err = snd_timer_open(timeri, &cable->snd_timer.id, current->pid);
+	err = snd_timer_open(timeri, &cable->snd_timer.id,
+			     sysiso_current->pid);
 	if (err < 0) {
 		pcm_err(dpcm->substream->pcm,
 			"snd_timer_open (%d,%d,%d) failed with %d",
diff --git a/sound/firewire/bebob/bebob_hwdep.c b/sound/firewire/bebob/bebob_hwdep.c
index 6f9331655..ca6f9f091 100644
--- a/sound/firewire/bebob/bebob_hwdep.c
+++ b/sound/firewire/bebob/bebob_hwdep.c
@@ -30,7 +30,7 @@ hwdep_read(struct snd_hwdep *hwdep, char __user *buf,  long count,
 		spin_unlock_irq(&bebob->lock);
 		schedule();
 		finish_wait(&bebob->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&bebob->lock);
 	}
diff --git a/sound/firewire/dice/dice-hwdep.c b/sound/firewire/dice/dice-hwdep.c
index ffc0b9778..7c489f4fe 100644
--- a/sound/firewire/dice/dice-hwdep.c
+++ b/sound/firewire/dice/dice-hwdep.c
@@ -22,7 +22,7 @@ static long hwdep_read(struct snd_hwdep *hwdep, char __user *buf,
 		spin_unlock_irq(&dice->lock);
 		schedule();
 		finish_wait(&dice->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&dice->lock);
 	}
diff --git a/sound/firewire/digi00x/digi00x-hwdep.c b/sound/firewire/digi00x/digi00x-hwdep.c
index aadf7d724..9353891d8 100644
--- a/sound/firewire/digi00x/digi00x-hwdep.c
+++ b/sound/firewire/digi00x/digi00x-hwdep.c
@@ -30,7 +30,7 @@ static long hwdep_read(struct snd_hwdep *hwdep, char __user *buf,  long count,
 		spin_unlock_irq(&dg00x->lock);
 		schedule();
 		finish_wait(&dg00x->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&dg00x->lock);
 	}
diff --git a/sound/firewire/fireface/ff-hwdep.c b/sound/firewire/fireface/ff-hwdep.c
index ea64a2a41..5d56103ee 100644
--- a/sound/firewire/fireface/ff-hwdep.c
+++ b/sound/firewire/fireface/ff-hwdep.c
@@ -29,7 +29,7 @@ static long hwdep_read(struct snd_hwdep *hwdep, char __user *buf,  long count,
 		spin_unlock_irq(&ff->lock);
 		schedule();
 		finish_wait(&ff->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&ff->lock);
 	}
diff --git a/sound/firewire/fireworks/fireworks_hwdep.c b/sound/firewire/fireworks/fireworks_hwdep.c
index 626c0c34b..3eb85fc12 100644
--- a/sound/firewire/fireworks/fireworks_hwdep.c
+++ b/sound/firewire/fireworks/fireworks_hwdep.c
@@ -136,7 +136,7 @@ hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,
 		spin_unlock_irq(&efw->lock);
 		schedule();
 		finish_wait(&efw->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&efw->lock);
 		dev_lock_changed = efw->dev_lock_changed;
diff --git a/sound/firewire/motu/motu-hwdep.c b/sound/firewire/motu/motu-hwdep.c
index b5ced5d27..5aae0236c 100644
--- a/sound/firewire/motu/motu-hwdep.c
+++ b/sound/firewire/motu/motu-hwdep.c
@@ -30,7 +30,7 @@ static long hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,
 		spin_unlock_irq(&motu->lock);
 		schedule();
 		finish_wait(&motu->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&motu->lock);
 	}
diff --git a/sound/firewire/oxfw/oxfw-hwdep.c b/sound/firewire/oxfw/oxfw-hwdep.c
index a0fe99618..7d16421b0 100644
--- a/sound/firewire/oxfw/oxfw-hwdep.c
+++ b/sound/firewire/oxfw/oxfw-hwdep.c
@@ -29,7 +29,7 @@ static long hwdep_read(struct snd_hwdep *hwdep, char __user *buf,  long count,
 		spin_unlock_irq(&oxfw->lock);
 		schedule();
 		finish_wait(&oxfw->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&oxfw->lock);
 	}
diff --git a/sound/firewire/tascam/tascam-hwdep.c b/sound/firewire/tascam/tascam-hwdep.c
index 74eed9505..fe5ef891c 100644
--- a/sound/firewire/tascam/tascam-hwdep.c
+++ b/sound/firewire/tascam/tascam-hwdep.c
@@ -108,7 +108,7 @@ static long hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,
 		spin_unlock_irq(&tscm->lock);
 		schedule();
 		finish_wait(&tscm->hwdep_wait, &wait);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			return -ERESTARTSYS;
 		spin_lock_irq(&tscm->lock);
 	}
diff --git a/sound/isa/gus/gus_pcm.c b/sound/isa/gus/gus_pcm.c
index 230f65a0e..70cd7ae5b 100644
--- a/sound/isa/gus/gus_pcm.c
+++ b/sound/isa/gus/gus_pcm.c
@@ -331,7 +331,7 @@ static int snd_gf1_pcm_poke_block(struct snd_gus_card *gus, unsigned char *buf,
 		}
 		if (count > 0 && !in_interrupt()) {
 			schedule_timeout_interruptible(1);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				return -EAGAIN;
 		}
 	}
diff --git a/sound/isa/msnd/msnd.c b/sound/isa/msnd/msnd.c
index c3fd1eb30..3f653b667 100644
--- a/sound/isa/msnd/msnd.c
+++ b/sound/isa/msnd/msnd.c
@@ -207,7 +207,7 @@ static void snd_msnd_dsp_write_flush(struct snd_msnd *chip)
 		&chip->writeflush,
 		get_play_delay_jiffies(&chip, chip->DAPF.len));*/
 	clear_bit(F_WRITEFLUSH, &chip->flags);
-	if (!signal_pending(current))
+	if (!signal_pending(sysiso_current))
 		schedule_timeout_interruptible(
 			get_play_delay_jiffies(chip, chip->play_period_bytes));
 	clear_bit(F_WRITING, &chip->flags);
diff --git a/sound/isa/sb/emu8000.c b/sound/isa/sb/emu8000.c
index e02029677..df30caf4c 100644
--- a/sound/isa/sb/emu8000.c
+++ b/sound/isa/sb/emu8000.c
@@ -123,7 +123,7 @@ snd_emu8000_read_wait(struct snd_emu8000 *emu)
 {
 	while ((EMU8000_SMALR_READ(emu) & 0x80000000) != 0) {
 		schedule_timeout_interruptible(1);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 }
@@ -135,7 +135,7 @@ snd_emu8000_write_wait(struct snd_emu8000 *emu)
 {
 	while ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {
 		schedule_timeout_interruptible(1);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 }
@@ -434,7 +434,7 @@ size_dram(struct snd_emu8000 *emu)
 		if ((EMU8000_SMALW_READ(emu) & 0x80000000) == 0)
 			break;
 		schedule_timeout_interruptible(1);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 	snd_emu8000_dma_chan(emu, 0, EMU8000_RAM_CLOSE);
diff --git a/sound/isa/sb/emu8000_patch.c b/sound/isa/sb/emu8000_patch.c
index 8c1e7f2bf..d8bb1cc6a 100644
--- a/sound/isa/sb/emu8000_patch.c
+++ b/sound/isa/sb/emu8000_patch.c
@@ -99,7 +99,7 @@ snd_emu8000_write_wait(struct snd_emu8000 *emu)
 {
 	while ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {
 		schedule_timeout_interruptible(1);
-		if (signal_pending(current))
+		if (signal_pending(sysiso_current))
 			break;
 	}
 }
diff --git a/sound/isa/sb/emu8000_pcm.c b/sound/isa/sb/emu8000_pcm.c
index f8d90a1e9..401e4adb3 100644
--- a/sound/isa/sb/emu8000_pcm.c
+++ b/sound/isa/sb/emu8000_pcm.c
@@ -106,7 +106,7 @@ snd_emu8000_write_wait(struct snd_emu8000 *emu, int can_schedule)
 	while ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {
 		if (can_schedule) {
 			schedule_timeout_interruptible(1);
-			if (signal_pending(current))
+			if (signal_pending(sysiso_current))
 				break;
 		}
 	}
@@ -405,7 +405,7 @@ static int emu8k_pcm_trigger(struct snd_pcm_substream *subs, int cmd)
 #define CHECK_SCHEDULER() \
 do { \
 	cond_resched();\
-	if (signal_pending(current))\
+	if (signal_pending(sysiso_current))\
 		return -EAGAIN;\
 } while (0)
 
diff --git a/sound/isa/wavefront/wavefront_synth.c b/sound/isa/wavefront/wavefront_synth.c
index 69cbc79fb..de3eaef1b 100644
--- a/sound/isa/wavefront/wavefront_synth.c
+++ b/sound/isa/wavefront/wavefront_synth.c
@@ -269,7 +269,7 @@ wavefront_sleep (int limit)
 {
 	schedule_timeout_interruptible(limit);
 
-	return signal_pending(current);
+	return signal_pending(sysiso_current);
 }
 
 static int
diff --git a/sound/oss/dmasound/dmasound_core.c b/sound/oss/dmasound/dmasound_core.c
index 0c95828ac..3c11f5212 100644
--- a/sound/oss/dmasound/dmasound_core.c
+++ b/sound/oss/dmasound/dmasound_core.c
@@ -634,7 +634,7 @@ static ssize_t sq_write(struct file *file, const char __user *src, size_t uLeft,
 				break;
 
 			schedule_timeout(HZ);
-			if (signal_pending(current)) {
+			if (signal_pending(sysiso_current)) {
 				finish_wait(&write_sq.action_queue, &wait);
 				return uWritten > 0 ? uWritten : -EINTR;
 			}
@@ -857,7 +857,7 @@ static int sq_fsync(void)
 	while (write_sq.active) {
 		wait_event_interruptible_timeout(write_sq.sync_queue,
 						 !write_sq.active, HZ);
-		if (signal_pending(current)) {
+		if (signal_pending(sysiso_current)) {
 			/* While waiting for audio output to drain, an
 			 * interrupt occurred.  Stop audio output immediately
 			 * and clear the queue. */
diff --git a/sound/pci/korg1212/korg1212.c b/sound/pci/korg1212/korg1212.c
index 5c9e240ff..2f46eddbc 100644
--- a/sound/pci/korg1212/korg1212.c
+++ b/sound/pci/korg1212/korg1212.c
@@ -1387,7 +1387,7 @@ static int snd_korg1212_playback_open(struct snd_pcm_substream *substream)
         spin_lock_irqsave(&korg1212->lock, flags);
 
         korg1212->playback_substream = substream;
-	korg1212->playback_pid = current->pid;
+	korg1212->playback_pid = sysiso_current->pid;
         korg1212->periodsize = K1212_PERIODS;
 	korg1212->channels = K1212_CHANNELS;
 	korg1212->errorcnt = 0;
@@ -1418,7 +1418,7 @@ static int snd_korg1212_capture_open(struct snd_pcm_substream *substream)
         spin_lock_irqsave(&korg1212->lock, flags);
 
         korg1212->capture_substream = substream;
-	korg1212->capture_pid = current->pid;
+	korg1212->capture_pid = sysiso_current->pid;
         korg1212->periodsize = K1212_PERIODS;
 	korg1212->channels = K1212_CHANNELS;
 
diff --git a/sound/pci/rme9652/hdsp.c b/sound/pci/rme9652/hdsp.c
index 75aa2ea73..e124476d1 100644
--- a/sound/pci/rme9652/hdsp.c
+++ b/sound/pci/rme9652/hdsp.c
@@ -4509,7 +4509,7 @@ static int snd_hdsp_playback_open(struct snd_pcm_substream *substream)
         runtime->hw = snd_hdsp_playback_subinfo;
 	snd_pcm_set_runtime_buffer(substream, hdsp->playback_dma_buf);
 
-	hdsp->playback_pid = current->pid;
+	hdsp->playback_pid = sysiso_current->pid;
 	hdsp->playback_substream = substream;
 
 	spin_unlock_irq(&hdsp->lock);
@@ -4585,7 +4585,7 @@ static int snd_hdsp_capture_open(struct snd_pcm_substream *substream)
 	runtime->hw = snd_hdsp_capture_subinfo;
 	snd_pcm_set_runtime_buffer(substream, hdsp->capture_dma_buf);
 
-	hdsp->capture_pid = current->pid;
+	hdsp->capture_pid = sysiso_current->pid;
 	hdsp->capture_substream = substream;
 
 	spin_unlock_irq(&hdsp->lock);
diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ff06ee826..0be5ab5b4 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6059,13 +6059,13 @@ static int snd_hdspm_open(struct snd_pcm_substream *substream)
 		if (!hdspm->capture_substream)
 			hdspm_stop_audio(hdspm);
 
-		hdspm->playback_pid = current->pid;
+		hdspm->playback_pid = sysiso_current->pid;
 		hdspm->playback_substream = substream;
 	} else {
 		if (!hdspm->playback_substream)
 			hdspm_stop_audio(hdspm);
 
-		hdspm->capture_pid = current->pid;
+		hdspm->capture_pid = sysiso_current->pid;
 		hdspm->capture_substream = substream;
 	}
 
diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index e76f737ac..fc00e3313 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2266,7 +2266,7 @@ static int snd_rme9652_playback_open(struct snd_pcm_substream *substream)
 		rme9652_set_thru(rme9652, -1, 0);
 	}
 
-	rme9652->playback_pid = current->pid;
+	rme9652->playback_pid = sysiso_current->pid;
 	rme9652->playback_substream = substream;
 
 	spin_unlock_irq(&rme9652->lock);
@@ -2325,7 +2325,7 @@ static int snd_rme9652_capture_open(struct snd_pcm_substream *substream)
 		rme9652_set_thru(rme9652, -1, 0);
 	}
 
-	rme9652->capture_pid = current->pid;
+	rme9652->capture_pid = sysiso_current->pid;
 	rme9652->capture_substream = substream;
 
 	spin_unlock_irq(&rme9652->lock);
diff --git a/sound/soc/sof/trace.c b/sound/soc/sof/trace.c
index 58f6ca5cf..865100115 100644
--- a/sound/soc/sof/trace.c
+++ b/sound/soc/sof/trace.c
@@ -276,7 +276,7 @@ static size_t sof_wait_trace_avail(struct snd_sof_dev *sdev,
 	set_current_state(TASK_INTERRUPTIBLE);
 	add_wait_queue(&sdev->trace_sleep, &wait);
 
-	if (!signal_pending(current)) {
+	if (!signal_pending(sysiso_current)) {
 		/* set timeout to max value, no error code */
 		schedule_timeout(MAX_SCHEDULE_TIMEOUT);
 	}
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 7851f3a1b..ae09d39ff 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -935,7 +935,8 @@ static int kvm_create_vm_debugfs(struct kvm *kvm, int fd)
 	if (!debugfs_initialized())
 		return 0;
 
-	snprintf(dir_name, sizeof(dir_name), "%d-%d", task_pid_nr(current), fd);
+	snprintf(dir_name, sizeof(dir_name), "%d-%d",
+		 task_pid_nr(sysiso_current), fd);
 	mutex_lock(&kvm_debugfs_lock);
 	dent = debugfs_lookup(dir_name, kvm_debugfs_dir);
 	if (dent) {
@@ -3180,7 +3181,7 @@ static int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)
 	}
 	if (kvm_cpu_has_pending_timer(vcpu))
 		goto out;
-	if (signal_pending(current))
+	if (signal_pending(sysiso_current))
 		goto out;
 	if (kvm_check_request(KVM_REQ_UNBLOCK, vcpu))
 		goto out;
@@ -3641,7 +3642,7 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 
 	/* Fill the stats id string for the vcpu */
 	snprintf(vcpu->stats_id, sizeof(vcpu->stats_id), "kvm-%d/vcpu-%d",
-		 task_pid_nr(current), id);
+		 task_pid_nr(sysiso_current), id);
 
 	/* Now it's all set up, let userspace reach it */
 	kvm_get_kvm(kvm);
@@ -4623,7 +4624,7 @@ static int kvm_dev_ioctl_create_vm(unsigned long type)
 		goto put_kvm;
 
 	snprintf(kvm->stats_id, sizeof(kvm->stats_id),
-			"kvm-%d", task_pid_nr(current));
+			"kvm-%d", task_pid_nr(sysiso_current));
 
 	file = anon_inode_getfile("kvm-vm", &kvm_vm_fops, kvm, O_RDWR);
 	if (IS_ERR(file)) {
@@ -5336,7 +5337,7 @@ static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)
 
 	if (type == KVM_EVENT_CREATE_VM) {
 		add_uevent_var(env, "EVENT=create");
-		kvm->userspace_pid = task_pid_nr(current);
+		kvm->userspace_pid = task_pid_nr(sysiso_current);
 	} else if (type == KVM_EVENT_DESTROY_VM) {
 		add_uevent_var(env, "EVENT=destroy");
 	}
@@ -5675,7 +5676,7 @@ int kvm_vm_create_worker_thread(struct kvm *kvm, kvm_vm_thread_fn_t thread_fn,
 	init_completion(&init_context.init_done);
 
 	thread = kthread_run(kvm_vm_worker_thread, &init_context,
-			     "%s-%d", name, task_pid_nr(current));
+			     "%s-%d", name, task_pid_nr(sysiso_current));
 	if (IS_ERR(thread))
 		return PTR_ERR(thread);
 
